
../../../bin/gsi_parse_json_server:     file format elf64-x86-64
../../../bin/gsi_parse_json_server
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000000401960

Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000400040 paddr 0x0000000000400040 align 2**3
         filesz 0x00000000000001f8 memsz 0x00000000000001f8 flags r-x
  INTERP off    0x0000000000000238 vaddr 0x0000000000400238 paddr 0x0000000000400238 align 2**0
         filesz 0x000000000000001c memsz 0x000000000000001c flags r--
    LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21
         filesz 0x000000000000ad84 memsz 0x000000000000ad84 flags r-x
    LOAD off    0x000000000000adf0 vaddr 0x000000000060adf0 paddr 0x000000000060adf0 align 2**21
         filesz 0x00000000000004b8 memsz 0x0000000000000668 flags rw-
 DYNAMIC off    0x000000000000ae08 vaddr 0x000000000060ae08 paddr 0x000000000060ae08 align 2**3
         filesz 0x00000000000001f0 memsz 0x00000000000001f0 flags rw-
    NOTE off    0x0000000000000254 vaddr 0x0000000000400254 paddr 0x0000000000400254 align 2**2
         filesz 0x0000000000000044 memsz 0x0000000000000044 flags r--
EH_FRAME off    0x000000000000a074 vaddr 0x000000000040a074 paddr 0x000000000040a074 align 2**2
         filesz 0x0000000000000244 memsz 0x0000000000000244 flags r--
   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
   RELRO off    0x000000000000adf0 vaddr 0x000000000060adf0 paddr 0x000000000060adf0 align 2**0
         filesz 0x0000000000000210 memsz 0x0000000000000210 flags r--

Dynamic Section:
  NEEDED               libjson-c.so.2
  NEEDED               libpthread.so.0
  NEEDED               libc.so.6
  INIT                 0x0000000000401510
  FINI                 0x0000000000407da4
  INIT_ARRAY           0x000000000060adf0
  INIT_ARRAYSZ         0x0000000000000008
  FINI_ARRAY           0x000000000060adf8
  FINI_ARRAYSZ         0x0000000000000008
  GNU_HASH             0x0000000000400298
  STRTAB               0x00000000004009f8
  SYMTAB               0x00000000004002d8
  STRSZ                0x00000000000003b6
  SYMENT               0x0000000000000018
  DEBUG                0x0000000000000000
  PLTGOT               0x000000000060b000
  PLTRELSZ             0x0000000000000618
  PLTREL               0x0000000000000007
  JMPREL               0x0000000000400ef8
  RELA                 0x0000000000400ec8
  RELASZ               0x0000000000000030
  RELAENT              0x0000000000000018
  VERNEED              0x0000000000400e48
  VERNEEDNUM           0x0000000000000002
  VERSYM               0x0000000000400dae

Version References:
  required from libpthread.so.0:
    0x09691972 0x00 04 GLIBC_2.3.2
    0x09691a75 0x00 03 GLIBC_2.2.5
  required from libc.so.6:
    0x0d696913 0x00 07 GLIBC_2.3
    0x06969194 0x00 06 GLIBC_2.14
    0x0d696914 0x00 05 GLIBC_2.4
    0x09691a75 0x00 02 GLIBC_2.2.5

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001c  0000000000400238  0000000000400238  00000238  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.ABI-tag 00000020  0000000000400254  0000000000400254  00000254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.gnu.build-id 00000024  0000000000400274  0000000000400274  00000274  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .gnu.hash     0000003c  0000000000400298  0000000000400298  00000298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .dynsym       00000720  00000000004002d8  00000000004002d8  000002d8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dynstr       000003b6  00000000004009f8  00000000004009f8  000009f8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .gnu.version  00000098  0000000000400dae  0000000000400dae  00000dae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .gnu.version_r 00000080  0000000000400e48  0000000000400e48  00000e48  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rela.dyn     00000030  0000000000400ec8  0000000000400ec8  00000ec8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rela.plt     00000618  0000000000400ef8  0000000000400ef8  00000ef8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .init         0000001a  0000000000401510  0000000000401510  00001510  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .plt          00000420  0000000000401530  0000000000401530  00001530  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt.got      00000008  0000000000401950  0000000000401950  00001950  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text         00006442  0000000000401960  0000000000401960  00001960  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .fini         00000009  0000000000407da4  0000000000407da4  00007da4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .rodata       000022c1  0000000000407db0  0000000000407db0  00007db0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 16 .eh_frame_hdr 00000244  000000000040a074  000000000040a074  0000a074  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 17 .eh_frame     00000acc  000000000040a2b8  000000000040a2b8  0000a2b8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 18 .init_array   00000008  000000000060adf0  000000000060adf0  0000adf0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 19 .fini_array   00000008  000000000060adf8  000000000060adf8  0000adf8  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 20 .jcr          00000008  000000000060ae00  000000000060ae00  0000ae00  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 21 .dynamic      000001f0  000000000060ae08  000000000060ae08  0000ae08  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 22 .got          00000008  000000000060aff8  000000000060aff8  0000aff8  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 23 .got.plt      00000220  000000000060b000  000000000060b000  0000b000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 24 .data         00000088  000000000060b220  000000000060b220  0000b220  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 25 .bss          00000198  000000000060b2c0  000000000060b2c0  0000b2a8  2**5
                  ALLOC
 26 .comment      00000035  0000000000000000  0000000000000000  0000b2a8  2**0
                  CONTENTS, READONLY
 27 .debug_aranges 00000120  0000000000000000  0000000000000000  0000b2dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_info   00003653  0000000000000000  0000000000000000  0000b3fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_abbrev 00000a3e  0000000000000000  0000000000000000  0000ea50  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .debug_line   000023a3  0000000000000000  0000000000000000  0000f48e  2**0
                  CONTENTS, READONLY, DEBUGGING
 31 .debug_str    000112b9  0000000000000000  0000000000000000  00011831  2**0
                  CONTENTS, READONLY, DEBUGGING
 32 .debug_macro  000059b4  0000000000000000  0000000000000000  00022aea  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
0000000000400238 l    d  .interp	0000000000000000              .interp
0000000000400254 l    d  .note.ABI-tag	0000000000000000              .note.ABI-tag
0000000000400274 l    d  .note.gnu.build-id	0000000000000000              .note.gnu.build-id
0000000000400298 l    d  .gnu.hash	0000000000000000              .gnu.hash
00000000004002d8 l    d  .dynsym	0000000000000000              .dynsym
00000000004009f8 l    d  .dynstr	0000000000000000              .dynstr
0000000000400dae l    d  .gnu.version	0000000000000000              .gnu.version
0000000000400e48 l    d  .gnu.version_r	0000000000000000              .gnu.version_r
0000000000400ec8 l    d  .rela.dyn	0000000000000000              .rela.dyn
0000000000400ef8 l    d  .rela.plt	0000000000000000              .rela.plt
0000000000401510 l    d  .init	0000000000000000              .init
0000000000401530 l    d  .plt	0000000000000000              .plt
0000000000401950 l    d  .plt.got	0000000000000000              .plt.got
0000000000401960 l    d  .text	0000000000000000              .text
0000000000407da4 l    d  .fini	0000000000000000              .fini
0000000000407db0 l    d  .rodata	0000000000000000              .rodata
000000000040a074 l    d  .eh_frame_hdr	0000000000000000              .eh_frame_hdr
000000000040a2b8 l    d  .eh_frame	0000000000000000              .eh_frame
000000000060adf0 l    d  .init_array	0000000000000000              .init_array
000000000060adf8 l    d  .fini_array	0000000000000000              .fini_array
000000000060ae00 l    d  .jcr	0000000000000000              .jcr
000000000060ae08 l    d  .dynamic	0000000000000000              .dynamic
000000000060aff8 l    d  .got	0000000000000000              .got
000000000060b000 l    d  .got.plt	0000000000000000              .got.plt
000000000060b220 l    d  .data	0000000000000000              .data
000000000060b2c0 l    d  .bss	0000000000000000              .bss
0000000000000000 l    d  .comment	0000000000000000              .comment
0000000000000000 l    d  .debug_aranges	0000000000000000              .debug_aranges
0000000000000000 l    d  .debug_info	0000000000000000              .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000              .debug_abbrev
0000000000000000 l    d  .debug_line	0000000000000000              .debug_line
0000000000000000 l    d  .debug_str	0000000000000000              .debug_str
0000000000000000 l    d  .debug_macro	0000000000000000              .debug_macro
0000000000000000 l    df *ABS*	0000000000000000              crtstuff.c
000000000060ae00 l     O .jcr	0000000000000000              __JCR_LIST__
0000000000401990 l     F .text	0000000000000000              deregister_tm_clones
00000000004019d0 l     F .text	0000000000000000              register_tm_clones
0000000000401a10 l     F .text	0000000000000000              __do_global_dtors_aux
000000000060b2c8 l     O .bss	0000000000000001              completed.7594
000000000060adf8 l     O .fini_array	0000000000000000              __do_global_dtors_aux_fini_array_entry
0000000000401a30 l     F .text	0000000000000000              frame_dummy
000000000060adf0 l     O .init_array	0000000000000000              __frame_dummy_init_array_entry
0000000000000000 l    df *ABS*	0000000000000000              gsi_parse_json_server.c
000000000060b2d0 l     O .bss	0000000000000008              g_arr_strings
0000000000401b85 l     F .text	0000000000000392              gsi_server_init_strings
000000000040201b l     F .text	00000000000001f9              gsi_server_init_clients
0000000000401f17 l     F .text	0000000000000104              gsi_server_clean_strings
0000000000402214 l     F .text	0000000000000172              gsi_server_thread_parse_client
000000000040269d l     F .text	00000000000002a0              gsi_server_infinite_service
0000000000402386 l     F .text	0000000000000317              gsi_server_timed_service
0000000000403199 l     F .text	0000000000000044              gsi_server_port_to_client
000000000040293d l     F .text	000000000000011e              gsi_server_handle_op_code
0000000000402a5b l     F .text	000000000000008a              gsi_server_handle_read_str
0000000000402ae5 l     F .text	0000000000000163              gsi_server_handle_write_str
0000000000402c48 l     F .text	000000000000021d              gsi_server_handle_read_file
0000000000402e65 l     F .text	00000000000000ec              gsi_server_handle_write_file
0000000000402f51 l     F .text	000000000000001f              gsi_server_handle_print_log
0000000000402f70 l     F .text	0000000000000229              gsi_server_handle_read_file_by_id
0000000000000000 l    df *ABS*	0000000000000000              gsi_build_parse_data.c
000000000040440e l     F .text	0000000000000264              gsi_build_parse_json_obj_to_string
0000000000404c86 l     F .text	00000000000000d9              gsi_build_parse_strdup
0000000000404672 l     F .text	00000000000000c2              gsi_build_parse_string_to_json_object
0000000000404734 l     F .text	0000000000000126              gsi_build_parse_json_object_to_json_msg
0000000000403bc4 l     F .text	0000000000000191              gsi_build_parse_build_msg
0000000000403d55 l     F .text	00000000000000ef              gsi_build_parse_get_msg_type
0000000000403e44 l     F .text	00000000000001d2              gsi_build_parse_get_msg_op_code
00000000004041b9 l     F .text	0000000000000255              gsi_build_parse_set_op_code_args
0000000000404016 l     F .text	0000000000000093              gsi_build_parse_get_msg_index
00000000004040a9 l     F .text	0000000000000065              gsi_build_parse_get_msg_len
000000000040410e l     F .text	00000000000000ab              gsi_build_parse_get_msg_content
0000000000404b55 l     F .text	0000000000000131              gsi_build_parse_get_file_name
0000000000404d5f l     F .text	000000000000004b              gsi_build_parse_op_code_to_string
000000000040485a l     F .text	00000000000002fb              gsi_build_parse_handle_op_code
0000000000000000 l    df *ABS*	0000000000000000              gsi_is_network_tcp.c
0000000000405dda l     F .text	0000000000000130              set_address_parameters
0000000000405f0a l     F .text	0000000000000599              read_check_heartbeat
0000000000000000 l    df *ABS*	0000000000000000              gsi_is_logger.c
000000000040697e l     F .text	00000000000000a4              thread_write_log
000000000060b2f0 l     O .bss	0000000000000014              s_time_stamp.3555
0000000000000000 l    df *ABS*	0000000000000000              gsi_parse_json_config.c
000000000060b240 l     O .data	0000000000000020              g_config_cmd_opts
000000000060b260 l     O .data	0000000000000048              g_config_params_keys
0000000000407467 l     F .text	00000000000000a5              gsi_parse_json_config_init_default_params
000000000040750c l     F .text	00000000000001a3              gsi_parse_json_config_init_from_config_file
0000000000407065 l     F .text	0000000000000402              gsi_parse_json_config_parse_main_args
0000000000000000 l    df *ABS*	0000000000000000              gsi_thread_pool.c
0000000000407b43 l     F .text	0000000000000150              gsi_is_thread_run
0000000000407c93 l     F .text	0000000000000094              gsi_is_thread_pool_free
0000000000000000 l    df *ABS*	0000000000000000              crtstuff.c
000000000040ad80 l     O .eh_frame	0000000000000000              __FRAME_END__
000000000060ae00 l     O .jcr	0000000000000000              __JCR_END__
0000000000000000 l    df *ABS*	0000000000000000              
000000000060adf8 l       .init_array	0000000000000000              __init_array_end
000000000060ae08 l     O .dynamic	0000000000000000              _DYNAMIC
000000000060adf0 l       .init_array	0000000000000000              __init_array_start
000000000040a074 l       .eh_frame_hdr	0000000000000000              __GNU_EH_FRAME_HDR
000000000060b000 l     O .got.plt	0000000000000000              _GLOBAL_OFFSET_TABLE_
0000000000407da0 g     F .text	0000000000000002              __libc_csu_fini
0000000000000000       F *UND*	0000000000000000              json_tokener_parse
0000000000000000       F *UND*	0000000000000000              free@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_create@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              localtime@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              strncmp@@GLIBC_2.2.5
0000000000000000  w      *UND*	0000000000000000              _ITM_deregisterTMCloneTable
000000000060b220  w      .data	0000000000000000              data_start
00000000004076af g     F .text	000000000000027c              gsi_is_thread_pool_create
0000000000000000       F *UND*	0000000000000000              strcpy@@GLIBC_2.2.5
00000000004031dd g     F .text	00000000000000bf              gsi_is_open_msg_file
0000000000000000       F *UND*	0000000000000000              pthread_cond_broadcast@@GLIBC_2.3.2
0000000000403a51 g     F .text	0000000000000173              gsi_is_get_next_msg
0000000000000000       F *UND*	0000000000000000              puts@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              setsockopt@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_new_string
0000000000000000       F *UND*	0000000000000000              write@@GLIBC_2.2.5
0000000000405c6a g     F .text	0000000000000170              gsi_is_network_tcp_server_cleanup
0000000000403521 g     F .text	00000000000002df              gsi_is_send_json_msg
000000000060b2a8 g       .data	0000000000000000              _edata
0000000000000000       F *UND*	0000000000000000              pthread_cond_wait@@GLIBC_2.3.2
0000000000000000       F *UND*	0000000000000000              fclose@@GLIBC_2.2.5
0000000000407da4 g     F .fini	0000000000000000              _fini
000000000040329c g     F .text	00000000000000ac              gsi_is_close_msg_file
0000000000000000       F *UND*	0000000000000000              json_object_get_string
0000000000000000       F *UND*	0000000000000000              strlen@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              __stack_chk_fail@@GLIBC_2.4
0000000000000000       F *UND*	0000000000000000              json_object_new_object
0000000000000000       F *UND*	0000000000000000              getopt_long@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              htons@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              strchr@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              printf@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_mutex_destroy@@GLIBC_2.2.5
0000000000406a22 g     F .text	00000000000000c6              gsi_parse_json_config_open
0000000000000000       F *UND*	0000000000000000              fputs@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              memset@@GLIBC_2.2.5
0000000000406de8 g     F .text	0000000000000103              gsi_parse_json_config_get_next_entry
0000000000404f38 g     F .text	0000000000000165              gsi_is_network_tcp_connect
0000000000000000       F *UND*	0000000000000000              close@@GLIBC_2.2.5
000000000040792b g     F .text	000000000000011d              gsi_is_thread_pool_add
0000000000403348 g     F .text	00000000000000ae              gsi_build_parse_reset_object
0000000000000000       F *UND*	0000000000000000              read@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              __libc_start_main@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_to_json_string_ext
0000000000000000       F *UND*	0000000000000000              fgets@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_get_int
0000000000405a68 g     F .text	0000000000000202              gsi_is_network_tcp_server_read
0000000000000000       F *UND*	0000000000000000              calloc@@GLIBC_2.2.5
000000000060b220 g       .data	0000000000000000              __data_start
0000000000000000       F *UND*	0000000000000000              strcmp@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_new_int
000000000060b2c0 g     O .bss	0000000000000008              optarg@@GLIBC_2.2.5
00000000004057f3 g     F .text	0000000000000275              gsi_is_network_tcp_server_poll
0000000000000000       F *UND*	0000000000000000              fprintf@@GLIBC_2.2.5
0000000000403800 g     F .text	0000000000000251              gsi_is_recv_json_msg
0000000000000000       F *UND*	0000000000000000              feof@@GLIBC_2.2.5
0000000000000000  w      *UND*	0000000000000000              __gmon_start__
0000000000000000       F *UND*	0000000000000000              strtol@@GLIBC_2.2.5
000000000060b228 g     O .data	0000000000000000              .hidden __dso_handle
0000000000000000       F *UND*	0000000000000000              memcpy@@GLIBC_2.14
00000000004066c0 g     F .text	00000000000001bd              gsi_is_write_to_log
0000000000407db0 g     O .rodata	0000000000000004              _IO_stdin_used
000000000060b2e8 g     O .bss	0000000000000008              g_p_log_file
0000000000000000       F *UND*	0000000000000000              inet_pton@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              time@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_object_add
0000000000000000       F *UND*	0000000000000000              pthread_cond_init@@GLIBC_2.3.2
00000000004052db g     F .text	00000000000001de              gsi_is_network_tcp_client_init
0000000000000000       F *UND*	0000000000000000              pthread_mutex_unlock@@GLIBC_2.2.5
0000000000407d30 g     F .text	0000000000000065              __libc_csu_init
000000000060b320 g     O .bss	00000000000000a0              g_config_server_params
0000000000000000       F *UND*	0000000000000000              malloc@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              fflush@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              listen@@GLIBC_2.2.5
000000000060b458 g       .bss	0000000000000000              _end
00000000004033f6 g     F .text	000000000000012b              gsi_is_send_all_json_msg
000000000040687d g     F .text	000000000000005f              gsi_is_close_log
0000000000401960 g     F .text	000000000000002a              _start
000000000060b2e0 g     O .bss	0000000000000008              g_p_thread_pool
000000000060b3c0 g     O .bss	0000000000000094              g_config_client_params
0000000000000000       F *UND*	0000000000000000              realloc@@GLIBC_2.2.5
000000000060b2a8 g       .bss	0000000000000000              __bss_start
0000000000401a56 g     F .text	000000000000012f              main
0000000000000000       F *UND*	0000000000000000              poll@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              bind@@GLIBC_2.2.5
0000000000406ae8 g     F .text	00000000000000ac              gsi_parse_json_config_close
0000000000000000       F *UND*	0000000000000000              vsprintf@@GLIBC_2.2.5
0000000000406b94 g     F .text	0000000000000254              gsi_parse_json_config_read_line
0000000000000000       F *UND*	0000000000000000              pthread_self@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_cond_destroy@@GLIBC_2.3.2
0000000000000000       F *UND*	0000000000000000              fopen@@GLIBC_2.2.5
000000000040509d g     F .text	000000000000023e              gsi_is_network_tcp_send
0000000000000000       F *UND*	0000000000000000              perror@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_join@@GLIBC_2.2.5
0000000000000000  w      *UND*	0000000000000000              _Jv_RegisterClasses
0000000000406664 g     F .text	000000000000005c              gsi_is_title_to_log
00000000004054b9 g     F .text	000000000000033a              gsi_is_network_tcp_server_init
00000000004064a3 g     F .text	00000000000001b4              gsi_is_create_log_file
0000000000000000       F *UND*	0000000000000000              accept@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              atoi@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_object_get
0000000000404daa g     F .text	0000000000000074              gsi_is_network_tcp_reset
0000000000000000       F *UND*	0000000000000000              sprintf@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              connect@@GLIBC_2.2.5
000000000060b2a8 g     O .data	0000000000000000              .hidden __TMC_END__
0000000000000000  w      *UND*	0000000000000000              _ITM_registerTMCloneTable
0000000000407a48 g     F .text	00000000000000fb              gsi_is_thread_pool_destroy
0000000000406657 g     F .text	000000000000000d              gsi_get_saved_file
00000000004068dc g     F .text	00000000000000a2              gsi_is_gen_timestamp
0000000000000000       F *UND*	0000000000000000              sleep@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_mutex_init@@GLIBC_2.2.5
0000000000401510 g     F .init	0000000000000000              _init
0000000000000000       F *UND*	0000000000000000              json_object_put
0000000000000000       F *UND*	0000000000000000              pthread_mutex_lock@@GLIBC_2.2.5
0000000000406eeb g     F .text	000000000000017a              gsi_parse_json_config_get_config
0000000000404e1e g     F .text	000000000000011a              gsi_is_network_tcp_set_sockaddr
0000000000000000       F *UND*	0000000000000000              __ctype_b_loc@@GLIBC_2.3
0000000000000000       F *UND*	0000000000000000              socket@@GLIBC_2.2.5



Disassembly of section .init:

0000000000401510 <_init>:
  401510:	48 83 ec 08          	sub    $0x8,%rsp
  401514:	48 8b 05 dd 9a 20 00 	mov    0x209add(%rip),%rax        # 60aff8 <_DYNAMIC+0x1f0>
  40151b:	48 85 c0             	test   %rax,%rax
  40151e:	74 05                	je     401525 <_init+0x15>
  401520:	e8 2b 04 00 00       	callq  401950 <socket@plt+0x10>
  401525:	48 83 c4 08          	add    $0x8,%rsp
  401529:	c3                   	retq   

Disassembly of section .plt:

0000000000401530 <json_tokener_parse@plt-0x10>:
  401530:	ff 35 d2 9a 20 00    	pushq  0x209ad2(%rip)        # 60b008 <_GLOBAL_OFFSET_TABLE_+0x8>
  401536:	ff 25 d4 9a 20 00    	jmpq   *0x209ad4(%rip)        # 60b010 <_GLOBAL_OFFSET_TABLE_+0x10>
  40153c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401540 <json_tokener_parse@plt>:
  401540:	ff 25 d2 9a 20 00    	jmpq   *0x209ad2(%rip)        # 60b018 <_GLOBAL_OFFSET_TABLE_+0x18>
  401546:	68 00 00 00 00       	pushq  $0x0
  40154b:	e9 e0 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401550 <free@plt>:
  401550:	ff 25 ca 9a 20 00    	jmpq   *0x209aca(%rip)        # 60b020 <_GLOBAL_OFFSET_TABLE_+0x20>
  401556:	68 01 00 00 00       	pushq  $0x1
  40155b:	e9 d0 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401560 <pthread_create@plt>:
  401560:	ff 25 c2 9a 20 00    	jmpq   *0x209ac2(%rip)        # 60b028 <_GLOBAL_OFFSET_TABLE_+0x28>
  401566:	68 02 00 00 00       	pushq  $0x2
  40156b:	e9 c0 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401570 <localtime@plt>:
  401570:	ff 25 ba 9a 20 00    	jmpq   *0x209aba(%rip)        # 60b030 <_GLOBAL_OFFSET_TABLE_+0x30>
  401576:	68 03 00 00 00       	pushq  $0x3
  40157b:	e9 b0 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401580 <strncmp@plt>:
  401580:	ff 25 b2 9a 20 00    	jmpq   *0x209ab2(%rip)        # 60b038 <_GLOBAL_OFFSET_TABLE_+0x38>
  401586:	68 04 00 00 00       	pushq  $0x4
  40158b:	e9 a0 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401590 <strcpy@plt>:
  401590:	ff 25 aa 9a 20 00    	jmpq   *0x209aaa(%rip)        # 60b040 <_GLOBAL_OFFSET_TABLE_+0x40>
  401596:	68 05 00 00 00       	pushq  $0x5
  40159b:	e9 90 ff ff ff       	jmpq   401530 <_init+0x20>

00000000004015a0 <pthread_cond_broadcast@plt>:
  4015a0:	ff 25 a2 9a 20 00    	jmpq   *0x209aa2(%rip)        # 60b048 <_GLOBAL_OFFSET_TABLE_+0x48>
  4015a6:	68 06 00 00 00       	pushq  $0x6
  4015ab:	e9 80 ff ff ff       	jmpq   401530 <_init+0x20>

00000000004015b0 <puts@plt>:
  4015b0:	ff 25 9a 9a 20 00    	jmpq   *0x209a9a(%rip)        # 60b050 <_GLOBAL_OFFSET_TABLE_+0x50>
  4015b6:	68 07 00 00 00       	pushq  $0x7
  4015bb:	e9 70 ff ff ff       	jmpq   401530 <_init+0x20>

00000000004015c0 <setsockopt@plt>:
  4015c0:	ff 25 92 9a 20 00    	jmpq   *0x209a92(%rip)        # 60b058 <_GLOBAL_OFFSET_TABLE_+0x58>
  4015c6:	68 08 00 00 00       	pushq  $0x8
  4015cb:	e9 60 ff ff ff       	jmpq   401530 <_init+0x20>

00000000004015d0 <json_object_new_string@plt>:
  4015d0:	ff 25 8a 9a 20 00    	jmpq   *0x209a8a(%rip)        # 60b060 <_GLOBAL_OFFSET_TABLE_+0x60>
  4015d6:	68 09 00 00 00       	pushq  $0x9
  4015db:	e9 50 ff ff ff       	jmpq   401530 <_init+0x20>

00000000004015e0 <write@plt>:
  4015e0:	ff 25 82 9a 20 00    	jmpq   *0x209a82(%rip)        # 60b068 <_GLOBAL_OFFSET_TABLE_+0x68>
  4015e6:	68 0a 00 00 00       	pushq  $0xa
  4015eb:	e9 40 ff ff ff       	jmpq   401530 <_init+0x20>

00000000004015f0 <pthread_cond_wait@plt>:
  4015f0:	ff 25 7a 9a 20 00    	jmpq   *0x209a7a(%rip)        # 60b070 <_GLOBAL_OFFSET_TABLE_+0x70>
  4015f6:	68 0b 00 00 00       	pushq  $0xb
  4015fb:	e9 30 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401600 <fclose@plt>:
  401600:	ff 25 72 9a 20 00    	jmpq   *0x209a72(%rip)        # 60b078 <_GLOBAL_OFFSET_TABLE_+0x78>
  401606:	68 0c 00 00 00       	pushq  $0xc
  40160b:	e9 20 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401610 <json_object_get_string@plt>:
  401610:	ff 25 6a 9a 20 00    	jmpq   *0x209a6a(%rip)        # 60b080 <_GLOBAL_OFFSET_TABLE_+0x80>
  401616:	68 0d 00 00 00       	pushq  $0xd
  40161b:	e9 10 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401620 <strlen@plt>:
  401620:	ff 25 62 9a 20 00    	jmpq   *0x209a62(%rip)        # 60b088 <_GLOBAL_OFFSET_TABLE_+0x88>
  401626:	68 0e 00 00 00       	pushq  $0xe
  40162b:	e9 00 ff ff ff       	jmpq   401530 <_init+0x20>

0000000000401630 <__stack_chk_fail@plt>:
  401630:	ff 25 5a 9a 20 00    	jmpq   *0x209a5a(%rip)        # 60b090 <_GLOBAL_OFFSET_TABLE_+0x90>
  401636:	68 0f 00 00 00       	pushq  $0xf
  40163b:	e9 f0 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401640 <json_object_new_object@plt>:
  401640:	ff 25 52 9a 20 00    	jmpq   *0x209a52(%rip)        # 60b098 <_GLOBAL_OFFSET_TABLE_+0x98>
  401646:	68 10 00 00 00       	pushq  $0x10
  40164b:	e9 e0 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401650 <getopt_long@plt>:
  401650:	ff 25 4a 9a 20 00    	jmpq   *0x209a4a(%rip)        # 60b0a0 <_GLOBAL_OFFSET_TABLE_+0xa0>
  401656:	68 11 00 00 00       	pushq  $0x11
  40165b:	e9 d0 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401660 <htons@plt>:
  401660:	ff 25 42 9a 20 00    	jmpq   *0x209a42(%rip)        # 60b0a8 <_GLOBAL_OFFSET_TABLE_+0xa8>
  401666:	68 12 00 00 00       	pushq  $0x12
  40166b:	e9 c0 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401670 <strchr@plt>:
  401670:	ff 25 3a 9a 20 00    	jmpq   *0x209a3a(%rip)        # 60b0b0 <_GLOBAL_OFFSET_TABLE_+0xb0>
  401676:	68 13 00 00 00       	pushq  $0x13
  40167b:	e9 b0 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401680 <printf@plt>:
  401680:	ff 25 32 9a 20 00    	jmpq   *0x209a32(%rip)        # 60b0b8 <_GLOBAL_OFFSET_TABLE_+0xb8>
  401686:	68 14 00 00 00       	pushq  $0x14
  40168b:	e9 a0 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401690 <pthread_mutex_destroy@plt>:
  401690:	ff 25 2a 9a 20 00    	jmpq   *0x209a2a(%rip)        # 60b0c0 <_GLOBAL_OFFSET_TABLE_+0xc0>
  401696:	68 15 00 00 00       	pushq  $0x15
  40169b:	e9 90 fe ff ff       	jmpq   401530 <_init+0x20>

00000000004016a0 <fputs@plt>:
  4016a0:	ff 25 22 9a 20 00    	jmpq   *0x209a22(%rip)        # 60b0c8 <_GLOBAL_OFFSET_TABLE_+0xc8>
  4016a6:	68 16 00 00 00       	pushq  $0x16
  4016ab:	e9 80 fe ff ff       	jmpq   401530 <_init+0x20>

00000000004016b0 <memset@plt>:
  4016b0:	ff 25 1a 9a 20 00    	jmpq   *0x209a1a(%rip)        # 60b0d0 <_GLOBAL_OFFSET_TABLE_+0xd0>
  4016b6:	68 17 00 00 00       	pushq  $0x17
  4016bb:	e9 70 fe ff ff       	jmpq   401530 <_init+0x20>

00000000004016c0 <close@plt>:
  4016c0:	ff 25 12 9a 20 00    	jmpq   *0x209a12(%rip)        # 60b0d8 <_GLOBAL_OFFSET_TABLE_+0xd8>
  4016c6:	68 18 00 00 00       	pushq  $0x18
  4016cb:	e9 60 fe ff ff       	jmpq   401530 <_init+0x20>

00000000004016d0 <read@plt>:
  4016d0:	ff 25 0a 9a 20 00    	jmpq   *0x209a0a(%rip)        # 60b0e0 <_GLOBAL_OFFSET_TABLE_+0xe0>
  4016d6:	68 19 00 00 00       	pushq  $0x19
  4016db:	e9 50 fe ff ff       	jmpq   401530 <_init+0x20>

00000000004016e0 <__libc_start_main@plt>:
  4016e0:	ff 25 02 9a 20 00    	jmpq   *0x209a02(%rip)        # 60b0e8 <_GLOBAL_OFFSET_TABLE_+0xe8>
  4016e6:	68 1a 00 00 00       	pushq  $0x1a
  4016eb:	e9 40 fe ff ff       	jmpq   401530 <_init+0x20>

00000000004016f0 <json_object_to_json_string_ext@plt>:
  4016f0:	ff 25 fa 99 20 00    	jmpq   *0x2099fa(%rip)        # 60b0f0 <_GLOBAL_OFFSET_TABLE_+0xf0>
  4016f6:	68 1b 00 00 00       	pushq  $0x1b
  4016fb:	e9 30 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401700 <fgets@plt>:
  401700:	ff 25 f2 99 20 00    	jmpq   *0x2099f2(%rip)        # 60b0f8 <_GLOBAL_OFFSET_TABLE_+0xf8>
  401706:	68 1c 00 00 00       	pushq  $0x1c
  40170b:	e9 20 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401710 <json_object_get_int@plt>:
  401710:	ff 25 ea 99 20 00    	jmpq   *0x2099ea(%rip)        # 60b100 <_GLOBAL_OFFSET_TABLE_+0x100>
  401716:	68 1d 00 00 00       	pushq  $0x1d
  40171b:	e9 10 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401720 <calloc@plt>:
  401720:	ff 25 e2 99 20 00    	jmpq   *0x2099e2(%rip)        # 60b108 <_GLOBAL_OFFSET_TABLE_+0x108>
  401726:	68 1e 00 00 00       	pushq  $0x1e
  40172b:	e9 00 fe ff ff       	jmpq   401530 <_init+0x20>

0000000000401730 <strcmp@plt>:
  401730:	ff 25 da 99 20 00    	jmpq   *0x2099da(%rip)        # 60b110 <_GLOBAL_OFFSET_TABLE_+0x110>
  401736:	68 1f 00 00 00       	pushq  $0x1f
  40173b:	e9 f0 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401740 <json_object_new_int@plt>:
  401740:	ff 25 d2 99 20 00    	jmpq   *0x2099d2(%rip)        # 60b118 <_GLOBAL_OFFSET_TABLE_+0x118>
  401746:	68 20 00 00 00       	pushq  $0x20
  40174b:	e9 e0 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401750 <fprintf@plt>:
  401750:	ff 25 ca 99 20 00    	jmpq   *0x2099ca(%rip)        # 60b120 <_GLOBAL_OFFSET_TABLE_+0x120>
  401756:	68 21 00 00 00       	pushq  $0x21
  40175b:	e9 d0 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401760 <feof@plt>:
  401760:	ff 25 c2 99 20 00    	jmpq   *0x2099c2(%rip)        # 60b128 <_GLOBAL_OFFSET_TABLE_+0x128>
  401766:	68 22 00 00 00       	pushq  $0x22
  40176b:	e9 c0 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401770 <strtol@plt>:
  401770:	ff 25 ba 99 20 00    	jmpq   *0x2099ba(%rip)        # 60b130 <_GLOBAL_OFFSET_TABLE_+0x130>
  401776:	68 23 00 00 00       	pushq  $0x23
  40177b:	e9 b0 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401780 <memcpy@plt>:
  401780:	ff 25 b2 99 20 00    	jmpq   *0x2099b2(%rip)        # 60b138 <_GLOBAL_OFFSET_TABLE_+0x138>
  401786:	68 24 00 00 00       	pushq  $0x24
  40178b:	e9 a0 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401790 <inet_pton@plt>:
  401790:	ff 25 aa 99 20 00    	jmpq   *0x2099aa(%rip)        # 60b140 <_GLOBAL_OFFSET_TABLE_+0x140>
  401796:	68 25 00 00 00       	pushq  $0x25
  40179b:	e9 90 fd ff ff       	jmpq   401530 <_init+0x20>

00000000004017a0 <time@plt>:
  4017a0:	ff 25 a2 99 20 00    	jmpq   *0x2099a2(%rip)        # 60b148 <_GLOBAL_OFFSET_TABLE_+0x148>
  4017a6:	68 26 00 00 00       	pushq  $0x26
  4017ab:	e9 80 fd ff ff       	jmpq   401530 <_init+0x20>

00000000004017b0 <json_object_object_add@plt>:
  4017b0:	ff 25 9a 99 20 00    	jmpq   *0x20999a(%rip)        # 60b150 <_GLOBAL_OFFSET_TABLE_+0x150>
  4017b6:	68 27 00 00 00       	pushq  $0x27
  4017bb:	e9 70 fd ff ff       	jmpq   401530 <_init+0x20>

00000000004017c0 <pthread_cond_init@plt>:
  4017c0:	ff 25 92 99 20 00    	jmpq   *0x209992(%rip)        # 60b158 <_GLOBAL_OFFSET_TABLE_+0x158>
  4017c6:	68 28 00 00 00       	pushq  $0x28
  4017cb:	e9 60 fd ff ff       	jmpq   401530 <_init+0x20>

00000000004017d0 <pthread_mutex_unlock@plt>:
  4017d0:	ff 25 8a 99 20 00    	jmpq   *0x20998a(%rip)        # 60b160 <_GLOBAL_OFFSET_TABLE_+0x160>
  4017d6:	68 29 00 00 00       	pushq  $0x29
  4017db:	e9 50 fd ff ff       	jmpq   401530 <_init+0x20>

00000000004017e0 <malloc@plt>:
  4017e0:	ff 25 82 99 20 00    	jmpq   *0x209982(%rip)        # 60b168 <_GLOBAL_OFFSET_TABLE_+0x168>
  4017e6:	68 2a 00 00 00       	pushq  $0x2a
  4017eb:	e9 40 fd ff ff       	jmpq   401530 <_init+0x20>

00000000004017f0 <fflush@plt>:
  4017f0:	ff 25 7a 99 20 00    	jmpq   *0x20997a(%rip)        # 60b170 <_GLOBAL_OFFSET_TABLE_+0x170>
  4017f6:	68 2b 00 00 00       	pushq  $0x2b
  4017fb:	e9 30 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401800 <listen@plt>:
  401800:	ff 25 72 99 20 00    	jmpq   *0x209972(%rip)        # 60b178 <_GLOBAL_OFFSET_TABLE_+0x178>
  401806:	68 2c 00 00 00       	pushq  $0x2c
  40180b:	e9 20 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401810 <realloc@plt>:
  401810:	ff 25 6a 99 20 00    	jmpq   *0x20996a(%rip)        # 60b180 <_GLOBAL_OFFSET_TABLE_+0x180>
  401816:	68 2d 00 00 00       	pushq  $0x2d
  40181b:	e9 10 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401820 <poll@plt>:
  401820:	ff 25 62 99 20 00    	jmpq   *0x209962(%rip)        # 60b188 <_GLOBAL_OFFSET_TABLE_+0x188>
  401826:	68 2e 00 00 00       	pushq  $0x2e
  40182b:	e9 00 fd ff ff       	jmpq   401530 <_init+0x20>

0000000000401830 <bind@plt>:
  401830:	ff 25 5a 99 20 00    	jmpq   *0x20995a(%rip)        # 60b190 <_GLOBAL_OFFSET_TABLE_+0x190>
  401836:	68 2f 00 00 00       	pushq  $0x2f
  40183b:	e9 f0 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401840 <vsprintf@plt>:
  401840:	ff 25 52 99 20 00    	jmpq   *0x209952(%rip)        # 60b198 <_GLOBAL_OFFSET_TABLE_+0x198>
  401846:	68 30 00 00 00       	pushq  $0x30
  40184b:	e9 e0 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401850 <pthread_self@plt>:
  401850:	ff 25 4a 99 20 00    	jmpq   *0x20994a(%rip)        # 60b1a0 <_GLOBAL_OFFSET_TABLE_+0x1a0>
  401856:	68 31 00 00 00       	pushq  $0x31
  40185b:	e9 d0 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401860 <pthread_cond_destroy@plt>:
  401860:	ff 25 42 99 20 00    	jmpq   *0x209942(%rip)        # 60b1a8 <_GLOBAL_OFFSET_TABLE_+0x1a8>
  401866:	68 32 00 00 00       	pushq  $0x32
  40186b:	e9 c0 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401870 <fopen@plt>:
  401870:	ff 25 3a 99 20 00    	jmpq   *0x20993a(%rip)        # 60b1b0 <_GLOBAL_OFFSET_TABLE_+0x1b0>
  401876:	68 33 00 00 00       	pushq  $0x33
  40187b:	e9 b0 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401880 <perror@plt>:
  401880:	ff 25 32 99 20 00    	jmpq   *0x209932(%rip)        # 60b1b8 <_GLOBAL_OFFSET_TABLE_+0x1b8>
  401886:	68 34 00 00 00       	pushq  $0x34
  40188b:	e9 a0 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401890 <pthread_join@plt>:
  401890:	ff 25 2a 99 20 00    	jmpq   *0x20992a(%rip)        # 60b1c0 <_GLOBAL_OFFSET_TABLE_+0x1c0>
  401896:	68 35 00 00 00       	pushq  $0x35
  40189b:	e9 90 fc ff ff       	jmpq   401530 <_init+0x20>

00000000004018a0 <accept@plt>:
  4018a0:	ff 25 22 99 20 00    	jmpq   *0x209922(%rip)        # 60b1c8 <_GLOBAL_OFFSET_TABLE_+0x1c8>
  4018a6:	68 36 00 00 00       	pushq  $0x36
  4018ab:	e9 80 fc ff ff       	jmpq   401530 <_init+0x20>

00000000004018b0 <atoi@plt>:
  4018b0:	ff 25 1a 99 20 00    	jmpq   *0x20991a(%rip)        # 60b1d0 <_GLOBAL_OFFSET_TABLE_+0x1d0>
  4018b6:	68 37 00 00 00       	pushq  $0x37
  4018bb:	e9 70 fc ff ff       	jmpq   401530 <_init+0x20>

00000000004018c0 <json_object_object_get@plt>:
  4018c0:	ff 25 12 99 20 00    	jmpq   *0x209912(%rip)        # 60b1d8 <_GLOBAL_OFFSET_TABLE_+0x1d8>
  4018c6:	68 38 00 00 00       	pushq  $0x38
  4018cb:	e9 60 fc ff ff       	jmpq   401530 <_init+0x20>

00000000004018d0 <sprintf@plt>:
  4018d0:	ff 25 0a 99 20 00    	jmpq   *0x20990a(%rip)        # 60b1e0 <_GLOBAL_OFFSET_TABLE_+0x1e0>
  4018d6:	68 39 00 00 00       	pushq  $0x39
  4018db:	e9 50 fc ff ff       	jmpq   401530 <_init+0x20>

00000000004018e0 <connect@plt>:
  4018e0:	ff 25 02 99 20 00    	jmpq   *0x209902(%rip)        # 60b1e8 <_GLOBAL_OFFSET_TABLE_+0x1e8>
  4018e6:	68 3a 00 00 00       	pushq  $0x3a
  4018eb:	e9 40 fc ff ff       	jmpq   401530 <_init+0x20>

00000000004018f0 <sleep@plt>:
  4018f0:	ff 25 fa 98 20 00    	jmpq   *0x2098fa(%rip)        # 60b1f0 <_GLOBAL_OFFSET_TABLE_+0x1f0>
  4018f6:	68 3b 00 00 00       	pushq  $0x3b
  4018fb:	e9 30 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401900 <pthread_mutex_init@plt>:
  401900:	ff 25 f2 98 20 00    	jmpq   *0x2098f2(%rip)        # 60b1f8 <_GLOBAL_OFFSET_TABLE_+0x1f8>
  401906:	68 3c 00 00 00       	pushq  $0x3c
  40190b:	e9 20 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401910 <json_object_put@plt>:
  401910:	ff 25 ea 98 20 00    	jmpq   *0x2098ea(%rip)        # 60b200 <_GLOBAL_OFFSET_TABLE_+0x200>
  401916:	68 3d 00 00 00       	pushq  $0x3d
  40191b:	e9 10 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401920 <pthread_mutex_lock@plt>:
  401920:	ff 25 e2 98 20 00    	jmpq   *0x2098e2(%rip)        # 60b208 <_GLOBAL_OFFSET_TABLE_+0x208>
  401926:	68 3e 00 00 00       	pushq  $0x3e
  40192b:	e9 00 fc ff ff       	jmpq   401530 <_init+0x20>

0000000000401930 <__ctype_b_loc@plt>:
  401930:	ff 25 da 98 20 00    	jmpq   *0x2098da(%rip)        # 60b210 <_GLOBAL_OFFSET_TABLE_+0x210>
  401936:	68 3f 00 00 00       	pushq  $0x3f
  40193b:	e9 f0 fb ff ff       	jmpq   401530 <_init+0x20>

0000000000401940 <socket@plt>:
  401940:	ff 25 d2 98 20 00    	jmpq   *0x2098d2(%rip)        # 60b218 <_GLOBAL_OFFSET_TABLE_+0x218>
  401946:	68 40 00 00 00       	pushq  $0x40
  40194b:	e9 e0 fb ff ff       	jmpq   401530 <_init+0x20>

Disassembly of section .plt.got:

0000000000401950 <.plt.got>:
  401950:	ff 25 a2 96 20 00    	jmpq   *0x2096a2(%rip)        # 60aff8 <_DYNAMIC+0x1f0>
  401956:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

0000000000401960 <_start>:
  401960:	31 ed                	xor    %ebp,%ebp
  401962:	49 89 d1             	mov    %rdx,%r9
  401965:	5e                   	pop    %rsi
  401966:	48 89 e2             	mov    %rsp,%rdx
  401969:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  40196d:	50                   	push   %rax
  40196e:	54                   	push   %rsp
  40196f:	49 c7 c0 a0 7d 40 00 	mov    $0x407da0,%r8
  401976:	48 c7 c1 30 7d 40 00 	mov    $0x407d30,%rcx
  40197d:	48 c7 c7 56 1a 40 00 	mov    $0x401a56,%rdi
  401984:	e8 57 fd ff ff       	callq  4016e0 <__libc_start_main@plt>
  401989:	f4                   	hlt    
  40198a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000401990 <deregister_tm_clones>:
  401990:	b8 af b2 60 00       	mov    $0x60b2af,%eax
  401995:	55                   	push   %rbp
  401996:	48 2d a8 b2 60 00    	sub    $0x60b2a8,%rax
  40199c:	48 83 f8 0e          	cmp    $0xe,%rax
  4019a0:	48 89 e5             	mov    %rsp,%rbp
  4019a3:	76 1b                	jbe    4019c0 <deregister_tm_clones+0x30>
  4019a5:	b8 00 00 00 00       	mov    $0x0,%eax
  4019aa:	48 85 c0             	test   %rax,%rax
  4019ad:	74 11                	je     4019c0 <deregister_tm_clones+0x30>
  4019af:	5d                   	pop    %rbp
  4019b0:	bf a8 b2 60 00       	mov    $0x60b2a8,%edi
  4019b5:	ff e0                	jmpq   *%rax
  4019b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4019be:	00 00 
  4019c0:	5d                   	pop    %rbp
  4019c1:	c3                   	retq   
  4019c2:	0f 1f 40 00          	nopl   0x0(%rax)
  4019c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4019cd:	00 00 00 

00000000004019d0 <register_tm_clones>:
  4019d0:	be a8 b2 60 00       	mov    $0x60b2a8,%esi
  4019d5:	55                   	push   %rbp
  4019d6:	48 81 ee a8 b2 60 00 	sub    $0x60b2a8,%rsi
  4019dd:	48 c1 fe 03          	sar    $0x3,%rsi
  4019e1:	48 89 e5             	mov    %rsp,%rbp
  4019e4:	48 89 f0             	mov    %rsi,%rax
  4019e7:	48 c1 e8 3f          	shr    $0x3f,%rax
  4019eb:	48 01 c6             	add    %rax,%rsi
  4019ee:	48 d1 fe             	sar    %rsi
  4019f1:	74 15                	je     401a08 <register_tm_clones+0x38>
  4019f3:	b8 00 00 00 00       	mov    $0x0,%eax
  4019f8:	48 85 c0             	test   %rax,%rax
  4019fb:	74 0b                	je     401a08 <register_tm_clones+0x38>
  4019fd:	5d                   	pop    %rbp
  4019fe:	bf a8 b2 60 00       	mov    $0x60b2a8,%edi
  401a03:	ff e0                	jmpq   *%rax
  401a05:	0f 1f 00             	nopl   (%rax)
  401a08:	5d                   	pop    %rbp
  401a09:	c3                   	retq   
  401a0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000401a10 <__do_global_dtors_aux>:
  401a10:	80 3d b1 98 20 00 00 	cmpb   $0x0,0x2098b1(%rip)        # 60b2c8 <completed.7594>
  401a17:	75 11                	jne    401a2a <__do_global_dtors_aux+0x1a>
  401a19:	55                   	push   %rbp
  401a1a:	48 89 e5             	mov    %rsp,%rbp
  401a1d:	e8 6e ff ff ff       	callq  401990 <deregister_tm_clones>
  401a22:	5d                   	pop    %rbp
  401a23:	c6 05 9e 98 20 00 01 	movb   $0x1,0x20989e(%rip)        # 60b2c8 <completed.7594>
  401a2a:	f3 c3                	repz retq 
  401a2c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401a30 <frame_dummy>:
  401a30:	bf 00 ae 60 00       	mov    $0x60ae00,%edi
  401a35:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  401a39:	75 05                	jne    401a40 <frame_dummy+0x10>
  401a3b:	eb 93                	jmp    4019d0 <register_tm_clones>
  401a3d:	0f 1f 00             	nopl   (%rax)
  401a40:	b8 00 00 00 00       	mov    $0x0,%eax
  401a45:	48 85 c0             	test   %rax,%rax
  401a48:	74 f1                	je     401a3b <frame_dummy+0xb>
  401a4a:	55                   	push   %rbp
  401a4b:	48 89 e5             	mov    %rsp,%rbp
  401a4e:	ff d0                	callq  *%rax
  401a50:	5d                   	pop    %rbp
  401a51:	e9 7a ff ff ff       	jmpq   4019d0 <register_tm_clones>

0000000000401a56 <main>:
 	 * Parameter:   char** argv - [1] - config file
 	 * Return: 	    Success - 0
 	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
int main(int argc, char** argv)
{
  401a56:	55                   	push   %rbp
  401a57:	48 89 e5             	mov    %rsp,%rbp
  401a5a:	53                   	push   %rbx
  401a5b:	48 83 ec 28          	sub    $0x28,%rsp
  401a5f:	89 7d dc             	mov    %edi,-0x24(%rbp)
  401a62:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Create log file from config file
	FILE* f_log = gsi_is_create_log_file("gsi-log-server", NULL);
  401a66:	be 00 00 00 00       	mov    $0x0,%esi
  401a6b:	bf b8 7d 40 00       	mov    $0x407db8,%edi
  401a70:	e8 2e 4a 00 00       	callq  4064a3 <gsi_is_create_log_file>
  401a75:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == f_log)
  401a79:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  401a7e:	75 0a                	jne    401a8a <main+0x34>
	{
		return GSI_IS_FAIL;
  401a80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401a85:	e9 f4 00 00 00       	jmpq   401b7e <main+0x128>
	}

	// Read configuration from file or default according to command line arguments
	if (GSI_PARSE_JSON_CONFIG_SUCCESS != gsi_parse_json_config_get_config(argc, argv))
  401a8a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401a8e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  401a91:	48 89 d6             	mov    %rdx,%rsi
  401a94:	89 c7                	mov    %eax,%edi
  401a96:	e8 50 54 00 00       	callq  406eeb <gsi_parse_json_config_get_config>
  401a9b:	85 c0                	test   %eax,%eax
  401a9d:	74 14                	je     401ab3 <main+0x5d>
	{
		printf("cannot load configuration parameters\n");
  401a9f:	bf c8 7d 40 00       	mov    $0x407dc8,%edi
  401aa4:	e8 07 fb ff ff       	callq  4015b0 <puts@plt>
		return GSI_IS_FAIL;
  401aa9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401aae:	e9 cb 00 00 00       	jmpq   401b7e <main+0x128>
	}

	gsi_is_title_to_log(f_log, "server test is up");
  401ab3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ab7:	be ed 7d 40 00       	mov    $0x407ded,%esi
  401abc:	48 89 c7             	mov    %rax,%rdi
  401abf:	e8 a0 4b 00 00       	callq  406664 <gsi_is_title_to_log>

	do
	{
		// Allocate array of strings for server read them from file in config file
		if (0 != gsi_server_init_strings(g_config_server_params.s_server_data_file))
  401ac4:	bf 40 b3 60 00       	mov    $0x60b340,%edi
  401ac9:	e8 b7 00 00 00       	callq  401b85 <gsi_server_init_strings>
  401ace:	85 c0                	test   %eax,%eax
  401ad0:	74 39                	je     401b0b <main+0xb5>
		{
			LOG_ERROR("couldn't init array of strings");
  401ad2:	b8 00 00 00 00       	mov    $0x0,%eax
  401ad7:	e8 00 4e 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401adc:	48 89 c3             	mov    %rax,%rbx
  401adf:	b8 00 00 00 00       	mov    $0x0,%eax
  401ae4:	e8 6e 4b 00 00       	callq  406657 <gsi_get_saved_file>
  401ae9:	41 b8 59 00 00 00    	mov    $0x59,%r8d
  401aef:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401af4:	48 89 da             	mov    %rbx,%rdx
  401af7:	be 20 7e 40 00       	mov    $0x407e20,%esi
  401afc:	48 89 c7             	mov    %rax,%rdi
  401aff:	b8 00 00 00 00       	mov    $0x0,%eax
  401b04:	e8 b7 4b 00 00       	callq  4066c0 <gsi_is_write_to_log>
			break;
  401b09:	eb 45                	jmp    401b50 <main+0xfa>
		}

		// Set up 3 listening threads
		if (0 != gsi_server_init_clients())
  401b0b:	b8 00 00 00 00       	mov    $0x0,%eax
  401b10:	e8 06 05 00 00       	callq  40201b <gsi_server_init_clients>
  401b15:	85 c0                	test   %eax,%eax
  401b17:	74 37                	je     401b50 <main+0xfa>
		{
			LOG_ERROR("couldn't init clients");
  401b19:	b8 00 00 00 00       	mov    $0x0,%eax
  401b1e:	e8 b9 4d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401b23:	48 89 c3             	mov    %rax,%rbx
  401b26:	b8 00 00 00 00       	mov    $0x0,%eax
  401b2b:	e8 27 4b 00 00       	callq  406657 <gsi_get_saved_file>
  401b30:	41 b8 60 00 00 00    	mov    $0x60,%r8d
  401b36:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401b3b:	48 89 da             	mov    %rbx,%rdx
  401b3e:	be 60 7e 40 00       	mov    $0x407e60,%esi
  401b43:	48 89 c7             	mov    %rax,%rdi
  401b46:	b8 00 00 00 00       	mov    $0x0,%eax
  401b4b:	e8 70 4b 00 00       	callq  4066c0 <gsi_is_write_to_log>
		}
	}
	while (0);

	// Free resources
	gsi_server_clean_strings(GSI_IS_MAX_STRINGS);
  401b50:	bf c8 00 00 00       	mov    $0xc8,%edi
  401b55:	e8 bd 03 00 00       	callq  401f17 <gsi_server_clean_strings>

	// Close log file to free resources
	if (GSI_LOG_RC_SUCCESS != gsi_is_close_log(f_log))
  401b5a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401b5e:	48 89 c7             	mov    %rax,%rdi
  401b61:	e8 17 4d 00 00       	callq  40687d <gsi_is_close_log>
  401b66:	85 c0                	test   %eax,%eax
  401b68:	74 0f                	je     401b79 <main+0x123>
	{
		printf("couldn't close log file");
  401b6a:	bf 97 7e 40 00       	mov    $0x407e97,%edi
  401b6f:	b8 00 00 00 00       	mov    $0x0,%eax
  401b74:	e8 07 fb ff ff       	callq  401680 <printf@plt>
	}

	return 0;
  401b79:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401b7e:	48 83 c4 28          	add    $0x28,%rsp
  401b82:	5b                   	pop    %rbx
  401b83:	5d                   	pop    %rbp
  401b84:	c3                   	retq   

0000000000401b85 <gsi_server_init_strings>:
	 * Parameter:   [in] char* s_file_name - file to read from
	 * Return:		Success - 0
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_init_strings(char* s_file_name)
{
  401b85:	55                   	push   %rbp
  401b86:	48 89 e5             	mov    %rsp,%rbp
  401b89:	53                   	push   %rbx
  401b8a:	48 81 ec 38 04 00 00 	sub    $0x438,%rsp
  401b91:	48 89 bd c8 fb ff ff 	mov    %rdi,-0x438(%rbp)
  401b98:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401b9f:	00 00 
  401ba1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  401ba5:	31 c0                	xor    %eax,%eax
	int i_len = 0;
  401ba7:	c7 85 d4 fb ff ff 00 	movl   $0x0,-0x42c(%rbp)
  401bae:	00 00 00 
	int i_index = 0;
  401bb1:	c7 85 d0 fb ff ff 00 	movl   $0x0,-0x430(%rbp)
  401bb8:	00 00 00 
	char s_buffer[GSI_IS_MAX_STR_LEN];
	FILE* f_str_file = NULL;
  401bbb:	48 c7 85 d8 fb ff ff 	movq   $0x0,-0x428(%rbp)
  401bc2:	00 00 00 00 

	// Check input validation
	if (NULL == s_file_name)
  401bc6:	48 83 bd c8 fb ff ff 	cmpq   $0x0,-0x438(%rbp)
  401bcd:	00 
  401bce:	75 41                	jne    401c11 <gsi_server_init_strings+0x8c>
	{
		LOG_ERROR("invalid argument!");
  401bd0:	b8 00 00 00 00       	mov    $0x0,%eax
  401bd5:	e8 02 4d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401bda:	48 89 c3             	mov    %rax,%rbx
  401bdd:	b8 00 00 00 00       	mov    $0x0,%eax
  401be2:	e8 70 4a 00 00       	callq  406657 <gsi_get_saved_file>
  401be7:	41 b8 86 00 00 00    	mov    $0x86,%r8d
  401bed:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401bf2:	48 89 da             	mov    %rbx,%rdx
  401bf5:	be b0 7e 40 00       	mov    $0x407eb0,%esi
  401bfa:	48 89 c7             	mov    %rax,%rdi
  401bfd:	b8 00 00 00 00       	mov    $0x0,%eax
  401c02:	e8 b9 4a 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  401c07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401c0c:	e9 e8 02 00 00       	jmpq   401ef9 <gsi_server_init_strings+0x374>
	}

	// Memory allocation for array of strings
	g_arr_strings = (char **)calloc(GSI_IS_MAX_STRINGS, sizeof(char *));
  401c11:	be 08 00 00 00       	mov    $0x8,%esi
  401c16:	bf c8 00 00 00       	mov    $0xc8,%edi
  401c1b:	e8 00 fb ff ff       	callq  401720 <calloc@plt>
  401c20:	48 89 05 a9 96 20 00 	mov    %rax,0x2096a9(%rip)        # 60b2d0 <g_arr_strings>
	if (NULL == g_arr_strings)
  401c27:	48 8b 05 a2 96 20 00 	mov    0x2096a2(%rip),%rax        # 60b2d0 <g_arr_strings>
  401c2e:	48 85 c0             	test   %rax,%rax
  401c31:	75 41                	jne    401c74 <gsi_server_init_strings+0xef>
	{
		LOG_ERROR("memory allocation for global array failed");
  401c33:	b8 00 00 00 00       	mov    $0x0,%eax
  401c38:	e8 9f 4c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401c3d:	48 89 c3             	mov    %rax,%rbx
  401c40:	b8 00 00 00 00       	mov    $0x0,%eax
  401c45:	e8 0d 4a 00 00       	callq  406657 <gsi_get_saved_file>
  401c4a:	41 b8 8e 00 00 00    	mov    $0x8e,%r8d
  401c50:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401c55:	48 89 da             	mov    %rbx,%rdx
  401c58:	be e8 7e 40 00       	mov    $0x407ee8,%esi
  401c5d:	48 89 c7             	mov    %rax,%rdi
  401c60:	b8 00 00 00 00       	mov    $0x0,%eax
  401c65:	e8 56 4a 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  401c6a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401c6f:	e9 85 02 00 00       	jmpq   401ef9 <gsi_server_init_strings+0x374>
	}

	// Open file to read from it
	f_str_file = fopen(s_file_name, "r");
  401c74:	48 8b 85 c8 fb ff ff 	mov    -0x438(%rbp),%rax
  401c7b:	be 33 7f 40 00       	mov    $0x407f33,%esi
  401c80:	48 89 c7             	mov    %rax,%rdi
  401c83:	e8 e8 fb ff ff       	callq  401870 <fopen@plt>
  401c88:	48 89 85 d8 fb ff ff 	mov    %rax,-0x428(%rbp)
	if (NULL == f_str_file)
  401c8f:	48 83 bd d8 fb ff ff 	cmpq   $0x0,-0x428(%rbp)
  401c96:	00 
  401c97:	75 65                	jne    401cfe <gsi_server_init_strings+0x179>
	{
		LOG_ERROR("couldn't open %s", s_file_name);
  401c99:	b8 00 00 00 00       	mov    $0x0,%eax
  401c9e:	e8 39 4c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401ca3:	48 89 c3             	mov    %rax,%rbx
  401ca6:	b8 00 00 00 00       	mov    $0x0,%eax
  401cab:	e8 a7 49 00 00       	callq  406657 <gsi_get_saved_file>
  401cb0:	48 89 c7             	mov    %rax,%rdi
  401cb3:	48 8b 85 c8 fb ff ff 	mov    -0x438(%rbp),%rax
  401cba:	49 89 c1             	mov    %rax,%r9
  401cbd:	41 b8 96 00 00 00    	mov    $0x96,%r8d
  401cc3:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401cc8:	48 89 da             	mov    %rbx,%rdx
  401ccb:	be 38 7f 40 00       	mov    $0x407f38,%esi
  401cd0:	b8 00 00 00 00       	mov    $0x0,%eax
  401cd5:	e8 e6 49 00 00       	callq  4066c0 <gsi_is_write_to_log>

		free(g_arr_strings);
  401cda:	48 8b 05 ef 95 20 00 	mov    0x2095ef(%rip),%rax        # 60b2d0 <g_arr_strings>
  401ce1:	48 89 c7             	mov    %rax,%rdi
  401ce4:	e8 67 f8 ff ff       	callq  401550 <free@plt>
		g_arr_strings = NULL;
  401ce9:	48 c7 05 dc 95 20 00 	movq   $0x0,0x2095dc(%rip)        # 60b2d0 <g_arr_strings>
  401cf0:	00 00 00 00 

		return GSI_IS_FAIL;
  401cf4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401cf9:	e9 fb 01 00 00       	jmpq   401ef9 <gsi_server_init_strings+0x374>
	}

	// Read strings from file up to GSI_IS_MAX_STRINGS
	for (i_index = 0; i_index < GSI_IS_MAX_STRINGS; ++i_index)
  401cfe:	c7 85 d0 fb ff ff 00 	movl   $0x0,-0x430(%rbp)
  401d05:	00 00 00 
  401d08:	e9 28 01 00 00       	jmpq   401e35 <gsi_server_init_strings+0x2b0>
	{
		// Reset buffer
		memset(s_buffer, 0, sizeof(s_buffer));
  401d0d:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  401d14:	ba 00 04 00 00       	mov    $0x400,%edx
  401d19:	be 00 00 00 00       	mov    $0x0,%esi
  401d1e:	48 89 c7             	mov    %rax,%rdi
  401d21:	e8 8a f9 ff ff       	callq  4016b0 <memset@plt>

		// Read from file into buffer
		if (NULL == fgets(s_buffer, GSI_IS_MAX_STR_LEN, f_str_file))
  401d26:	48 8b 95 d8 fb ff ff 	mov    -0x428(%rbp),%rdx
  401d2d:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  401d34:	be 00 04 00 00       	mov    $0x400,%esi
  401d39:	48 89 c7             	mov    %rax,%rdi
  401d3c:	e8 bf f9 ff ff       	callq  401700 <fgets@plt>
  401d41:	48 85 c0             	test   %rax,%rax
  401d44:	0f 84 fd 00 00 00    	je     401e47 <gsi_server_init_strings+0x2c2>
		{
			break;
		}

		i_len = strlen(s_buffer);
  401d4a:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  401d51:	48 89 c7             	mov    %rax,%rdi
  401d54:	e8 c7 f8 ff ff       	callq  401620 <strlen@plt>
  401d59:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%rbp)

		// Replace the '\n' at the end of the string by '\0'
		s_buffer[i_len - 1] = '\0';
  401d5f:	8b 85 d4 fb ff ff    	mov    -0x42c(%rbp),%eax
  401d65:	83 e8 01             	sub    $0x1,%eax
  401d68:	48 98                	cltq   
  401d6a:	c6 84 05 e0 fb ff ff 	movb   $0x0,-0x420(%rbp,%rax,1)
  401d71:	00 

		// Allocate memory for each new string
		g_arr_strings[i_index] = malloc(i_len);
  401d72:	48 8b 05 57 95 20 00 	mov    0x209557(%rip),%rax        # 60b2d0 <g_arr_strings>
  401d79:	8b 95 d0 fb ff ff    	mov    -0x430(%rbp),%edx
  401d7f:	48 63 d2             	movslq %edx,%rdx
  401d82:	48 c1 e2 03          	shl    $0x3,%rdx
  401d86:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx
  401d8a:	8b 85 d4 fb ff ff    	mov    -0x42c(%rbp),%eax
  401d90:	48 98                	cltq   
  401d92:	48 89 c7             	mov    %rax,%rdi
  401d95:	e8 46 fa ff ff       	callq  4017e0 <malloc@plt>
  401d9a:	48 89 03             	mov    %rax,(%rbx)
		if (NULL == g_arr_strings[i_index])
  401d9d:	48 8b 05 2c 95 20 00 	mov    0x20952c(%rip),%rax        # 60b2d0 <g_arr_strings>
  401da4:	8b 95 d0 fb ff ff    	mov    -0x430(%rbp),%edx
  401daa:	48 63 d2             	movslq %edx,%rdx
  401dad:	48 c1 e2 03          	shl    $0x3,%rdx
  401db1:	48 01 d0             	add    %rdx,%rax
  401db4:	48 8b 00             	mov    (%rax),%rax
  401db7:	48 85 c0             	test   %rax,%rax
  401dba:	75 46                	jne    401e02 <gsi_server_init_strings+0x27d>
		{
			LOG_ERROR("memory allocation for string in global array failed");
  401dbc:	b8 00 00 00 00       	mov    $0x0,%eax
  401dc1:	e8 16 4b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401dc6:	48 89 c3             	mov    %rax,%rbx
  401dc9:	b8 00 00 00 00       	mov    $0x0,%eax
  401dce:	e8 84 48 00 00       	callq  406657 <gsi_get_saved_file>
  401dd3:	41 b8 b3 00 00 00    	mov    $0xb3,%r8d
  401dd9:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401dde:	48 89 da             	mov    %rbx,%rdx
  401de1:	be 70 7f 40 00       	mov    $0x407f70,%esi
  401de6:	48 89 c7             	mov    %rax,%rdi
  401de9:	b8 00 00 00 00       	mov    $0x0,%eax
  401dee:	e8 cd 48 00 00       	callq  4066c0 <gsi_is_write_to_log>

			// Rollback free
			gsi_server_clean_strings(i_index);
  401df3:	8b 85 d0 fb ff ff    	mov    -0x430(%rbp),%eax
  401df9:	89 c7                	mov    %eax,%edi
  401dfb:	e8 17 01 00 00       	callq  401f17 <gsi_server_clean_strings>
			break;
  401e00:	eb 46                	jmp    401e48 <gsi_server_init_strings+0x2c3>
		}

		// Copy Content
		strcpy(g_arr_strings[i_index], s_buffer);
  401e02:	48 8b 05 c7 94 20 00 	mov    0x2094c7(%rip),%rax        # 60b2d0 <g_arr_strings>
  401e09:	8b 95 d0 fb ff ff    	mov    -0x430(%rbp),%edx
  401e0f:	48 63 d2             	movslq %edx,%rdx
  401e12:	48 c1 e2 03          	shl    $0x3,%rdx
  401e16:	48 01 d0             	add    %rdx,%rax
  401e19:	48 8b 00             	mov    (%rax),%rax
  401e1c:	48 8d 95 e0 fb ff ff 	lea    -0x420(%rbp),%rdx
  401e23:	48 89 d6             	mov    %rdx,%rsi
  401e26:	48 89 c7             	mov    %rax,%rdi
  401e29:	e8 62 f7 ff ff       	callq  401590 <strcpy@plt>

		return GSI_IS_FAIL;
	}

	// Read strings from file up to GSI_IS_MAX_STRINGS
	for (i_index = 0; i_index < GSI_IS_MAX_STRINGS; ++i_index)
  401e2e:	83 85 d0 fb ff ff 01 	addl   $0x1,-0x430(%rbp)
  401e35:	81 bd d0 fb ff ff c7 	cmpl   $0xc7,-0x430(%rbp)
  401e3c:	00 00 00 
  401e3f:	0f 8e c8 fe ff ff    	jle    401d0d <gsi_server_init_strings+0x188>
  401e45:	eb 01                	jmp    401e48 <gsi_server_init_strings+0x2c3>
		memset(s_buffer, 0, sizeof(s_buffer));

		// Read from file into buffer
		if (NULL == fgets(s_buffer, GSI_IS_MAX_STR_LEN, f_str_file))
		{
			break;
  401e47:	90                   	nop
		// Copy Content
		strcpy(g_arr_strings[i_index], s_buffer);
	}

	// Check if error occurred
	if (i_index != GSI_IS_MAX_STRINGS)
  401e48:	81 bd d0 fb ff ff c8 	cmpl   $0xc8,-0x430(%rbp)
  401e4f:	00 00 00 
  401e52:	74 5a                	je     401eae <gsi_server_init_strings+0x329>
	{
		LOG_ERROR("couldn't initialize the global array");
  401e54:	b8 00 00 00 00       	mov    $0x0,%eax
  401e59:	e8 7e 4a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401e5e:	48 89 c3             	mov    %rax,%rbx
  401e61:	b8 00 00 00 00       	mov    $0x0,%eax
  401e66:	e8 ec 47 00 00       	callq  406657 <gsi_get_saved_file>
  401e6b:	41 b8 c1 00 00 00    	mov    $0xc1,%r8d
  401e71:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401e76:	48 89 da             	mov    %rbx,%rdx
  401e79:	be c8 7f 40 00       	mov    $0x407fc8,%esi
  401e7e:	48 89 c7             	mov    %rax,%rdi
  401e81:	b8 00 00 00 00       	mov    $0x0,%eax
  401e86:	e8 35 48 00 00       	callq  4066c0 <gsi_is_write_to_log>

		gsi_server_clean_strings(i_index);
  401e8b:	8b 85 d0 fb ff ff    	mov    -0x430(%rbp),%eax
  401e91:	89 c7                	mov    %eax,%edi
  401e93:	e8 7f 00 00 00       	callq  401f17 <gsi_server_clean_strings>
		fclose(f_str_file);
  401e98:	48 8b 85 d8 fb ff ff 	mov    -0x428(%rbp),%rax
  401e9f:	48 89 c7             	mov    %rax,%rdi
  401ea2:	e8 59 f7 ff ff       	callq  401600 <fclose@plt>

		return GSI_IS_FAIL;
  401ea7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401eac:	eb 4b                	jmp    401ef9 <gsi_server_init_strings+0x374>
	}

	// Close file
	fclose(f_str_file);
  401eae:	48 8b 85 d8 fb ff ff 	mov    -0x428(%rbp),%rax
  401eb5:	48 89 c7             	mov    %rax,%rdi
  401eb8:	e8 43 f7 ff ff       	callq  401600 <fclose@plt>

	LOG_INFO("Successfully init global array of string");
  401ebd:	b8 00 00 00 00       	mov    $0x0,%eax
  401ec2:	e8 15 4a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401ec7:	48 89 c3             	mov    %rax,%rbx
  401eca:	b8 00 00 00 00       	mov    $0x0,%eax
  401ecf:	e8 83 47 00 00       	callq  406657 <gsi_get_saved_file>
  401ed4:	41 b8 cc 00 00 00    	mov    $0xcc,%r8d
  401eda:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401edf:	48 89 da             	mov    %rbx,%rdx
  401ee2:	be 10 80 40 00       	mov    $0x408010,%esi
  401ee7:	48 89 c7             	mov    %rax,%rdi
  401eea:	b8 00 00 00 00       	mov    $0x0,%eax
  401eef:	e8 cc 47 00 00       	callq  4066c0 <gsi_is_write_to_log>

	return 0;
  401ef4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401ef9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  401efd:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  401f04:	00 00 
  401f06:	74 05                	je     401f0d <gsi_server_init_strings+0x388>
  401f08:	e8 23 f7 ff ff       	callq  401630 <__stack_chk_fail@plt>
  401f0d:	48 81 c4 38 04 00 00 	add    $0x438,%rsp
  401f14:	5b                   	pop    %rbx
  401f15:	5d                   	pop    %rbp
  401f16:	c3                   	retq   

0000000000401f17 <gsi_server_clean_strings>:
	 * Description: Roll back clean function to free all memory allocations of global array
	 * Parameter:   [in] int i_index - index of the position to start clean
	 * Return:		None
#############################################################################*/
static void gsi_server_clean_strings(int i_index)
{
  401f17:	55                   	push   %rbp
  401f18:	48 89 e5             	mov    %rsp,%rbp
  401f1b:	53                   	push   %rbx
  401f1c:	48 83 ec 28          	sub    $0x28,%rsp
  401f20:	89 7d dc             	mov    %edi,-0x24(%rbp)
	// Check input validation
	if ((0 > i_index) || (GSI_IS_MAX_STRINGS < i_index))
  401f23:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  401f27:	78 09                	js     401f32 <gsi_server_clean_strings+0x1b>
  401f29:	81 7d dc c8 00 00 00 	cmpl   $0xc8,-0x24(%rbp)
  401f30:	7e 42                	jle    401f74 <gsi_server_clean_strings+0x5d>
	{
		LOG_ERROR("index %d is out of range", i_index);
  401f32:	b8 00 00 00 00       	mov    $0x0,%eax
  401f37:	e8 a0 49 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401f3c:	48 89 c3             	mov    %rax,%rbx
  401f3f:	b8 00 00 00 00       	mov    $0x0,%eax
  401f44:	e8 0e 47 00 00       	callq  406657 <gsi_get_saved_file>
  401f49:	48 89 c7             	mov    %rax,%rdi
  401f4c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  401f4f:	41 89 c1             	mov    %eax,%r9d
  401f52:	41 b8 dc 00 00 00    	mov    $0xdc,%r8d
  401f58:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401f5d:	48 89 da             	mov    %rbx,%rdx
  401f60:	be 60 80 40 00       	mov    $0x408060,%esi
  401f65:	b8 00 00 00 00       	mov    $0x0,%eax
  401f6a:	e8 51 47 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return;
  401f6f:	e9 a0 00 00 00       	jmpq   402014 <gsi_server_clean_strings+0xfd>
	}

	// Loop to free all allocated entries
	for (int i = (i_index - 1); i >= 0; --i)
  401f74:	8b 45 dc             	mov    -0x24(%rbp),%eax
  401f77:	83 e8 01             	sub    $0x1,%eax
  401f7a:	89 45 ec             	mov    %eax,-0x14(%rbp)
  401f7d:	eb 3e                	jmp    401fbd <gsi_server_clean_strings+0xa6>
	{
		free(g_arr_strings[i]);
  401f7f:	48 8b 05 4a 93 20 00 	mov    0x20934a(%rip),%rax        # 60b2d0 <g_arr_strings>
  401f86:	8b 55 ec             	mov    -0x14(%rbp),%edx
  401f89:	48 63 d2             	movslq %edx,%rdx
  401f8c:	48 c1 e2 03          	shl    $0x3,%rdx
  401f90:	48 01 d0             	add    %rdx,%rax
  401f93:	48 8b 00             	mov    (%rax),%rax
  401f96:	48 89 c7             	mov    %rax,%rdi
  401f99:	e8 b2 f5 ff ff       	callq  401550 <free@plt>
		g_arr_strings[i] = NULL;
  401f9e:	48 8b 05 2b 93 20 00 	mov    0x20932b(%rip),%rax        # 60b2d0 <g_arr_strings>
  401fa5:	8b 55 ec             	mov    -0x14(%rbp),%edx
  401fa8:	48 63 d2             	movslq %edx,%rdx
  401fab:	48 c1 e2 03          	shl    $0x3,%rdx
  401faf:	48 01 d0             	add    %rdx,%rax
  401fb2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		LOG_ERROR("index %d is out of range", i_index);
		return;
	}

	// Loop to free all allocated entries
	for (int i = (i_index - 1); i >= 0; --i)
  401fb9:	83 6d ec 01          	subl   $0x1,-0x14(%rbp)
  401fbd:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  401fc1:	79 bc                	jns    401f7f <gsi_server_clean_strings+0x68>
		free(g_arr_strings[i]);
		g_arr_strings[i] = NULL;
	}

	// Free the global array
	free(g_arr_strings);
  401fc3:	48 8b 05 06 93 20 00 	mov    0x209306(%rip),%rax        # 60b2d0 <g_arr_strings>
  401fca:	48 89 c7             	mov    %rax,%rdi
  401fcd:	e8 7e f5 ff ff       	callq  401550 <free@plt>
	g_arr_strings = NULL;
  401fd2:	48 c7 05 f3 92 20 00 	movq   $0x0,0x2092f3(%rip)        # 60b2d0 <g_arr_strings>
  401fd9:	00 00 00 00 

	LOG_INFO("Successfully clean all the resources in global array");
  401fdd:	b8 00 00 00 00       	mov    $0x0,%eax
  401fe2:	e8 f5 48 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  401fe7:	48 89 c3             	mov    %rax,%rbx
  401fea:	b8 00 00 00 00       	mov    $0x0,%eax
  401fef:	e8 63 46 00 00       	callq  406657 <gsi_get_saved_file>
  401ff4:	41 b8 eb 00 00 00    	mov    $0xeb,%r8d
  401ffa:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  401fff:	48 89 da             	mov    %rbx,%rdx
  402002:	be a0 80 40 00       	mov    $0x4080a0,%esi
  402007:	48 89 c7             	mov    %rax,%rdi
  40200a:	b8 00 00 00 00       	mov    $0x0,%eax
  40200f:	e8 ac 46 00 00       	callq  4066c0 <gsi_is_write_to_log>
}
  402014:	48 83 c4 28          	add    $0x28,%rsp
  402018:	5b                   	pop    %rbx
  402019:	5d                   	pop    %rbp
  40201a:	c3                   	retq   

000000000040201b <gsi_server_init_clients>:
	 * Description: Init 3 threads to listen on 3 different ports
	 * Return: 		Success - 0
	 * 				Failure - -1
#############################################################################*/
static int gsi_server_init_clients()
{
  40201b:	55                   	push   %rbp
  40201c:	48 89 e5             	mov    %rsp,%rbp
  40201f:	53                   	push   %rbx
  402020:	48 83 ec 28          	sub    $0x28,%rsp
  402024:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40202b:	00 00 
  40202d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402031:	31 c0                	xor    %eax,%eax
	unsigned int ui_port_1 = g_config_server_params.ui_port1;
  402033:	8b 05 e7 92 20 00    	mov    0x2092e7(%rip),%eax        # 60b320 <g_config_server_params>
  402039:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	unsigned int ui_port_2 = g_config_server_params.ui_port2;
  40203c:	8b 05 e2 92 20 00    	mov    0x2092e2(%rip),%eax        # 60b324 <g_config_server_params+0x4>
  402042:	89 45 d8             	mov    %eax,-0x28(%rbp)
	unsigned int ui_port_3 = g_config_server_params.ui_port3;
  402045:	8b 05 dd 92 20 00    	mov    0x2092dd(%rip),%eax        # 60b328 <g_config_server_params+0x8>
  40204b:	89 45 dc             	mov    %eax,-0x24(%rbp)

	// Create ThreadPool from parameters in config file
	gsi_thread_pool_t* pool = gsi_is_thread_pool_create(GSI_IS_SERVER_THREADS, GSI_IS_SERVER_QUEUE_SIZE);
  40204e:	be 03 00 00 00       	mov    $0x3,%esi
  402053:	bf 03 00 00 00       	mov    $0x3,%edi
  402058:	e8 52 56 00 00       	callq  4076af <gsi_is_thread_pool_create>
  40205d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (NULL == pool)
  402061:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  402066:	75 41                	jne    4020a9 <gsi_server_init_clients+0x8e>
	{
		LOG_ERROR("couldn't create the ThreadPool");
  402068:	b8 00 00 00 00       	mov    $0x0,%eax
  40206d:	e8 6a 48 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402072:	48 89 c3             	mov    %rax,%rbx
  402075:	b8 00 00 00 00       	mov    $0x0,%eax
  40207a:	e8 d8 45 00 00       	callq  406657 <gsi_get_saved_file>
  40207f:	41 b8 fe 00 00 00    	mov    $0xfe,%r8d
  402085:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  40208a:	48 89 da             	mov    %rbx,%rdx
  40208d:	be f8 80 40 00       	mov    $0x4080f8,%esi
  402092:	48 89 c7             	mov    %rax,%rdi
  402095:	b8 00 00 00 00       	mov    $0x0,%eax
  40209a:	e8 21 46 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  40209f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4020a4:	e9 50 01 00 00       	jmpq   4021f9 <gsi_server_init_clients+0x1de>
	}

	do
	{
		// Active 3 threads to listen 3 different ports.
		if (GSI_TP_RC_SUCCESS != gsi_is_thread_pool_add(pool, gsi_server_thread_parse_client, (void *)(&ui_port_1)))
  4020a9:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  4020ad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4020b1:	be 14 22 40 00       	mov    $0x402214,%esi
  4020b6:	48 89 c7             	mov    %rax,%rdi
  4020b9:	e8 6d 58 00 00       	callq  40792b <gsi_is_thread_pool_add>
  4020be:	85 c0                	test   %eax,%eax
  4020c0:	74 3c                	je     4020fe <gsi_server_init_clients+0xe3>
		{
			LOG_ERROR("couldn't add job to the ThreadPool");
  4020c2:	b8 00 00 00 00       	mov    $0x0,%eax
  4020c7:	e8 10 48 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4020cc:	48 89 c3             	mov    %rax,%rbx
  4020cf:	b8 00 00 00 00       	mov    $0x0,%eax
  4020d4:	e8 7e 45 00 00       	callq  406657 <gsi_get_saved_file>
  4020d9:	41 b8 07 01 00 00    	mov    $0x107,%r8d
  4020df:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  4020e4:	48 89 da             	mov    %rbx,%rdx
  4020e7:	be 38 81 40 00       	mov    $0x408138,%esi
  4020ec:	48 89 c7             	mov    %rax,%rdi
  4020ef:	b8 00 00 00 00       	mov    $0x0,%eax
  4020f4:	e8 c7 45 00 00       	callq  4066c0 <gsi_is_write_to_log>
			break;
  4020f9:	e9 a3 00 00 00       	jmpq   4021a1 <gsi_server_init_clients+0x186>
		}

		if (GSI_TP_RC_SUCCESS != gsi_is_thread_pool_add(pool, gsi_server_thread_parse_client, (void *)(&ui_port_2)))
  4020fe:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  402102:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402106:	be 14 22 40 00       	mov    $0x402214,%esi
  40210b:	48 89 c7             	mov    %rax,%rdi
  40210e:	e8 18 58 00 00       	callq  40792b <gsi_is_thread_pool_add>
  402113:	85 c0                	test   %eax,%eax
  402115:	74 39                	je     402150 <gsi_server_init_clients+0x135>
		{
			LOG_ERROR("couldn't add job to the ThreadPool");
  402117:	b8 00 00 00 00       	mov    $0x0,%eax
  40211c:	e8 bb 47 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402121:	48 89 c3             	mov    %rax,%rbx
  402124:	b8 00 00 00 00       	mov    $0x0,%eax
  402129:	e8 29 45 00 00       	callq  406657 <gsi_get_saved_file>
  40212e:	41 b8 0d 01 00 00    	mov    $0x10d,%r8d
  402134:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402139:	48 89 da             	mov    %rbx,%rdx
  40213c:	be 38 81 40 00       	mov    $0x408138,%esi
  402141:	48 89 c7             	mov    %rax,%rdi
  402144:	b8 00 00 00 00       	mov    $0x0,%eax
  402149:	e8 72 45 00 00       	callq  4066c0 <gsi_is_write_to_log>
			break;
  40214e:	eb 51                	jmp    4021a1 <gsi_server_init_clients+0x186>
		}

		if (GSI_TP_RC_SUCCESS != gsi_is_thread_pool_add(pool, gsi_server_thread_parse_client, (void *)(&ui_port_3)))
  402150:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
  402154:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402158:	be 14 22 40 00       	mov    $0x402214,%esi
  40215d:	48 89 c7             	mov    %rax,%rdi
  402160:	e8 c6 57 00 00       	callq  40792b <gsi_is_thread_pool_add>
  402165:	85 c0                	test   %eax,%eax
  402167:	74 38                	je     4021a1 <gsi_server_init_clients+0x186>
		{
			LOG_ERROR("couldn't add job to the ThreadPool");
  402169:	b8 00 00 00 00       	mov    $0x0,%eax
  40216e:	e8 69 47 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402173:	48 89 c3             	mov    %rax,%rbx
  402176:	b8 00 00 00 00       	mov    $0x0,%eax
  40217b:	e8 d7 44 00 00       	callq  406657 <gsi_get_saved_file>
  402180:	41 b8 13 01 00 00    	mov    $0x113,%r8d
  402186:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  40218b:	48 89 da             	mov    %rbx,%rdx
  40218e:	be 38 81 40 00       	mov    $0x408138,%esi
  402193:	48 89 c7             	mov    %rax,%rdi
  402196:	b8 00 00 00 00       	mov    $0x0,%eax
  40219b:	e8 20 45 00 00       	callq  4066c0 <gsi_is_write_to_log>
			break;
  4021a0:	90                   	nop
		}
	}
	while (0);

	// Destroy ThreadPool
	if (GSI_TP_RC_SUCCESS != gsi_is_thread_pool_destroy(pool, GSI_TP_DESTROY_GRACEFUL))
  4021a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4021a5:	be 01 00 00 00       	mov    $0x1,%esi
  4021aa:	48 89 c7             	mov    %rax,%rdi
  4021ad:	e8 96 58 00 00       	callq  407a48 <gsi_is_thread_pool_destroy>
  4021b2:	85 c0                	test   %eax,%eax
  4021b4:	74 3e                	je     4021f4 <gsi_server_init_clients+0x1d9>
	{
		LOG_ERROR("couldn't destroy the ThreadPool");
  4021b6:	b8 00 00 00 00       	mov    $0x0,%eax
  4021bb:	e8 1c 47 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4021c0:	48 89 c3             	mov    %rax,%rbx
  4021c3:	b8 00 00 00 00       	mov    $0x0,%eax
  4021c8:	e8 8a 44 00 00       	callq  406657 <gsi_get_saved_file>
  4021cd:	41 b8 1c 01 00 00    	mov    $0x11c,%r8d
  4021d3:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  4021d8:	48 89 da             	mov    %rbx,%rdx
  4021db:	be 80 81 40 00       	mov    $0x408180,%esi
  4021e0:	48 89 c7             	mov    %rax,%rdi
  4021e3:	b8 00 00 00 00       	mov    $0x0,%eax
  4021e8:	e8 d3 44 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return 1;
  4021ed:	b8 01 00 00 00       	mov    $0x1,%eax
  4021f2:	eb 05                	jmp    4021f9 <gsi_server_init_clients+0x1de>
	}

	return 0;
  4021f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4021f9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  4021fd:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  402204:	00 00 
  402206:	74 05                	je     40220d <gsi_server_init_clients+0x1f2>
  402208:	e8 23 f4 ff ff       	callq  401630 <__stack_chk_fail@plt>
  40220d:	48 83 c4 28          	add    $0x28,%rsp
  402211:	5b                   	pop    %rbx
  402212:	5d                   	pop    %rbp
  402213:	c3                   	retq   

0000000000402214 <gsi_server_thread_parse_client>:
	 * Description: Main thread function to listen on connection
	 * Parameter:   [in] void* p_args - holds the port number
	 * Return:		Always NULL
#############################################################################*/
static void* gsi_server_thread_parse_client(void* p_args)
{
  402214:	55                   	push   %rbp
  402215:	48 89 e5             	mov    %rsp,%rbp
  402218:	53                   	push   %rbx
  402219:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  402220:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
  402227:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40222e:	00 00 
  402230:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402234:	31 c0                	xor    %eax,%eax
	unsigned int ui_port = *((unsigned int *)p_args);
  402236:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  40223d:	8b 00                	mov    (%rax),%eax
  40223f:	89 45 8c             	mov    %eax,-0x74(%rbp)
	struct gsi_net_tcp server;

	// Check input validation
	if (NULL == p_args)
  402242:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  402249:	00 
  40224a:	75 41                	jne    40228d <gsi_server_thread_parse_client+0x79>
	{
		LOG_ERROR("invalid argument!");
  40224c:	b8 00 00 00 00       	mov    $0x0,%eax
  402251:	e8 86 46 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402256:	48 89 c3             	mov    %rax,%rbx
  402259:	b8 00 00 00 00       	mov    $0x0,%eax
  40225e:	e8 f4 43 00 00       	callq  406657 <gsi_get_saved_file>
  402263:	41 b8 31 01 00 00    	mov    $0x131,%r8d
  402269:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  40226e:	48 89 da             	mov    %rbx,%rdx
  402271:	be b0 7e 40 00       	mov    $0x407eb0,%esi
  402276:	48 89 c7             	mov    %rax,%rdi
  402279:	b8 00 00 00 00       	mov    $0x0,%eax
  40227e:	e8 3d 44 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  402283:	b8 00 00 00 00       	mov    $0x0,%eax
  402288:	e9 db 00 00 00       	jmpq   402368 <gsi_server_thread_parse_client+0x154>
	}

	// Init Server object
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_server_init(&server, ui_port))
  40228d:	8b 55 8c             	mov    -0x74(%rbp),%edx
  402290:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  402294:	89 d6                	mov    %edx,%esi
  402296:	48 89 c7             	mov    %rax,%rdi
  402299:	e8 1b 32 00 00       	callq  4054b9 <gsi_is_network_tcp_server_init>
  40229e:	85 c0                	test   %eax,%eax
  4022a0:	74 41                	je     4022e3 <gsi_server_thread_parse_client+0xcf>
	{
		LOG_ERROR("server init failed");
  4022a2:	b8 00 00 00 00       	mov    $0x0,%eax
  4022a7:	e8 30 46 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4022ac:	48 89 c3             	mov    %rax,%rbx
  4022af:	b8 00 00 00 00       	mov    $0x0,%eax
  4022b4:	e8 9e 43 00 00       	callq  406657 <gsi_get_saved_file>
  4022b9:	41 b8 38 01 00 00    	mov    $0x138,%r8d
  4022bf:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  4022c4:	48 89 da             	mov    %rbx,%rdx
  4022c7:	be c8 81 40 00       	mov    $0x4081c8,%esi
  4022cc:	48 89 c7             	mov    %rax,%rdi
  4022cf:	b8 00 00 00 00       	mov    $0x0,%eax
  4022d4:	e8 e7 43 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  4022d9:	b8 00 00 00 00       	mov    $0x0,%eax
  4022de:	e9 85 00 00 00       	jmpq   402368 <gsi_server_thread_parse_client+0x154>
	}

	// Check if server needs timer
	if ((-1 == g_config_server_params.i_server_timer) ||
  4022e3:	8b 05 43 90 20 00    	mov    0x209043(%rip),%eax        # 60b32c <g_config_server_params+0xc>
  4022e9:	83 f8 ff             	cmp    $0xffffffff,%eax
  4022ec:	74 0a                	je     4022f8 <gsi_server_thread_parse_client+0xe4>
		 (0 == g_config_server_params.i_server_timer))
  4022ee:	8b 05 38 90 20 00    	mov    0x209038(%rip),%eax        # 60b32c <g_config_server_params+0xc>
		LOG_ERROR("server init failed");
		return NULL;
	}

	// Check if server needs timer
	if ((-1 == g_config_server_params.i_server_timer) ||
  4022f4:	85 c0                	test   %eax,%eax
  4022f6:	75 13                	jne    40230b <gsi_server_thread_parse_client+0xf7>
		 (0 == g_config_server_params.i_server_timer))
	{
		gsi_server_infinite_service(&server);
  4022f8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  4022fc:	48 89 c7             	mov    %rax,%rdi
  4022ff:	b8 00 00 00 00       	mov    $0x0,%eax
  402304:	e8 94 03 00 00       	callq  40269d <gsi_server_infinite_service>
  402309:	eb 11                	jmp    40231c <gsi_server_thread_parse_client+0x108>
	}
	else
	{
		gsi_server_timed_service(&server);
  40230b:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  40230f:	48 89 c7             	mov    %rax,%rdi
  402312:	b8 00 00 00 00       	mov    $0x0,%eax
  402317:	e8 6a 00 00 00       	callq  402386 <gsi_server_timed_service>
	}

	// Cleanup - close open file descriptors.
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_server_cleanup(&server))
  40231c:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  402320:	48 89 c7             	mov    %rax,%rdi
  402323:	e8 42 39 00 00       	callq  405c6a <gsi_is_network_tcp_server_cleanup>
  402328:	85 c0                	test   %eax,%eax
  40232a:	74 37                	je     402363 <gsi_server_thread_parse_client+0x14f>
	{
		LOG_ERROR("cleanup failed");
  40232c:	b8 00 00 00 00       	mov    $0x0,%eax
  402331:	e8 a6 45 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402336:	48 89 c3             	mov    %rax,%rbx
  402339:	b8 00 00 00 00       	mov    $0x0,%eax
  40233e:	e8 14 43 00 00       	callq  406657 <gsi_get_saved_file>
  402343:	41 b8 4a 01 00 00    	mov    $0x14a,%r8d
  402349:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  40234e:	48 89 da             	mov    %rbx,%rdx
  402351:	be 00 82 40 00       	mov    $0x408200,%esi
  402356:	48 89 c7             	mov    %rax,%rdi
  402359:	b8 00 00 00 00       	mov    $0x0,%eax
  40235e:	e8 5d 43 00 00       	callq  4066c0 <gsi_is_write_to_log>
	}

	return NULL;
  402363:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402368:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  40236c:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  402373:	00 00 
  402375:	74 05                	je     40237c <gsi_server_thread_parse_client+0x168>
  402377:	e8 b4 f2 ff ff       	callq  401630 <__stack_chk_fail@plt>
  40237c:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  402383:	5b                   	pop    %rbx
  402384:	5d                   	pop    %rbp
  402385:	c3                   	retq   

0000000000402386 <gsi_server_timed_service>:
	 * Description: run server on timer
	 * Parameter:   [in] struct gsi_net_tcp* p_server - pointer to server
	 * Return:		None
#############################################################################*/
static void gsi_server_timed_service(struct gsi_net_tcp* p_server)
{
  402386:	55                   	push   %rbp
  402387:	48 89 e5             	mov    %rsp,%rbp
  40238a:	41 54                	push   %r12
  40238c:	53                   	push   %rbx
  40238d:	48 83 ec 60          	sub    $0x60,%rsp
  402391:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  402395:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40239c:	00 00 
  40239e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  4023a2:	31 c0                	xor    %eax,%eax
	int i_rc = 0;
  4023a4:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%rbp)
	int i_run_flag = GSI_IS_TRUE;
  4023ab:	c7 45 a8 01 00 00 00 	movl   $0x1,-0x58(%rbp)
	time_t t_seconds = g_config_server_params.i_server_timer;
  4023b2:	8b 05 74 8f 20 00    	mov    0x208f74(%rip),%eax        # 60b32c <g_config_server_params+0xc>
  4023b8:	48 98                	cltq   
  4023ba:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	time_t t_start_time = time(NULL);
  4023be:	bf 00 00 00 00       	mov    $0x0,%edi
  4023c3:	e8 d8 f3 ff ff       	callq  4017a0 <time@plt>
  4023c8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	struct gsi_json_msg json_msg;

	// Reset json-msg
	memset(&json_msg, 0, sizeof(json_msg));
  4023cc:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4023d0:	ba 28 00 00 00       	mov    $0x28,%edx
  4023d5:	be 00 00 00 00       	mov    $0x0,%esi
  4023da:	48 89 c7             	mov    %rax,%rdi
  4023dd:	e8 ce f2 ff ff       	callq  4016b0 <memset@plt>

	while ((i_run_flag) && (time(NULL) - t_start_time) < t_seconds)
  4023e2:	e9 f0 01 00 00       	jmpq   4025d7 <gsi_server_timed_service+0x251>
	{
		// Check events on fds of server
		i_rc = gsi_is_network_tcp_server_poll(p_server);
  4023e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  4023eb:	48 89 c7             	mov    %rax,%rdi
  4023ee:	e8 00 34 00 00       	callq  4057f3 <gsi_is_network_tcp_server_poll>
  4023f3:	89 45 ac             	mov    %eax,-0x54(%rbp)
		switch (i_rc)
  4023f6:	8b 45 ac             	mov    -0x54(%rbp),%eax
  4023f9:	83 f8 04             	cmp    $0x4,%eax
  4023fc:	0f 84 34 01 00 00    	je     402536 <gsi_server_timed_service+0x1b0>
  402402:	3d 80 00 00 00       	cmp    $0x80,%eax
  402407:	74 44                	je     40244d <gsi_server_timed_service+0xc7>
  402409:	85 c0                	test   %eax,%eax
  40240b:	0f 85 6f 01 00 00    	jne    402580 <gsi_server_timed_service+0x1fa>
		{
		case GSI_NET_RC_SUCCESS:
			LOG_INFO("still listen\n");
  402411:	b8 00 00 00 00       	mov    $0x0,%eax
  402416:	e8 c1 44 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40241b:	48 89 c3             	mov    %rax,%rbx
  40241e:	b8 00 00 00 00       	mov    $0x0,%eax
  402423:	e8 2f 42 00 00       	callq  406657 <gsi_get_saved_file>
  402428:	41 b8 68 01 00 00    	mov    $0x168,%r8d
  40242e:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402433:	48 89 da             	mov    %rbx,%rdx
  402436:	be 30 82 40 00       	mov    $0x408230,%esi
  40243b:	48 89 c7             	mov    %rax,%rdi
  40243e:	b8 00 00 00 00       	mov    $0x0,%eax
  402443:	e8 78 42 00 00       	callq  4066c0 <gsi_is_write_to_log>
			break;
  402448:	e9 74 01 00 00       	jmpq   4025c1 <gsi_server_timed_service+0x23b>

		case GSI_NET_RC_HASDATA:
			LOG_INFO("client %d sent message:", gsi_server_port_to_client(p_server->ui_port));
  40244d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  402451:	8b 40 28             	mov    0x28(%rax),%eax
  402454:	89 c7                	mov    %eax,%edi
  402456:	e8 3e 0d 00 00       	callq  403199 <gsi_server_port_to_client>
  40245b:	41 89 c4             	mov    %eax,%r12d
  40245e:	b8 00 00 00 00       	mov    $0x0,%eax
  402463:	e8 74 44 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402468:	48 89 c3             	mov    %rax,%rbx
  40246b:	b8 00 00 00 00       	mov    $0x0,%eax
  402470:	e8 e2 41 00 00       	callq  406657 <gsi_get_saved_file>
  402475:	45 89 e1             	mov    %r12d,%r9d
  402478:	41 b8 6c 01 00 00    	mov    $0x16c,%r8d
  40247e:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402483:	48 89 da             	mov    %rbx,%rdx
  402486:	be 60 82 40 00       	mov    $0x408260,%esi
  40248b:	48 89 c7             	mov    %rax,%rdi
  40248e:	b8 00 00 00 00       	mov    $0x0,%eax
  402493:	e8 28 42 00 00       	callq  4066c0 <gsi_is_write_to_log>

			if (GSI_JSON_SUCCESS != gsi_is_recv_json_msg(p_server, &json_msg))
  402498:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  40249c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  4024a0:	48 89 d6             	mov    %rdx,%rsi
  4024a3:	48 89 c7             	mov    %rax,%rdi
  4024a6:	e8 55 13 00 00       	callq  403800 <gsi_is_recv_json_msg>
  4024ab:	85 c0                	test   %eax,%eax
  4024ad:	74 37                	je     4024e6 <gsi_server_timed_service+0x160>
			{
				LOG_ERROR("receive message failed");
  4024af:	b8 00 00 00 00       	mov    $0x0,%eax
  4024b4:	e8 23 44 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4024b9:	48 89 c3             	mov    %rax,%rbx
  4024bc:	b8 00 00 00 00       	mov    $0x0,%eax
  4024c1:	e8 91 41 00 00       	callq  406657 <gsi_get_saved_file>
  4024c6:	41 b8 70 01 00 00    	mov    $0x170,%r8d
  4024cc:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  4024d1:	48 89 da             	mov    %rbx,%rdx
  4024d4:	be 98 82 40 00       	mov    $0x408298,%esi
  4024d9:	48 89 c7             	mov    %rax,%rdi
  4024dc:	b8 00 00 00 00       	mov    $0x0,%eax
  4024e1:	e8 da 41 00 00       	callq  4066c0 <gsi_is_write_to_log>
			}

			// Operate according to operation code
			if (0 != gsi_server_handle_op_code(&json_msg))
  4024e6:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4024ea:	48 89 c7             	mov    %rax,%rdi
  4024ed:	e8 4b 04 00 00       	callq  40293d <gsi_server_handle_op_code>
  4024f2:	85 c0                	test   %eax,%eax
  4024f4:	0f 84 c6 00 00 00    	je     4025c0 <gsi_server_timed_service+0x23a>
			{
				LOG_ERROR("server handle op code failed");
  4024fa:	b8 00 00 00 00       	mov    $0x0,%eax
  4024ff:	e8 d8 43 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402504:	48 89 c3             	mov    %rax,%rbx
  402507:	b8 00 00 00 00       	mov    $0x0,%eax
  40250c:	e8 46 41 00 00       	callq  406657 <gsi_get_saved_file>
  402511:	41 b8 76 01 00 00    	mov    $0x176,%r8d
  402517:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  40251c:	48 89 da             	mov    %rbx,%rdx
  40251f:	be d0 82 40 00       	mov    $0x4082d0,%esi
  402524:	48 89 c7             	mov    %rax,%rdi
  402527:	b8 00 00 00 00       	mov    $0x0,%eax
  40252c:	e8 8f 41 00 00       	callq  4066c0 <gsi_is_write_to_log>
			}
			break;
  402531:	e9 8a 00 00 00       	jmpq   4025c0 <gsi_server_timed_service+0x23a>

		case GSI_NET_RC_CONNECTERR:
			i_run_flag = GSI_IS_FALSE;
  402536:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
			LOG_ERROR("client from port %d disconnected\n", p_server->ui_port);
  40253d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  402541:	8b 58 28             	mov    0x28(%rax),%ebx
  402544:	b8 00 00 00 00       	mov    $0x0,%eax
  402549:	e8 8e 43 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40254e:	49 89 c4             	mov    %rax,%r12
  402551:	b8 00 00 00 00       	mov    $0x0,%eax
  402556:	e8 fc 40 00 00       	callq  406657 <gsi_get_saved_file>
  40255b:	41 89 d9             	mov    %ebx,%r9d
  40255e:	41 b8 7c 01 00 00    	mov    $0x17c,%r8d
  402564:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402569:	4c 89 e2             	mov    %r12,%rdx
  40256c:	be 10 83 40 00       	mov    $0x408310,%esi
  402571:	48 89 c7             	mov    %rax,%rdi
  402574:	b8 00 00 00 00       	mov    $0x0,%eax
  402579:	e8 42 41 00 00       	callq  4066c0 <gsi_is_write_to_log>
			break;
  40257e:	eb 41                	jmp    4025c1 <gsi_server_timed_service+0x23b>

		default:
			i_run_flag = GSI_IS_FALSE;
  402580:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
			LOG_ERROR("error has been occurred");
  402587:	b8 00 00 00 00       	mov    $0x0,%eax
  40258c:	e8 4b 43 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402591:	48 89 c3             	mov    %rax,%rbx
  402594:	b8 00 00 00 00       	mov    $0x0,%eax
  402599:	e8 b9 40 00 00       	callq  406657 <gsi_get_saved_file>
  40259e:	41 b8 81 01 00 00    	mov    $0x181,%r8d
  4025a4:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  4025a9:	48 89 da             	mov    %rbx,%rdx
  4025ac:	be 58 83 40 00       	mov    $0x408358,%esi
  4025b1:	48 89 c7             	mov    %rax,%rdi
  4025b4:	b8 00 00 00 00       	mov    $0x0,%eax
  4025b9:	e8 02 41 00 00       	callq  4066c0 <gsi_is_write_to_log>
  4025be:	eb 01                	jmp    4025c1 <gsi_server_timed_service+0x23b>
			// Operate according to operation code
			if (0 != gsi_server_handle_op_code(&json_msg))
			{
				LOG_ERROR("server handle op code failed");
			}
			break;
  4025c0:	90                   	nop
			i_run_flag = GSI_IS_FALSE;
			LOG_ERROR("error has been occurred");
		}

		// Reset and free resources of json-msg object
		gsi_build_parse_reset_object(&json_msg);
  4025c1:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4025c5:	48 89 c7             	mov    %rax,%rdi
  4025c8:	e8 7b 0d 00 00       	callq  403348 <gsi_build_parse_reset_object>

		sleep(1);
  4025cd:	bf 01 00 00 00       	mov    $0x1,%edi
  4025d2:	e8 19 f3 ff ff       	callq  4018f0 <sleep@plt>
	struct gsi_json_msg json_msg;

	// Reset json-msg
	memset(&json_msg, 0, sizeof(json_msg));

	while ((i_run_flag) && (time(NULL) - t_start_time) < t_seconds)
  4025d7:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  4025db:	74 18                	je     4025f5 <gsi_server_timed_service+0x26f>
  4025dd:	bf 00 00 00 00       	mov    $0x0,%edi
  4025e2:	e8 b9 f1 ff ff       	callq  4017a0 <time@plt>
  4025e7:	48 2b 45 b8          	sub    -0x48(%rbp),%rax
  4025eb:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
  4025ef:	0f 8c f2 fd ff ff    	jl     4023e7 <gsi_server_timed_service+0x61>

		sleep(1);
	}

	// Check finish status
	if (i_run_flag)
  4025f5:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  4025f9:	74 43                	je     40263e <gsi_server_timed_service+0x2b8>
	{
		LOG_INFO("thread on port %d timeout\n", p_server->ui_port);
  4025fb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  4025ff:	8b 58 28             	mov    0x28(%rax),%ebx
  402602:	b8 00 00 00 00       	mov    $0x0,%eax
  402607:	e8 d0 42 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40260c:	49 89 c4             	mov    %rax,%r12
  40260f:	b8 00 00 00 00       	mov    $0x0,%eax
  402614:	e8 3e 40 00 00       	callq  406657 <gsi_get_saved_file>
  402619:	41 89 d9             	mov    %ebx,%r9d
  40261c:	41 b8 8d 01 00 00    	mov    $0x18d,%r8d
  402622:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402627:	4c 89 e2             	mov    %r12,%rdx
  40262a:	be 98 83 40 00       	mov    $0x408398,%esi
  40262f:	48 89 c7             	mov    %rax,%rdi
  402632:	b8 00 00 00 00       	mov    $0x0,%eax
  402637:	e8 84 40 00 00       	callq  4066c0 <gsi_is_write_to_log>
	}
	else
	{
		LOG_ERROR("thread on port %d stopped\n", p_server->ui_port);
	}
}
  40263c:	eb 41                	jmp    40267f <gsi_server_timed_service+0x2f9>
	{
		LOG_INFO("thread on port %d timeout\n", p_server->ui_port);
	}
	else
	{
		LOG_ERROR("thread on port %d stopped\n", p_server->ui_port);
  40263e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  402642:	8b 58 28             	mov    0x28(%rax),%ebx
  402645:	b8 00 00 00 00       	mov    $0x0,%eax
  40264a:	e8 8d 42 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40264f:	49 89 c4             	mov    %rax,%r12
  402652:	b8 00 00 00 00       	mov    $0x0,%eax
  402657:	e8 fb 3f 00 00       	callq  406657 <gsi_get_saved_file>
  40265c:	41 89 d9             	mov    %ebx,%r9d
  40265f:	41 b8 91 01 00 00    	mov    $0x191,%r8d
  402665:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  40266a:	4c 89 e2             	mov    %r12,%rdx
  40266d:	be d8 83 40 00       	mov    $0x4083d8,%esi
  402672:	48 89 c7             	mov    %rax,%rdi
  402675:	b8 00 00 00 00       	mov    $0x0,%eax
  40267a:	e8 41 40 00 00       	callq  4066c0 <gsi_is_write_to_log>
	}
}
  40267f:	90                   	nop
  402680:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402684:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40268b:	00 00 
  40268d:	74 05                	je     402694 <gsi_server_timed_service+0x30e>
  40268f:	e8 9c ef ff ff       	callq  401630 <__stack_chk_fail@plt>
  402694:	48 83 c4 60          	add    $0x60,%rsp
  402698:	5b                   	pop    %rbx
  402699:	41 5c                	pop    %r12
  40269b:	5d                   	pop    %rbp
  40269c:	c3                   	retq   

000000000040269d <gsi_server_infinite_service>:
	 * Description: run server on infinite loop (until error will occur)
	 * Parameter:   [in] struct gsi_net_tcp* p_server - pointer to server
	 * Return:		None
#############################################################################*/
static void gsi_server_infinite_service(struct gsi_net_tcp* p_server)
{
  40269d:	55                   	push   %rbp
  40269e:	48 89 e5             	mov    %rsp,%rbp
  4026a1:	41 54                	push   %r12
  4026a3:	53                   	push   %rbx
  4026a4:	48 83 ec 50          	sub    $0x50,%rsp
  4026a8:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  4026ac:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4026b3:	00 00 
  4026b5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  4026b9:	31 c0                	xor    %eax,%eax
	int i_rc = 0;
  4026bb:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
	int i_run_flag = GSI_IS_TRUE;
  4026c2:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
	struct gsi_json_msg json_msg;

	// Reset json-msg
	memset(&json_msg, 0, sizeof(json_msg));
  4026c9:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4026cd:	ba 28 00 00 00       	mov    $0x28,%edx
  4026d2:	be 00 00 00 00       	mov    $0x0,%esi
  4026d7:	48 89 c7             	mov    %rax,%rdi
  4026da:	e8 d1 ef ff ff       	callq  4016b0 <memset@plt>

	while (i_run_flag)
  4026df:	e9 f0 01 00 00       	jmpq   4028d4 <gsi_server_infinite_service+0x237>
	{
		// Check events on fds of server
		i_rc = gsi_is_network_tcp_server_poll(p_server);
  4026e4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4026e8:	48 89 c7             	mov    %rax,%rdi
  4026eb:	e8 03 31 00 00       	callq  4057f3 <gsi_is_network_tcp_server_poll>
  4026f0:	89 45 bc             	mov    %eax,-0x44(%rbp)
		switch (i_rc)
  4026f3:	8b 45 bc             	mov    -0x44(%rbp),%eax
  4026f6:	83 f8 04             	cmp    $0x4,%eax
  4026f9:	0f 84 34 01 00 00    	je     402833 <gsi_server_infinite_service+0x196>
  4026ff:	3d 80 00 00 00       	cmp    $0x80,%eax
  402704:	74 44                	je     40274a <gsi_server_infinite_service+0xad>
  402706:	85 c0                	test   %eax,%eax
  402708:	0f 85 6f 01 00 00    	jne    40287d <gsi_server_infinite_service+0x1e0>
		{
		case GSI_NET_RC_SUCCESS:
			LOG_INFO("still listen\n");
  40270e:	b8 00 00 00 00       	mov    $0x0,%eax
  402713:	e8 c4 41 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402718:	48 89 c3             	mov    %rax,%rbx
  40271b:	b8 00 00 00 00       	mov    $0x0,%eax
  402720:	e8 32 3f 00 00       	callq  406657 <gsi_get_saved_file>
  402725:	41 b8 ab 01 00 00    	mov    $0x1ab,%r8d
  40272b:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402730:	48 89 da             	mov    %rbx,%rdx
  402733:	be 30 82 40 00       	mov    $0x408230,%esi
  402738:	48 89 c7             	mov    %rax,%rdi
  40273b:	b8 00 00 00 00       	mov    $0x0,%eax
  402740:	e8 7b 3f 00 00       	callq  4066c0 <gsi_is_write_to_log>
			break;
  402745:	e9 74 01 00 00       	jmpq   4028be <gsi_server_infinite_service+0x221>

		case GSI_NET_RC_HASDATA:
			LOG_INFO("client %d sent message:", gsi_server_port_to_client(p_server->ui_port));
  40274a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  40274e:	8b 40 28             	mov    0x28(%rax),%eax
  402751:	89 c7                	mov    %eax,%edi
  402753:	e8 41 0a 00 00       	callq  403199 <gsi_server_port_to_client>
  402758:	41 89 c4             	mov    %eax,%r12d
  40275b:	b8 00 00 00 00       	mov    $0x0,%eax
  402760:	e8 77 41 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402765:	48 89 c3             	mov    %rax,%rbx
  402768:	b8 00 00 00 00       	mov    $0x0,%eax
  40276d:	e8 e5 3e 00 00       	callq  406657 <gsi_get_saved_file>
  402772:	45 89 e1             	mov    %r12d,%r9d
  402775:	41 b8 af 01 00 00    	mov    $0x1af,%r8d
  40277b:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402780:	48 89 da             	mov    %rbx,%rdx
  402783:	be 60 82 40 00       	mov    $0x408260,%esi
  402788:	48 89 c7             	mov    %rax,%rdi
  40278b:	b8 00 00 00 00       	mov    $0x0,%eax
  402790:	e8 2b 3f 00 00       	callq  4066c0 <gsi_is_write_to_log>

			if (GSI_JSON_SUCCESS != gsi_is_recv_json_msg(p_server, &json_msg))
  402795:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  402799:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  40279d:	48 89 d6             	mov    %rdx,%rsi
  4027a0:	48 89 c7             	mov    %rax,%rdi
  4027a3:	e8 58 10 00 00       	callq  403800 <gsi_is_recv_json_msg>
  4027a8:	85 c0                	test   %eax,%eax
  4027aa:	74 37                	je     4027e3 <gsi_server_infinite_service+0x146>
			{
				LOG_ERROR("receive message failed");
  4027ac:	b8 00 00 00 00       	mov    $0x0,%eax
  4027b1:	e8 26 41 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4027b6:	48 89 c3             	mov    %rax,%rbx
  4027b9:	b8 00 00 00 00       	mov    $0x0,%eax
  4027be:	e8 94 3e 00 00       	callq  406657 <gsi_get_saved_file>
  4027c3:	41 b8 b3 01 00 00    	mov    $0x1b3,%r8d
  4027c9:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  4027ce:	48 89 da             	mov    %rbx,%rdx
  4027d1:	be 98 82 40 00       	mov    $0x408298,%esi
  4027d6:	48 89 c7             	mov    %rax,%rdi
  4027d9:	b8 00 00 00 00       	mov    $0x0,%eax
  4027de:	e8 dd 3e 00 00       	callq  4066c0 <gsi_is_write_to_log>
			}

			// Operate according to operation code
			if (0 != gsi_server_handle_op_code(&json_msg))
  4027e3:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4027e7:	48 89 c7             	mov    %rax,%rdi
  4027ea:	e8 4e 01 00 00       	callq  40293d <gsi_server_handle_op_code>
  4027ef:	85 c0                	test   %eax,%eax
  4027f1:	0f 84 c6 00 00 00    	je     4028bd <gsi_server_infinite_service+0x220>
			{
				LOG_ERROR("server handle op code failed");
  4027f7:	b8 00 00 00 00       	mov    $0x0,%eax
  4027fc:	e8 db 40 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402801:	48 89 c3             	mov    %rax,%rbx
  402804:	b8 00 00 00 00       	mov    $0x0,%eax
  402809:	e8 49 3e 00 00       	callq  406657 <gsi_get_saved_file>
  40280e:	41 b8 b9 01 00 00    	mov    $0x1b9,%r8d
  402814:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402819:	48 89 da             	mov    %rbx,%rdx
  40281c:	be d0 82 40 00       	mov    $0x4082d0,%esi
  402821:	48 89 c7             	mov    %rax,%rdi
  402824:	b8 00 00 00 00       	mov    $0x0,%eax
  402829:	e8 92 3e 00 00       	callq  4066c0 <gsi_is_write_to_log>
			}
			break;
  40282e:	e9 8a 00 00 00       	jmpq   4028bd <gsi_server_infinite_service+0x220>

		case GSI_NET_RC_CONNECTERR:
			i_run_flag = GSI_IS_FALSE;
  402833:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
			LOG_ERROR("client from port %d disconnected\n", p_server->ui_port);
  40283a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  40283e:	8b 58 28             	mov    0x28(%rax),%ebx
  402841:	b8 00 00 00 00       	mov    $0x0,%eax
  402846:	e8 91 40 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40284b:	49 89 c4             	mov    %rax,%r12
  40284e:	b8 00 00 00 00       	mov    $0x0,%eax
  402853:	e8 ff 3d 00 00       	callq  406657 <gsi_get_saved_file>
  402858:	41 89 d9             	mov    %ebx,%r9d
  40285b:	41 b8 bf 01 00 00    	mov    $0x1bf,%r8d
  402861:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402866:	4c 89 e2             	mov    %r12,%rdx
  402869:	be 10 83 40 00       	mov    $0x408310,%esi
  40286e:	48 89 c7             	mov    %rax,%rdi
  402871:	b8 00 00 00 00       	mov    $0x0,%eax
  402876:	e8 45 3e 00 00       	callq  4066c0 <gsi_is_write_to_log>
			break;
  40287b:	eb 41                	jmp    4028be <gsi_server_infinite_service+0x221>

		default:
			i_run_flag = GSI_IS_FALSE;
  40287d:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
			LOG_ERROR("error has been occurred");
  402884:	b8 00 00 00 00       	mov    $0x0,%eax
  402889:	e8 4e 40 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40288e:	48 89 c3             	mov    %rax,%rbx
  402891:	b8 00 00 00 00       	mov    $0x0,%eax
  402896:	e8 bc 3d 00 00       	callq  406657 <gsi_get_saved_file>
  40289b:	41 b8 c4 01 00 00    	mov    $0x1c4,%r8d
  4028a1:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  4028a6:	48 89 da             	mov    %rbx,%rdx
  4028a9:	be 58 83 40 00       	mov    $0x408358,%esi
  4028ae:	48 89 c7             	mov    %rax,%rdi
  4028b1:	b8 00 00 00 00       	mov    $0x0,%eax
  4028b6:	e8 05 3e 00 00       	callq  4066c0 <gsi_is_write_to_log>
  4028bb:	eb 01                	jmp    4028be <gsi_server_infinite_service+0x221>
			// Operate according to operation code
			if (0 != gsi_server_handle_op_code(&json_msg))
			{
				LOG_ERROR("server handle op code failed");
			}
			break;
  4028bd:	90                   	nop
			i_run_flag = GSI_IS_FALSE;
			LOG_ERROR("error has been occurred");
		}

		// Reset and free resources of json-msg object
		gsi_build_parse_reset_object(&json_msg);
  4028be:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4028c2:	48 89 c7             	mov    %rax,%rdi
  4028c5:	e8 7e 0a 00 00       	callq  403348 <gsi_build_parse_reset_object>

		sleep(1);
  4028ca:	bf 01 00 00 00       	mov    $0x1,%edi
  4028cf:	e8 1c f0 ff ff       	callq  4018f0 <sleep@plt>
	struct gsi_json_msg json_msg;

	// Reset json-msg
	memset(&json_msg, 0, sizeof(json_msg));

	while (i_run_flag)
  4028d4:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  4028d8:	0f 85 06 fe ff ff    	jne    4026e4 <gsi_server_infinite_service+0x47>
		gsi_build_parse_reset_object(&json_msg);

		sleep(1);
	}

	LOG_ERROR("thread on port %d stopped\n", p_server->ui_port);
  4028de:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4028e2:	8b 58 28             	mov    0x28(%rax),%ebx
  4028e5:	b8 00 00 00 00       	mov    $0x0,%eax
  4028ea:	e8 ed 3f 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4028ef:	49 89 c4             	mov    %rax,%r12
  4028f2:	b8 00 00 00 00       	mov    $0x0,%eax
  4028f7:	e8 5b 3d 00 00       	callq  406657 <gsi_get_saved_file>
  4028fc:	41 89 d9             	mov    %ebx,%r9d
  4028ff:	41 b8 cd 01 00 00    	mov    $0x1cd,%r8d
  402905:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  40290a:	4c 89 e2             	mov    %r12,%rdx
  40290d:	be d8 83 40 00       	mov    $0x4083d8,%esi
  402912:	48 89 c7             	mov    %rax,%rdi
  402915:	b8 00 00 00 00       	mov    $0x0,%eax
  40291a:	e8 a1 3d 00 00       	callq  4066c0 <gsi_is_write_to_log>
}
  40291f:	90                   	nop
  402920:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402924:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
  40292b:	00 00 
  40292d:	74 05                	je     402934 <gsi_server_infinite_service+0x297>
  40292f:	e8 fc ec ff ff       	callq  401630 <__stack_chk_fail@plt>
  402934:	48 83 c4 50          	add    $0x50,%rsp
  402938:	5b                   	pop    %rbx
  402939:	41 5c                	pop    %r12
  40293b:	5d                   	pop    %rbp
  40293c:	c3                   	retq   

000000000040293d <gsi_server_handle_op_code>:
	 * Parameter:   [in] struct gsi_json_msg* p_json_msg - pointer to json-msg
	 * Return:		Success - 0
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_handle_op_code(struct gsi_json_msg* p_json_msg)
{
  40293d:	55                   	push   %rbp
  40293e:	48 89 e5             	mov    %rsp,%rbp
  402941:	53                   	push   %rbx
  402942:	48 83 ec 18          	sub    $0x18,%rsp
  402946:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == p_json_msg)
  40294a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  40294f:	75 41                	jne    402992 <gsi_server_handle_op_code+0x55>
	{
		LOG_ERROR("invalid argument!");
  402951:	b8 00 00 00 00       	mov    $0x0,%eax
  402956:	e8 81 3f 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40295b:	48 89 c3             	mov    %rax,%rbx
  40295e:	b8 00 00 00 00       	mov    $0x0,%eax
  402963:	e8 ef 3c 00 00       	callq  406657 <gsi_get_saved_file>
  402968:	41 b8 dc 01 00 00    	mov    $0x1dc,%r8d
  40296e:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402973:	48 89 da             	mov    %rbx,%rdx
  402976:	be b0 7e 40 00       	mov    $0x407eb0,%esi
  40297b:	48 89 c7             	mov    %rax,%rdi
  40297e:	b8 00 00 00 00       	mov    $0x0,%eax
  402983:	e8 38 3d 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  402988:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40298d:	e9 c2 00 00 00       	jmpq   402a54 <gsi_server_handle_op_code+0x117>
	}

	// Check op-code
	switch(p_json_msg->i_op_code)
  402992:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402996:	8b 40 04             	mov    0x4(%rax),%eax
  402999:	83 f8 05             	cmp    $0x5,%eax
  40299c:	0f 87 ad 00 00 00    	ja     402a4f <gsi_server_handle_op_code+0x112>
  4029a2:	89 c0                	mov    %eax,%eax
  4029a4:	48 8b 04 c5 18 84 40 	mov    0x408418(,%rax,8),%rax
  4029ab:	00 
  4029ac:	ff e0                	jmpq   *%rax
	{
		case GSI_READ_STR:
			return gsi_server_handle_read_str(p_json_msg->i_index);
  4029ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029b2:	8b 40 0c             	mov    0xc(%rax),%eax
  4029b5:	89 c7                	mov    %eax,%edi
  4029b7:	e8 9f 00 00 00       	callq  402a5b <gsi_server_handle_read_str>
  4029bc:	e9 93 00 00 00       	jmpq   402a54 <gsi_server_handle_op_code+0x117>

		case GSI_WRITE_STR:
			return gsi_server_handle_write_str(p_json_msg->i_index, p_json_msg->s_data, p_json_msg->i_data_len);
  4029c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029c5:	8b 50 10             	mov    0x10(%rax),%edx
  4029c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029cc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  4029d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029d4:	8b 40 0c             	mov    0xc(%rax),%eax
  4029d7:	48 89 ce             	mov    %rcx,%rsi
  4029da:	89 c7                	mov    %eax,%edi
  4029dc:	e8 04 01 00 00       	callq  402ae5 <gsi_server_handle_write_str>
  4029e1:	eb 71                	jmp    402a54 <gsi_server_handle_op_code+0x117>

		case GSI_READ_FILE:
			return gsi_server_handle_read_file(p_json_msg->s_file_name, GSI_IS_NO_PRINT);
  4029e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029e7:	48 8b 40 18          	mov    0x18(%rax),%rax
  4029eb:	be 00 00 00 00       	mov    $0x0,%esi
  4029f0:	48 89 c7             	mov    %rax,%rdi
  4029f3:	e8 50 02 00 00       	callq  402c48 <gsi_server_handle_read_file>
  4029f8:	eb 5a                	jmp    402a54 <gsi_server_handle_op_code+0x117>

		case GSI_WRITE_FILE:
			return gsi_server_handle_write_file(p_json_msg->s_file_name, p_json_msg->s_data);
  4029fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029fe:	48 8b 50 20          	mov    0x20(%rax),%rdx
  402a02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402a06:	48 8b 40 18          	mov    0x18(%rax),%rax
  402a0a:	48 89 d6             	mov    %rdx,%rsi
  402a0d:	48 89 c7             	mov    %rax,%rdi
  402a10:	e8 50 04 00 00       	callq  402e65 <gsi_server_handle_write_file>
  402a15:	eb 3d                	jmp    402a54 <gsi_server_handle_op_code+0x117>

		case GSI_PRINT_LOG:
			return gsi_server_handle_print_log(p_json_msg->s_file_name);
  402a17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402a1b:	48 8b 40 18          	mov    0x18(%rax),%rax
  402a1f:	48 89 c7             	mov    %rax,%rdi
  402a22:	e8 2a 05 00 00       	callq  402f51 <gsi_server_handle_print_log>
  402a27:	eb 2b                	jmp    402a54 <gsi_server_handle_op_code+0x117>

		case GSI_READ_FILE_BY_ID:
			return gsi_server_handle_read_file_by_id(p_json_msg->s_file_name, atoi(p_json_msg->s_data));
  402a29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402a2d:	48 8b 40 20          	mov    0x20(%rax),%rax
  402a31:	48 89 c7             	mov    %rax,%rdi
  402a34:	e8 77 ee ff ff       	callq  4018b0 <atoi@plt>
  402a39:	89 c2                	mov    %eax,%edx
  402a3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402a3f:	48 8b 40 18          	mov    0x18(%rax),%rax
  402a43:	89 d6                	mov    %edx,%esi
  402a45:	48 89 c7             	mov    %rax,%rdi
  402a48:	e8 23 05 00 00       	callq  402f70 <gsi_server_handle_read_file_by_id>
  402a4d:	eb 05                	jmp    402a54 <gsi_server_handle_op_code+0x117>

		default:
			return GSI_IS_FAIL;
  402a4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
  402a54:	48 83 c4 18          	add    $0x18,%rsp
  402a58:	5b                   	pop    %rbx
  402a59:	5d                   	pop    %rbp
  402a5a:	c3                   	retq   

0000000000402a5b <gsi_server_handle_read_str>:
	 * Parameter:   [in] int i_index - index in global array to read its string
	 * Return:		Success - 0
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_handle_read_str(int i_index)
{
  402a5b:	55                   	push   %rbp
  402a5c:	48 89 e5             	mov    %rsp,%rbp
  402a5f:	53                   	push   %rbx
  402a60:	48 83 ec 18          	sub    $0x18,%rsp
  402a64:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Check input validation
	if ((0 > i_index) || (GSI_IS_MAX_STRINGS < i_index))
  402a67:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  402a6b:	78 09                	js     402a76 <gsi_server_handle_read_str+0x1b>
  402a6d:	81 7d ec c8 00 00 00 	cmpl   $0xc8,-0x14(%rbp)
  402a74:	7e 44                	jle    402aba <gsi_server_handle_read_str+0x5f>
	{
		LOG_ERROR("index %d is out of range", i_index);
  402a76:	b8 00 00 00 00       	mov    $0x0,%eax
  402a7b:	e8 5c 3e 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402a80:	48 89 c3             	mov    %rax,%rbx
  402a83:	b8 00 00 00 00       	mov    $0x0,%eax
  402a88:	e8 ca 3b 00 00       	callq  406657 <gsi_get_saved_file>
  402a8d:	48 89 c7             	mov    %rax,%rdi
  402a90:	8b 45 ec             	mov    -0x14(%rbp),%eax
  402a93:	41 89 c1             	mov    %eax,%r9d
  402a96:	41 b8 06 02 00 00    	mov    $0x206,%r8d
  402a9c:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402aa1:	48 89 da             	mov    %rbx,%rdx
  402aa4:	be 60 80 40 00       	mov    $0x408060,%esi
  402aa9:	b8 00 00 00 00       	mov    $0x0,%eax
  402aae:	e8 0d 3c 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  402ab3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402ab8:	eb 24                	jmp    402ade <gsi_server_handle_read_str+0x83>
	}

	// Print the string to screen
	printf("%s\n", g_arr_strings[i_index]);
  402aba:	48 8b 05 0f 88 20 00 	mov    0x20880f(%rip),%rax        # 60b2d0 <g_arr_strings>
  402ac1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  402ac4:	48 63 d2             	movslq %edx,%rdx
  402ac7:	48 c1 e2 03          	shl    $0x3,%rdx
  402acb:	48 01 d0             	add    %rdx,%rax
  402ace:	48 8b 00             	mov    (%rax),%rax
  402ad1:	48 89 c7             	mov    %rax,%rdi
  402ad4:	e8 d7 ea ff ff       	callq  4015b0 <puts@plt>

	return 0;
  402ad9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402ade:	48 83 c4 18          	add    $0x18,%rsp
  402ae2:	5b                   	pop    %rbx
  402ae3:	5d                   	pop    %rbp
  402ae4:	c3                   	retq   

0000000000402ae5 <gsi_server_handle_write_str>:
	 * Parameter:   [in] int i_len - the length of new_str
	 * Return:		Success - 0
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_handle_write_str(int i_index, char* s_new_str, int i_len)
{
  402ae5:	55                   	push   %rbp
  402ae6:	48 89 e5             	mov    %rsp,%rbp
  402ae9:	53                   	push   %rbx
  402aea:	48 83 ec 18          	sub    $0x18,%rsp
  402aee:	89 7d ec             	mov    %edi,-0x14(%rbp)
  402af1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402af5:	89 55 e8             	mov    %edx,-0x18(%rbp)
	// Check input validation
	if ((0 > i_index) || (GSI_IS_MAX_STRINGS < i_index))
  402af8:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  402afc:	78 09                	js     402b07 <gsi_server_handle_write_str+0x22>
  402afe:	81 7d ec c8 00 00 00 	cmpl   $0xc8,-0x14(%rbp)
  402b05:	7e 47                	jle    402b4e <gsi_server_handle_write_str+0x69>
	{
		LOG_ERROR("index %d is out of range", i_index);
  402b07:	b8 00 00 00 00       	mov    $0x0,%eax
  402b0c:	e8 cb 3d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402b11:	48 89 c3             	mov    %rax,%rbx
  402b14:	b8 00 00 00 00       	mov    $0x0,%eax
  402b19:	e8 39 3b 00 00       	callq  406657 <gsi_get_saved_file>
  402b1e:	48 89 c7             	mov    %rax,%rdi
  402b21:	8b 45 ec             	mov    -0x14(%rbp),%eax
  402b24:	41 89 c1             	mov    %eax,%r9d
  402b27:	41 b8 1f 02 00 00    	mov    $0x21f,%r8d
  402b2d:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402b32:	48 89 da             	mov    %rbx,%rdx
  402b35:	be 60 80 40 00       	mov    $0x408060,%esi
  402b3a:	b8 00 00 00 00       	mov    $0x0,%eax
  402b3f:	e8 7c 3b 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  402b44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402b49:	e9 f3 00 00 00       	jmpq   402c41 <gsi_server_handle_write_str+0x15c>
	}

	// Check if need to use realloc
	if (i_len > strlen(g_arr_strings[i_index]))
  402b4e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  402b51:	48 63 d8             	movslq %eax,%rbx
  402b54:	48 8b 05 75 87 20 00 	mov    0x208775(%rip),%rax        # 60b2d0 <g_arr_strings>
  402b5b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  402b5e:	48 63 d2             	movslq %edx,%rdx
  402b61:	48 c1 e2 03          	shl    $0x3,%rdx
  402b65:	48 01 d0             	add    %rdx,%rax
  402b68:	48 8b 00             	mov    (%rax),%rax
  402b6b:	48 89 c7             	mov    %rax,%rdi
  402b6e:	e8 ad ea ff ff       	callq  401620 <strlen@plt>
  402b73:	48 39 c3             	cmp    %rax,%rbx
  402b76:	0f 86 9a 00 00 00    	jbe    402c16 <gsi_server_handle_write_str+0x131>
	{
		g_arr_strings[i_index] = realloc(g_arr_strings[i_index], i_len);
  402b7c:	48 8b 05 4d 87 20 00 	mov    0x20874d(%rip),%rax        # 60b2d0 <g_arr_strings>
  402b83:	8b 55 ec             	mov    -0x14(%rbp),%edx
  402b86:	48 63 d2             	movslq %edx,%rdx
  402b89:	48 c1 e2 03          	shl    $0x3,%rdx
  402b8d:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx
  402b91:	8b 45 e8             	mov    -0x18(%rbp),%eax
  402b94:	48 63 d0             	movslq %eax,%rdx
  402b97:	48 8b 05 32 87 20 00 	mov    0x208732(%rip),%rax        # 60b2d0 <g_arr_strings>
  402b9e:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  402ba1:	48 63 c9             	movslq %ecx,%rcx
  402ba4:	48 c1 e1 03          	shl    $0x3,%rcx
  402ba8:	48 01 c8             	add    %rcx,%rax
  402bab:	48 8b 00             	mov    (%rax),%rax
  402bae:	48 89 d6             	mov    %rdx,%rsi
  402bb1:	48 89 c7             	mov    %rax,%rdi
  402bb4:	e8 57 ec ff ff       	callq  401810 <realloc@plt>
  402bb9:	48 89 03             	mov    %rax,(%rbx)
		if (NULL == g_arr_strings[i_index])
  402bbc:	48 8b 05 0d 87 20 00 	mov    0x20870d(%rip),%rax        # 60b2d0 <g_arr_strings>
  402bc3:	8b 55 ec             	mov    -0x14(%rbp),%edx
  402bc6:	48 63 d2             	movslq %edx,%rdx
  402bc9:	48 c1 e2 03          	shl    $0x3,%rdx
  402bcd:	48 01 d0             	add    %rdx,%rax
  402bd0:	48 8b 00             	mov    (%rax),%rax
  402bd3:	48 85 c0             	test   %rax,%rax
  402bd6:	75 3e                	jne    402c16 <gsi_server_handle_write_str+0x131>
		{
			LOG_ERROR("memory reallocation failed");
  402bd8:	b8 00 00 00 00       	mov    $0x0,%eax
  402bdd:	e8 fa 3c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402be2:	48 89 c3             	mov    %rax,%rbx
  402be5:	b8 00 00 00 00       	mov    $0x0,%eax
  402bea:	e8 68 3a 00 00       	callq  406657 <gsi_get_saved_file>
  402bef:	41 b8 29 02 00 00    	mov    $0x229,%r8d
  402bf5:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402bfa:	48 89 da             	mov    %rbx,%rdx
  402bfd:	be 48 84 40 00       	mov    $0x408448,%esi
  402c02:	48 89 c7             	mov    %rax,%rdi
  402c05:	b8 00 00 00 00       	mov    $0x0,%eax
  402c0a:	e8 b1 3a 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_IS_FAIL;
  402c0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402c14:	eb 2b                	jmp    402c41 <gsi_server_handle_write_str+0x15c>
		}
	}

	// Copy new string content
	strcpy(g_arr_strings[i_index], s_new_str);
  402c16:	48 8b 05 b3 86 20 00 	mov    0x2086b3(%rip),%rax        # 60b2d0 <g_arr_strings>
  402c1d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  402c20:	48 63 d2             	movslq %edx,%rdx
  402c23:	48 c1 e2 03          	shl    $0x3,%rdx
  402c27:	48 01 d0             	add    %rdx,%rax
  402c2a:	48 8b 00             	mov    (%rax),%rax
  402c2d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402c31:	48 89 d6             	mov    %rdx,%rsi
  402c34:	48 89 c7             	mov    %rax,%rdi
  402c37:	e8 54 e9 ff ff       	callq  401590 <strcpy@plt>

	return 0;
  402c3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402c41:	48 83 c4 18          	add    $0x18,%rsp
  402c45:	5b                   	pop    %rbx
  402c46:	5d                   	pop    %rbp
  402c47:	c3                   	retq   

0000000000402c48 <gsi_server_handle_read_file>:
	 * Parameter:   [in] char* s_file_name - file to read
	 * Return:		Success - 0
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_handle_read_file(char* s_file_name, int flags)
{
  402c48:	55                   	push   %rbp
  402c49:	48 89 e5             	mov    %rsp,%rbp
  402c4c:	53                   	push   %rbx
  402c4d:	48 81 ec 38 20 03 00 	sub    $0x32038,%rsp
  402c54:	48 89 bd c8 df fc ff 	mov    %rdi,-0x32038(%rbp)
  402c5b:	89 b5 c4 df fc ff    	mov    %esi,-0x3203c(%rbp)
  402c61:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  402c68:	00 00 
  402c6a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402c6e:	31 c0                	xor    %eax,%eax
	int i_index = 0;
  402c70:	c7 85 d0 df fc ff 00 	movl   $0x0,-0x32030(%rbp)
  402c77:	00 00 00 
	char s_buffer[GSI_IS_MAX_STRINGS][GSI_IS_MAX_STR_LEN];
	FILE* f_read_file = NULL;
  402c7a:	48 c7 85 d8 df fc ff 	movq   $0x0,-0x32028(%rbp)
  402c81:	00 00 00 00 

	// Check input validation
	if (NULL == s_file_name)
  402c85:	48 83 bd c8 df fc ff 	cmpq   $0x0,-0x32038(%rbp)
  402c8c:	00 
  402c8d:	75 41                	jne    402cd0 <gsi_server_handle_read_file+0x88>
	{
		LOG_ERROR("invalid argument!");
  402c8f:	b8 00 00 00 00       	mov    $0x0,%eax
  402c94:	e8 43 3c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402c99:	48 89 c3             	mov    %rax,%rbx
  402c9c:	b8 00 00 00 00       	mov    $0x0,%eax
  402ca1:	e8 b1 39 00 00       	callq  406657 <gsi_get_saved_file>
  402ca6:	41 b8 44 02 00 00    	mov    $0x244,%r8d
  402cac:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402cb1:	48 89 da             	mov    %rbx,%rdx
  402cb4:	be b0 7e 40 00       	mov    $0x407eb0,%esi
  402cb9:	48 89 c7             	mov    %rax,%rdi
  402cbc:	b8 00 00 00 00       	mov    $0x0,%eax
  402cc1:	e8 fa 39 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  402cc6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402ccb:	e9 77 01 00 00       	jmpq   402e47 <gsi_server_handle_read_file+0x1ff>
	}

	// Open file to read from it
	f_read_file = fopen(s_file_name, "r");
  402cd0:	48 8b 85 c8 df fc ff 	mov    -0x32038(%rbp),%rax
  402cd7:	be 33 7f 40 00       	mov    $0x407f33,%esi
  402cdc:	48 89 c7             	mov    %rax,%rdi
  402cdf:	e8 8c eb ff ff       	callq  401870 <fopen@plt>
  402ce4:	48 89 85 d8 df fc ff 	mov    %rax,-0x32028(%rbp)
	if (NULL == f_read_file)
  402ceb:	48 83 bd d8 df fc ff 	cmpq   $0x0,-0x32028(%rbp)
  402cf2:	00 
  402cf3:	75 55                	jne    402d4a <gsi_server_handle_read_file+0x102>
	{
		perror("open: ");
  402cf5:	bf 84 84 40 00       	mov    $0x408484,%edi
  402cfa:	e8 81 eb ff ff       	callq  401880 <perror@plt>
		LOG_ERROR("failed to open %s", s_file_name);
  402cff:	b8 00 00 00 00       	mov    $0x0,%eax
  402d04:	e8 d3 3b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402d09:	48 89 c3             	mov    %rax,%rbx
  402d0c:	b8 00 00 00 00       	mov    $0x0,%eax
  402d11:	e8 41 39 00 00       	callq  406657 <gsi_get_saved_file>
  402d16:	48 89 c7             	mov    %rax,%rdi
  402d19:	48 8b 85 c8 df fc ff 	mov    -0x32038(%rbp),%rax
  402d20:	49 89 c1             	mov    %rax,%r9
  402d23:	41 b8 4d 02 00 00    	mov    $0x24d,%r8d
  402d29:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402d2e:	48 89 da             	mov    %rbx,%rdx
  402d31:	be 90 84 40 00       	mov    $0x408490,%esi
  402d36:	b8 00 00 00 00       	mov    $0x0,%eax
  402d3b:	e8 80 39 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  402d40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402d45:	e9 fd 00 00 00       	jmpq   402e47 <gsi_server_handle_read_file+0x1ff>
	}

	// Reset buffer
	memset(s_buffer, 0, sizeof(s_buffer));
  402d4a:	48 8d 85 e0 df fc ff 	lea    -0x32020(%rbp),%rax
  402d51:	ba 00 20 03 00       	mov    $0x32000,%edx
  402d56:	be 00 00 00 00       	mov    $0x0,%esi
  402d5b:	48 89 c7             	mov    %rax,%rdi
  402d5e:	e8 4d e9 ff ff       	callq  4016b0 <memset@plt>

	// Main loop to read up to GSI_IS_MAX_STRINGS and print them
	for (i_index = 0; i_index < GSI_IS_MAX_STRINGS; ++i_index)
  402d63:	c7 85 d0 df fc ff 00 	movl   $0x0,-0x32030(%rbp)
  402d6a:	00 00 00 
  402d6d:	eb 64                	jmp    402dd3 <gsi_server_handle_read_file+0x18b>
	{
		// Reset buffer
		memset(s_buffer[i_index], 0, sizeof(s_buffer[i_index]));
  402d6f:	48 8d 85 e0 df fc ff 	lea    -0x32020(%rbp),%rax
  402d76:	8b 95 d0 df fc ff    	mov    -0x32030(%rbp),%edx
  402d7c:	48 63 d2             	movslq %edx,%rdx
  402d7f:	48 c1 e2 0a          	shl    $0xa,%rdx
  402d83:	48 01 d0             	add    %rdx,%rax
  402d86:	ba 00 04 00 00       	mov    $0x400,%edx
  402d8b:	be 00 00 00 00       	mov    $0x0,%esi
  402d90:	48 89 c7             	mov    %rax,%rdi
  402d93:	e8 18 e9 ff ff       	callq  4016b0 <memset@plt>

		// Read line from file
		if (NULL == fgets(s_buffer[i_index], GSI_IS_MAX_STR_LEN, f_read_file))
  402d98:	48 8d 85 e0 df fc ff 	lea    -0x32020(%rbp),%rax
  402d9f:	8b 95 d0 df fc ff    	mov    -0x32030(%rbp),%edx
  402da5:	48 63 d2             	movslq %edx,%rdx
  402da8:	48 c1 e2 0a          	shl    $0xa,%rdx
  402dac:	48 8d 0c 10          	lea    (%rax,%rdx,1),%rcx
  402db0:	48 8b 85 d8 df fc ff 	mov    -0x32028(%rbp),%rax
  402db7:	48 89 c2             	mov    %rax,%rdx
  402dba:	be 00 04 00 00       	mov    $0x400,%esi
  402dbf:	48 89 cf             	mov    %rcx,%rdi
  402dc2:	e8 39 e9 ff ff       	callq  401700 <fgets@plt>
  402dc7:	48 85 c0             	test   %rax,%rax
  402dca:	74 15                	je     402de1 <gsi_server_handle_read_file+0x199>

	// Reset buffer
	memset(s_buffer, 0, sizeof(s_buffer));

	// Main loop to read up to GSI_IS_MAX_STRINGS and print them
	for (i_index = 0; i_index < GSI_IS_MAX_STRINGS; ++i_index)
  402dcc:	83 85 d0 df fc ff 01 	addl   $0x1,-0x32030(%rbp)
  402dd3:	81 bd d0 df fc ff c7 	cmpl   $0xc7,-0x32030(%rbp)
  402dda:	00 00 00 
  402ddd:	7e 90                	jle    402d6f <gsi_server_handle_read_file+0x127>
  402ddf:	eb 01                	jmp    402de2 <gsi_server_handle_read_file+0x19a>
		memset(s_buffer[i_index], 0, sizeof(s_buffer[i_index]));

		// Read line from file
		if (NULL == fgets(s_buffer[i_index], GSI_IS_MAX_STR_LEN, f_read_file))
		{
			break;
  402de1:	90                   	nop
		}
	}

	// Check if the user want to print to screen
	if (GSI_IS_PRINT_SCREEN == flags)
  402de2:	83 bd c4 df fc ff 01 	cmpl   $0x1,-0x3203c(%rbp)
  402de9:	75 48                	jne    402e33 <gsi_server_handle_read_file+0x1eb>
	{
		for (int i = 0; i < GSI_IS_MAX_STRINGS; ++i)
  402deb:	c7 85 d4 df fc ff 00 	movl   $0x0,-0x3202c(%rbp)
  402df2:	00 00 00 
  402df5:	eb 30                	jmp    402e27 <gsi_server_handle_read_file+0x1df>
		{
			printf("%s", s_buffer[i]);
  402df7:	48 8d 85 e0 df fc ff 	lea    -0x32020(%rbp),%rax
  402dfe:	8b 95 d4 df fc ff    	mov    -0x3202c(%rbp),%edx
  402e04:	48 63 d2             	movslq %edx,%rdx
  402e07:	48 c1 e2 0a          	shl    $0xa,%rdx
  402e0b:	48 01 d0             	add    %rdx,%rax
  402e0e:	48 89 c6             	mov    %rax,%rsi
  402e11:	bf c3 84 40 00       	mov    $0x4084c3,%edi
  402e16:	b8 00 00 00 00       	mov    $0x0,%eax
  402e1b:	e8 60 e8 ff ff       	callq  401680 <printf@plt>
	}

	// Check if the user want to print to screen
	if (GSI_IS_PRINT_SCREEN == flags)
	{
		for (int i = 0; i < GSI_IS_MAX_STRINGS; ++i)
  402e20:	83 85 d4 df fc ff 01 	addl   $0x1,-0x3202c(%rbp)
  402e27:	81 bd d4 df fc ff c7 	cmpl   $0xc7,-0x3202c(%rbp)
  402e2e:	00 00 00 
  402e31:	7e c4                	jle    402df7 <gsi_server_handle_read_file+0x1af>
			printf("%s", s_buffer[i]);
		}
	}

	// Close file
	fclose(f_read_file);
  402e33:	48 8b 85 d8 df fc ff 	mov    -0x32028(%rbp),%rax
  402e3a:	48 89 c7             	mov    %rax,%rdi
  402e3d:	e8 be e7 ff ff       	callq  401600 <fclose@plt>

	return 0;
  402e42:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402e47:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  402e4b:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  402e52:	00 00 
  402e54:	74 05                	je     402e5b <gsi_server_handle_read_file+0x213>
  402e56:	e8 d5 e7 ff ff       	callq  401630 <__stack_chk_fail@plt>
  402e5b:	48 81 c4 38 20 03 00 	add    $0x32038,%rsp
  402e62:	5b                   	pop    %rbx
  402e63:	5d                   	pop    %rbp
  402e64:	c3                   	retq   

0000000000402e65 <gsi_server_handle_write_file>:
	 * Parameter:   [in] char* s_msg - new message to insert
	 * Return:		Success - 0
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_handle_write_file(char* s_file_name, char* s_msg)
{
  402e65:	55                   	push   %rbp
  402e66:	48 89 e5             	mov    %rsp,%rbp
  402e69:	53                   	push   %rbx
  402e6a:	48 83 ec 28          	sub    $0x28,%rsp
  402e6e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  402e72:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Check input validation
	if ((NULL == s_file_name) || (NULL == s_msg))
  402e76:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  402e7b:	74 07                	je     402e84 <gsi_server_handle_write_file+0x1f>
  402e7d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  402e82:	75 41                	jne    402ec5 <gsi_server_handle_write_file+0x60>
	{
		LOG_ERROR("invalid arguments!");
  402e84:	b8 00 00 00 00       	mov    $0x0,%eax
  402e89:	e8 4e 3a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402e8e:	48 89 c3             	mov    %rax,%rbx
  402e91:	b8 00 00 00 00       	mov    $0x0,%eax
  402e96:	e8 bc 37 00 00       	callq  406657 <gsi_get_saved_file>
  402e9b:	41 b8 7d 02 00 00    	mov    $0x27d,%r8d
  402ea1:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402ea6:	48 89 da             	mov    %rbx,%rdx
  402ea9:	be c8 84 40 00       	mov    $0x4084c8,%esi
  402eae:	48 89 c7             	mov    %rax,%rdi
  402eb1:	b8 00 00 00 00       	mov    $0x0,%eax
  402eb6:	e8 05 38 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  402ebb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402ec0:	e9 85 00 00 00       	jmpq   402f4a <gsi_server_handle_write_file+0xe5>
	}

	// Open source file
	FILE* f_target = fopen(s_file_name, "a+");
  402ec5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402ec9:	be fc 84 40 00       	mov    $0x4084fc,%esi
  402ece:	48 89 c7             	mov    %rax,%rdi
  402ed1:	e8 9a e9 ff ff       	callq  401870 <fopen@plt>
  402ed6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == f_target)
  402eda:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  402edf:	75 45                	jne    402f26 <gsi_server_handle_write_file+0xc1>
	{
		LOG_ERROR("failed to open %s", s_file_name);
  402ee1:	b8 00 00 00 00       	mov    $0x0,%eax
  402ee6:	e8 f1 39 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402eeb:	48 89 c3             	mov    %rax,%rbx
  402eee:	b8 00 00 00 00       	mov    $0x0,%eax
  402ef3:	e8 5f 37 00 00       	callq  406657 <gsi_get_saved_file>
  402ef8:	48 89 c7             	mov    %rax,%rdi
  402efb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402eff:	49 89 c1             	mov    %rax,%r9
  402f02:	41 b8 85 02 00 00    	mov    $0x285,%r8d
  402f08:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402f0d:	48 89 da             	mov    %rbx,%rdx
  402f10:	be 90 84 40 00       	mov    $0x408490,%esi
  402f15:	b8 00 00 00 00       	mov    $0x0,%eax
  402f1a:	e8 a1 37 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  402f1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402f24:	eb 24                	jmp    402f4a <gsi_server_handle_write_file+0xe5>
	}

	// Insert meesage into file
	fputs(s_msg, f_target);
  402f26:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402f2a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  402f2e:	48 89 d6             	mov    %rdx,%rsi
  402f31:	48 89 c7             	mov    %rax,%rdi
  402f34:	e8 67 e7 ff ff       	callq  4016a0 <fputs@plt>

	// Close file
	fclose(f_target);
  402f39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402f3d:	48 89 c7             	mov    %rax,%rdi
  402f40:	e8 bb e6 ff ff       	callq  401600 <fclose@plt>

	return 0;
  402f45:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402f4a:	48 83 c4 28          	add    $0x28,%rsp
  402f4e:	5b                   	pop    %rbx
  402f4f:	5d                   	pop    %rbp
  402f50:	c3                   	retq   

0000000000402f51 <gsi_server_handle_print_log>:
	 * Parameter:   [in] char* s_file_name - log file to print
	 * Return:		Success - 0
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_handle_print_log(char* s_file_name)
{
  402f51:	55                   	push   %rbp
  402f52:	48 89 e5             	mov    %rsp,%rbp
  402f55:	48 83 ec 10          	sub    $0x10,%rsp
  402f59:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return gsi_server_handle_read_file(s_file_name, GSI_IS_PRINT_SCREEN);
  402f5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402f61:	be 01 00 00 00       	mov    $0x1,%esi
  402f66:	48 89 c7             	mov    %rax,%rdi
  402f69:	e8 da fc ff ff       	callq  402c48 <gsi_server_handle_read_file>
}
  402f6e:	c9                   	leaveq 
  402f6f:	c3                   	retq   

0000000000402f70 <gsi_server_handle_read_file_by_id>:
	 * Parameter:   [in] int i_id - message id
	 * Return:		Success - 0
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_handle_read_file_by_id(char* s_file_name, int i_id)
{
  402f70:	55                   	push   %rbp
  402f71:	48 89 e5             	mov    %rsp,%rbp
  402f74:	53                   	push   %rbx
  402f75:	48 81 ec 48 04 00 00 	sub    $0x448,%rsp
  402f7c:	48 89 bd b8 fb ff ff 	mov    %rdi,-0x448(%rbp)
  402f83:	89 b5 b4 fb ff ff    	mov    %esi,-0x44c(%rbp)
  402f89:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  402f90:	00 00 
  402f92:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402f96:	31 c0                	xor    %eax,%eax
	char s_buffer[GSI_IS_MAX_BUF_SIZE];
	char* s_res = s_buffer;
  402f98:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  402f9f:	48 89 85 d0 fb ff ff 	mov    %rax,-0x430(%rbp)
	int i_current_id = 0;
  402fa6:	c7 85 cc fb ff ff 00 	movl   $0x0,-0x434(%rbp)
  402fad:	00 00 00 
	int i_found = GSI_IS_FALSE;
  402fb0:	c7 85 c8 fb ff ff 00 	movl   $0x0,-0x438(%rbp)
  402fb7:	00 00 00 

	// Check input validation
	if ((NULL == s_file_name) || (0 > i_id))
  402fba:	48 83 bd b8 fb ff ff 	cmpq   $0x0,-0x448(%rbp)
  402fc1:	00 
  402fc2:	74 09                	je     402fcd <gsi_server_handle_read_file_by_id+0x5d>
  402fc4:	83 bd b4 fb ff ff 00 	cmpl   $0x0,-0x44c(%rbp)
  402fcb:	79 41                	jns    40300e <gsi_server_handle_read_file_by_id+0x9e>
	{
		LOG_ERROR("invalid arguments!");
  402fcd:	b8 00 00 00 00       	mov    $0x0,%eax
  402fd2:	e8 05 39 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  402fd7:	48 89 c3             	mov    %rax,%rbx
  402fda:	b8 00 00 00 00       	mov    $0x0,%eax
  402fdf:	e8 73 36 00 00       	callq  406657 <gsi_get_saved_file>
  402fe4:	41 b8 b0 02 00 00    	mov    $0x2b0,%r8d
  402fea:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  402fef:	48 89 da             	mov    %rbx,%rdx
  402ff2:	be c8 84 40 00       	mov    $0x4084c8,%esi
  402ff7:	48 89 c7             	mov    %rax,%rdi
  402ffa:	b8 00 00 00 00       	mov    $0x0,%eax
  402fff:	e8 bc 36 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  403004:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403009:	e9 71 01 00 00       	jmpq   40317f <gsi_server_handle_read_file_by_id+0x20f>
	}

	// Open source file
	FILE* f_target = fopen(s_file_name, "r");
  40300e:	48 8b 85 b8 fb ff ff 	mov    -0x448(%rbp),%rax
  403015:	be 33 7f 40 00       	mov    $0x407f33,%esi
  40301a:	48 89 c7             	mov    %rax,%rdi
  40301d:	e8 4e e8 ff ff       	callq  401870 <fopen@plt>
  403022:	48 89 85 d8 fb ff ff 	mov    %rax,-0x428(%rbp)
	if (NULL == f_target)
  403029:	48 83 bd d8 fb ff ff 	cmpq   $0x0,-0x428(%rbp)
  403030:	00 
  403031:	75 4b                	jne    40307e <gsi_server_handle_read_file_by_id+0x10e>
	{
		LOG_ERROR("failed to open %s", s_file_name);
  403033:	b8 00 00 00 00       	mov    $0x0,%eax
  403038:	e8 9f 38 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40303d:	48 89 c3             	mov    %rax,%rbx
  403040:	b8 00 00 00 00       	mov    $0x0,%eax
  403045:	e8 0d 36 00 00       	callq  406657 <gsi_get_saved_file>
  40304a:	48 89 c7             	mov    %rax,%rdi
  40304d:	48 8b 85 b8 fb ff ff 	mov    -0x448(%rbp),%rax
  403054:	49 89 c1             	mov    %rax,%r9
  403057:	41 b8 b8 02 00 00    	mov    $0x2b8,%r8d
  40305d:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  403062:	48 89 da             	mov    %rbx,%rdx
  403065:	be 90 84 40 00       	mov    $0x408490,%esi
  40306a:	b8 00 00 00 00       	mov    $0x0,%eax
  40306f:	e8 4c 36 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  403074:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403079:	e9 01 01 00 00       	jmpq   40317f <gsi_server_handle_read_file_by_id+0x20f>

	// Main loop - run until found the message with the match id
	while (1)
	{
		// Reset buffer
		memset(s_buffer, 0, sizeof(s_buffer));
  40307e:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  403085:	ba 00 04 00 00       	mov    $0x400,%edx
  40308a:	be 00 00 00 00       	mov    $0x0,%esi
  40308f:	48 89 c7             	mov    %rax,%rdi
  403092:	e8 19 e6 ff ff       	callq  4016b0 <memset@plt>

		// Read string from file into buffer
		if (NULL == fgets(s_buffer, GSI_IS_MAX_BUF_SIZE, f_target))
  403097:	48 8b 95 d8 fb ff ff 	mov    -0x428(%rbp),%rdx
  40309e:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  4030a5:	be 00 04 00 00       	mov    $0x400,%esi
  4030aa:	48 89 c7             	mov    %rax,%rdi
  4030ad:	e8 4e e6 ff ff       	callq  401700 <fgets@plt>
  4030b2:	48 85 c0             	test   %rax,%rax
  4030b5:	74 5c                	je     403113 <gsi_server_handle_read_file_by_id+0x1a3>
		{
			break;
		}

		// Extract the id from the string
		i_current_id = strtol(s_buffer, &s_res, 10);
  4030b7:	48 8d 8d d0 fb ff ff 	lea    -0x430(%rbp),%rcx
  4030be:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  4030c5:	ba 0a 00 00 00       	mov    $0xa,%edx
  4030ca:	48 89 ce             	mov    %rcx,%rsi
  4030cd:	48 89 c7             	mov    %rax,%rdi
  4030d0:	e8 9b e6 ff ff       	callq  401770 <strtol@plt>
  4030d5:	89 85 cc fb ff ff    	mov    %eax,-0x434(%rbp)

		// Check if match
		if (i_current_id == i_id)
  4030db:	8b 85 cc fb ff ff    	mov    -0x434(%rbp),%eax
  4030e1:	3b 85 b4 fb ff ff    	cmp    -0x44c(%rbp),%eax
  4030e7:	75 95                	jne    40307e <gsi_server_handle_read_file_by_id+0x10e>
		{
			i_found = GSI_IS_TRUE;
  4030e9:	c7 85 c8 fb ff ff 01 	movl   $0x1,-0x438(%rbp)
  4030f0:	00 00 00 
			printf("message id: %d\ncontent: %s", i_id, s_res);
  4030f3:	48 8b 95 d0 fb ff ff 	mov    -0x430(%rbp),%rdx
  4030fa:	8b 85 b4 fb ff ff    	mov    -0x44c(%rbp),%eax
  403100:	89 c6                	mov    %eax,%esi
  403102:	bf ff 84 40 00       	mov    $0x4084ff,%edi
  403107:	b8 00 00 00 00       	mov    $0x0,%eax
  40310c:	e8 6f e5 ff ff       	callq  401680 <printf@plt>
			break;
  403111:	eb 01                	jmp    403114 <gsi_server_handle_read_file_by_id+0x1a4>
		memset(s_buffer, 0, sizeof(s_buffer));

		// Read string from file into buffer
		if (NULL == fgets(s_buffer, GSI_IS_MAX_BUF_SIZE, f_target))
		{
			break;
  403113:	90                   	nop
			break;
		}
	}

	// Check if not found any message
	if (GSI_IS_FALSE == i_found)
  403114:	83 bd c8 fb ff ff 00 	cmpl   $0x0,-0x438(%rbp)
  40311b:	75 4e                	jne    40316b <gsi_server_handle_read_file_by_id+0x1fb>
	{
		LOG_WARNING("not found message with id: %d in file: %s", i_id, s_file_name);
  40311d:	b8 00 00 00 00       	mov    $0x0,%eax
  403122:	e8 b5 37 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403127:	48 89 c3             	mov    %rax,%rbx
  40312a:	b8 00 00 00 00       	mov    $0x0,%eax
  40312f:	e8 23 35 00 00       	callq  406657 <gsi_get_saved_file>
  403134:	48 89 c7             	mov    %rax,%rdi
  403137:	8b 85 b4 fb ff ff    	mov    -0x44c(%rbp),%eax
  40313d:	48 83 ec 08          	sub    $0x8,%rsp
  403141:	ff b5 b8 fb ff ff    	pushq  -0x448(%rbp)
  403147:	41 89 c1             	mov    %eax,%r9d
  40314a:	41 b8 d7 02 00 00    	mov    $0x2d7,%r8d
  403150:	b9 00 7e 40 00       	mov    $0x407e00,%ecx
  403155:	48 89 da             	mov    %rbx,%rdx
  403158:	be 20 85 40 00       	mov    $0x408520,%esi
  40315d:	b8 00 00 00 00       	mov    $0x0,%eax
  403162:	e8 59 35 00 00       	callq  4066c0 <gsi_is_write_to_log>
  403167:	48 83 c4 10          	add    $0x10,%rsp
	}

	// Close file
	fclose(f_target);
  40316b:	48 8b 85 d8 fb ff ff 	mov    -0x428(%rbp),%rax
  403172:	48 89 c7             	mov    %rax,%rdi
  403175:	e8 86 e4 ff ff       	callq  401600 <fclose@plt>

	return 0;
  40317a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40317f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  403183:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  40318a:	00 00 
  40318c:	74 05                	je     403193 <gsi_server_handle_read_file_by_id+0x223>
  40318e:	e8 9d e4 ff ff       	callq  401630 <__stack_chk_fail@plt>
  403193:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  403197:	c9                   	leaveq 
  403198:	c3                   	retq   

0000000000403199 <gsi_server_port_to_client>:
	 * Parameter:   [in] unsigned int ui_port - port number
	 * Return:		Success - Number representation of client
	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
static int gsi_server_port_to_client(unsigned int ui_port)
{
  403199:	55                   	push   %rbp
  40319a:	48 89 e5             	mov    %rsp,%rbp
  40319d:	89 7d fc             	mov    %edi,-0x4(%rbp)
	if (ui_port == g_config_server_params.ui_port1)
  4031a0:	8b 05 7a 81 20 00    	mov    0x20817a(%rip),%eax        # 60b320 <g_config_server_params>
  4031a6:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4031a9:	75 07                	jne    4031b2 <gsi_server_port_to_client+0x19>
	{
		return 1;
  4031ab:	b8 01 00 00 00       	mov    $0x1,%eax
  4031b0:	eb 29                	jmp    4031db <gsi_server_port_to_client+0x42>
	}
	if (ui_port == g_config_server_params.ui_port2)
  4031b2:	8b 05 6c 81 20 00    	mov    0x20816c(%rip),%eax        # 60b324 <g_config_server_params+0x4>
  4031b8:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4031bb:	75 07                	jne    4031c4 <gsi_server_port_to_client+0x2b>
	{
		return 2;
  4031bd:	b8 02 00 00 00       	mov    $0x2,%eax
  4031c2:	eb 17                	jmp    4031db <gsi_server_port_to_client+0x42>
	}
	if (ui_port == g_config_server_params.ui_port3)
  4031c4:	8b 05 5e 81 20 00    	mov    0x20815e(%rip),%eax        # 60b328 <g_config_server_params+0x8>
  4031ca:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4031cd:	75 07                	jne    4031d6 <gsi_server_port_to_client+0x3d>
	{
		return 3;
  4031cf:	b8 03 00 00 00       	mov    $0x3,%eax
  4031d4:	eb 05                	jmp    4031db <gsi_server_port_to_client+0x42>
	}

	return GSI_IS_FAIL;
  4031d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  4031db:	5d                   	pop    %rbp
  4031dc:	c3                   	retq   

00000000004031dd <gsi_is_open_msg_file>:
	 * Parameter:   [in] const char* s_file_name - file's name to open in READ mode
	 * Return:		Success - FILE* - handler to opened file
	 * 				Failure - NULL
#############################################################################*/
FILE* gsi_is_open_msg_file(const char* s_file_name)
{
  4031dd:	55                   	push   %rbp
  4031de:	48 89 e5             	mov    %rsp,%rbp
  4031e1:	53                   	push   %rbx
  4031e2:	48 83 ec 28          	sub    $0x28,%rsp
  4031e6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	FILE* f_msg_file = NULL;
  4031ea:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  4031f1:	00 

	// Check input validation
	if (NULL == s_file_name)
  4031f2:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  4031f7:	75 3e                	jne    403237 <gsi_is_open_msg_file+0x5a>
	{
		LOG_ERROR("invalid argument!");
  4031f9:	b8 00 00 00 00       	mov    $0x0,%eax
  4031fe:	e8 d9 36 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403203:	48 89 c3             	mov    %rax,%rbx
  403206:	b8 00 00 00 00       	mov    $0x0,%eax
  40320b:	e8 47 34 00 00       	callq  406657 <gsi_get_saved_file>
  403210:	41 b8 37 00 00 00    	mov    $0x37,%r8d
  403216:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40321b:	48 89 da             	mov    %rbx,%rdx
  40321e:	be 90 85 40 00       	mov    $0x408590,%esi
  403223:	48 89 c7             	mov    %rax,%rdi
  403226:	b8 00 00 00 00       	mov    $0x0,%eax
  40322b:	e8 90 34 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  403230:	b8 00 00 00 00       	mov    $0x0,%eax
  403235:	eb 5e                	jmp    403295 <gsi_is_open_msg_file+0xb8>
	}

	// Open messages file
	f_msg_file = fopen(s_file_name, "r");
  403237:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40323b:	be c3 85 40 00       	mov    $0x4085c3,%esi
  403240:	48 89 c7             	mov    %rax,%rdi
  403243:	e8 28 e6 ff ff       	callq  401870 <fopen@plt>
  403248:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == f_msg_file)
  40324c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  403251:	75 3e                	jne    403291 <gsi_is_open_msg_file+0xb4>
	{
		LOG_ERROR("couldn't open file: %s", s_file_name);
  403253:	b8 00 00 00 00       	mov    $0x0,%eax
  403258:	e8 7f 36 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40325d:	48 89 c3             	mov    %rax,%rbx
  403260:	b8 00 00 00 00       	mov    $0x0,%eax
  403265:	e8 ed 33 00 00       	callq  406657 <gsi_get_saved_file>
  40326a:	48 89 c7             	mov    %rax,%rdi
  40326d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403271:	49 89 c1             	mov    %rax,%r9
  403274:	41 b8 3f 00 00 00    	mov    $0x3f,%r8d
  40327a:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40327f:	48 89 da             	mov    %rbx,%rdx
  403282:	be c8 85 40 00       	mov    $0x4085c8,%esi
  403287:	b8 00 00 00 00       	mov    $0x0,%eax
  40328c:	e8 2f 34 00 00       	callq  4066c0 <gsi_is_write_to_log>
	}

	return f_msg_file;
  403291:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  403295:	48 83 c4 28          	add    $0x28,%rsp
  403299:	5b                   	pop    %rbx
  40329a:	5d                   	pop    %rbp
  40329b:	c3                   	retq   

000000000040329c <gsi_is_close_msg_file>:
	 * Parameter:   [in] FILE* f_msg_file - handler to opened file
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_CLOSE_ERR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_is_close_msg_file(FILE* f_msg_file)
{
  40329c:	55                   	push   %rbp
  40329d:	48 89 e5             	mov    %rsp,%rbp
  4032a0:	53                   	push   %rbx
  4032a1:	48 83 ec 18          	sub    $0x18,%rsp
  4032a5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == f_msg_file)
  4032a9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4032ae:	75 3e                	jne    4032ee <gsi_is_close_msg_file+0x52>
	{
		LOG_ERROR("invalid argument!");
  4032b0:	b8 00 00 00 00       	mov    $0x0,%eax
  4032b5:	e8 22 36 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4032ba:	48 89 c3             	mov    %rax,%rbx
  4032bd:	b8 00 00 00 00       	mov    $0x0,%eax
  4032c2:	e8 90 33 00 00       	callq  406657 <gsi_get_saved_file>
  4032c7:	41 b8 51 00 00 00    	mov    $0x51,%r8d
  4032cd:	b9 70 85 40 00       	mov    $0x408570,%ecx
  4032d2:	48 89 da             	mov    %rbx,%rdx
  4032d5:	be 90 85 40 00       	mov    $0x408590,%esi
  4032da:	48 89 c7             	mov    %rax,%rdi
  4032dd:	b8 00 00 00 00       	mov    $0x0,%eax
  4032e2:	e8 d9 33 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  4032e7:	b8 01 00 00 00       	mov    $0x1,%eax
  4032ec:	eb 53                	jmp    403341 <gsi_is_close_msg_file+0xa5>
	}

	// Close file
	if (0 != fclose(f_msg_file))
  4032ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4032f2:	48 89 c7             	mov    %rax,%rdi
  4032f5:	e8 06 e3 ff ff       	callq  401600 <fclose@plt>
  4032fa:	85 c0                	test   %eax,%eax
  4032fc:	74 3e                	je     40333c <gsi_is_close_msg_file+0xa0>
	{
		LOG_ERROR("couldn't close messages file");
  4032fe:	b8 00 00 00 00       	mov    $0x0,%eax
  403303:	e8 d4 35 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403308:	48 89 c3             	mov    %rax,%rbx
  40330b:	b8 00 00 00 00       	mov    $0x0,%eax
  403310:	e8 42 33 00 00       	callq  406657 <gsi_get_saved_file>
  403315:	41 b8 58 00 00 00    	mov    $0x58,%r8d
  40331b:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403320:	48 89 da             	mov    %rbx,%rdx
  403323:	be 00 86 40 00       	mov    $0x408600,%esi
  403328:	48 89 c7             	mov    %rax,%rdi
  40332b:	b8 00 00 00 00       	mov    $0x0,%eax
  403330:	e8 8b 33 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_CLOSE_ERR;
  403335:	b8 03 00 00 00       	mov    $0x3,%eax
  40333a:	eb 05                	jmp    403341 <gsi_is_close_msg_file+0xa5>
	}

	return GSI_JSON_SUCCESS;
  40333c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403341:	48 83 c4 18          	add    $0x18,%rsp
  403345:	5b                   	pop    %rbx
  403346:	5d                   	pop    %rbp
  403347:	c3                   	retq   

0000000000403348 <gsi_build_parse_reset_object>:
	 * Parameter:   [in-out] struct gsi_json_msg* p_json_msg - pointer to reset
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_build_parse_reset_object(struct gsi_json_msg* p_json_msg)
{
  403348:	55                   	push   %rbp
  403349:	48 89 e5             	mov    %rsp,%rbp
  40334c:	53                   	push   %rbx
  40334d:	48 83 ec 18          	sub    $0x18,%rsp
  403351:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == p_json_msg)
  403355:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  40335a:	75 3e                	jne    40339a <gsi_build_parse_reset_object+0x52>
	{
		LOG_ERROR("invalid argument!");
  40335c:	b8 00 00 00 00       	mov    $0x0,%eax
  403361:	e8 76 35 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403366:	48 89 c3             	mov    %rax,%rbx
  403369:	b8 00 00 00 00       	mov    $0x0,%eax
  40336e:	e8 e4 32 00 00       	callq  406657 <gsi_get_saved_file>
  403373:	41 b8 6b 00 00 00    	mov    $0x6b,%r8d
  403379:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40337e:	48 89 da             	mov    %rbx,%rdx
  403381:	be 90 85 40 00       	mov    $0x408590,%esi
  403386:	48 89 c7             	mov    %rax,%rdi
  403389:	b8 00 00 00 00       	mov    $0x0,%eax
  40338e:	e8 2d 33 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  403393:	b8 01 00 00 00       	mov    $0x1,%eax
  403398:	eb 55                	jmp    4033ef <gsi_build_parse_reset_object+0xa7>
	}

	// Check if need to free s_file_name
	if (NULL != p_json_msg->s_file_name)
  40339a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40339e:	48 8b 40 18          	mov    0x18(%rax),%rax
  4033a2:	48 85 c0             	test   %rax,%rax
  4033a5:	74 10                	je     4033b7 <gsi_build_parse_reset_object+0x6f>
	{
		free(p_json_msg->s_file_name);
  4033a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4033ab:	48 8b 40 18          	mov    0x18(%rax),%rax
  4033af:	48 89 c7             	mov    %rax,%rdi
  4033b2:	e8 99 e1 ff ff       	callq  401550 <free@plt>
	}

	// Check if need to free s_data
	if (NULL != p_json_msg->s_data)
  4033b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4033bb:	48 8b 40 20          	mov    0x20(%rax),%rax
  4033bf:	48 85 c0             	test   %rax,%rax
  4033c2:	74 10                	je     4033d4 <gsi_build_parse_reset_object+0x8c>
	{
		free(p_json_msg->s_data);
  4033c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4033c8:	48 8b 40 20          	mov    0x20(%rax),%rax
  4033cc:	48 89 c7             	mov    %rax,%rdi
  4033cf:	e8 7c e1 ff ff       	callq  401550 <free@plt>
	}

	// Reset fields
	memset(p_json_msg, 0, sizeof(struct gsi_json_msg));
  4033d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4033d8:	ba 28 00 00 00       	mov    $0x28,%edx
  4033dd:	be 00 00 00 00       	mov    $0x0,%esi
  4033e2:	48 89 c7             	mov    %rax,%rdi
  4033e5:	e8 c6 e2 ff ff       	callq  4016b0 <memset@plt>

	return GSI_JSON_SUCCESS;
  4033ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4033ef:	48 83 c4 18          	add    $0x18,%rsp
  4033f3:	5b                   	pop    %rbx
  4033f4:	5d                   	pop    %rbp
  4033f5:	c3                   	retq   

00000000004033f6 <gsi_is_send_all_json_msg>:
	 * Parameter:   [in] struct gsi_net_tcp* p_client - client that wants to send the messages
	 * Return :		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_is_send_all_json_msg(FILE* f_msg_file, struct gsi_net_tcp* p_client)
{
  4033f6:	55                   	push   %rbp
  4033f7:	48 89 e5             	mov    %rsp,%rbp
  4033fa:	53                   	push   %rbx
  4033fb:	48 83 ec 58          	sub    $0x58,%rsp
  4033ff:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  403403:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  403407:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40340e:	00 00 
  403410:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  403414:	31 c0                	xor    %eax,%eax
	struct gsi_json_msg json_msg;
	int i_rc = GSI_JSON_SUCCESS;
  403416:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)

	// Check input validation
	if ((NULL == f_msg_file) || (NULL == p_client))
  40341d:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  403422:	74 07                	je     40342b <gsi_is_send_all_json_msg+0x35>
  403424:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  403429:	75 41                	jne    40346c <gsi_is_send_all_json_msg+0x76>
	{
		LOG_ERROR("invalid arguments!");
  40342b:	b8 00 00 00 00       	mov    $0x0,%eax
  403430:	e8 a7 34 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403435:	48 89 c3             	mov    %rax,%rbx
  403438:	b8 00 00 00 00       	mov    $0x0,%eax
  40343d:	e8 15 32 00 00       	callq  406657 <gsi_get_saved_file>
  403442:	41 b8 91 00 00 00    	mov    $0x91,%r8d
  403448:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40344d:	48 89 da             	mov    %rbx,%rdx
  403450:	be 40 86 40 00       	mov    $0x408640,%esi
  403455:	48 89 c7             	mov    %rax,%rdi
  403458:	b8 00 00 00 00       	mov    $0x0,%eax
  40345d:	e8 5e 32 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  403462:	b8 01 00 00 00       	mov    $0x1,%eax
  403467:	e9 9a 00 00 00       	jmpq   403506 <gsi_is_send_all_json_msg+0x110>
	}

	// Reset fields
	memset(&json_msg, 0, sizeof(json_msg));
  40346c:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  403470:	ba 28 00 00 00       	mov    $0x28,%edx
  403475:	be 00 00 00 00       	mov    $0x0,%esi
  40347a:	48 89 c7             	mov    %rax,%rdi
  40347d:	e8 2e e2 ff ff       	callq  4016b0 <memset@plt>

	// Main loop to send all messages
	while (1)
	{
		// Get next message from file
		i_rc = gsi_is_get_next_msg(f_msg_file, &json_msg);
  403482:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  403486:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  40348a:	48 89 d6             	mov    %rdx,%rsi
  40348d:	48 89 c7             	mov    %rax,%rdi
  403490:	e8 bc 05 00 00       	callq  403a51 <gsi_is_get_next_msg>
  403495:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (GSI_JSON_READ_ERROR == i_rc)
  403498:	83 7d bc 04          	cmpl   $0x4,-0x44(%rbp)
  40349c:	75 09                	jne    4034a7 <gsi_is_send_all_json_msg+0xb1>
		{
			i_rc = GSI_JSON_SUCCESS;
  40349e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
			break;
  4034a5:	eb 45                	jmp    4034ec <gsi_is_send_all_json_msg+0xf6>
		}
		else if ((GSI_JSON_ERROR == i_rc) || (GSI_JSON_INVALID_ERR == i_rc))
  4034a7:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%rbp)
  4034ab:	74 3f                	je     4034ec <gsi_is_send_all_json_msg+0xf6>
  4034ad:	83 7d bc 01          	cmpl   $0x1,-0x44(%rbp)
  4034b1:	74 39                	je     4034ec <gsi_is_send_all_json_msg+0xf6>
		{
			break;
		}

		if (GSI_COMMENT == json_msg.i_msg_type)
  4034b3:	8b 45 c0             	mov    -0x40(%rbp),%eax
  4034b6:	83 f8 03             	cmp    $0x3,%eax
  4034b9:	74 2e                	je     4034e9 <gsi_is_send_all_json_msg+0xf3>
		{
			continue;
		}

		// Send message
		if (GSI_JSON_SUCCESS != gsi_is_send_json_msg(p_client, &json_msg))
  4034bb:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  4034bf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  4034c3:	48 89 d6             	mov    %rdx,%rsi
  4034c6:	48 89 c7             	mov    %rax,%rdi
  4034c9:	e8 53 00 00 00       	callq  403521 <gsi_is_send_json_msg>
  4034ce:	85 c0                	test   %eax,%eax
  4034d0:	74 09                	je     4034db <gsi_is_send_all_json_msg+0xe5>
		{
			i_rc = GSI_JSON_ERROR;
  4034d2:	c7 45 bc ff ff ff ff 	movl   $0xffffffff,-0x44(%rbp)
			break;
  4034d9:	eb 11                	jmp    4034ec <gsi_is_send_all_json_msg+0xf6>
		}

		// Reset the json-msg object
		gsi_build_parse_reset_object(&json_msg);
  4034db:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4034df:	48 89 c7             	mov    %rax,%rdi
  4034e2:	e8 61 fe ff ff       	callq  403348 <gsi_build_parse_reset_object>
  4034e7:	eb 99                	jmp    403482 <gsi_is_send_all_json_msg+0x8c>
			break;
		}

		if (GSI_COMMENT == json_msg.i_msg_type)
		{
			continue;
  4034e9:	90                   	nop
			break;
		}

		// Reset the json-msg object
		gsi_build_parse_reset_object(&json_msg);
	}
  4034ea:	eb 96                	jmp    403482 <gsi_is_send_all_json_msg+0x8c>

	// Reset the json-msg object
	if (GSI_JSON_SUCCESS != gsi_build_parse_reset_object(&json_msg))
  4034ec:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4034f0:	48 89 c7             	mov    %rax,%rdi
  4034f3:	e8 50 fe ff ff       	callq  403348 <gsi_build_parse_reset_object>
  4034f8:	85 c0                	test   %eax,%eax
  4034fa:	74 07                	je     403503 <gsi_is_send_all_json_msg+0x10d>
	{
		return GSI_JSON_ERROR;
  4034fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403501:	eb 03                	jmp    403506 <gsi_is_send_all_json_msg+0x110>
	}

	return i_rc;
  403503:	8b 45 bc             	mov    -0x44(%rbp),%eax
}
  403506:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  40350a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  403511:	00 00 
  403513:	74 05                	je     40351a <gsi_is_send_all_json_msg+0x124>
  403515:	e8 16 e1 ff ff       	callq  401630 <__stack_chk_fail@plt>
  40351a:	48 83 c4 58          	add    $0x58,%rsp
  40351e:	5b                   	pop    %rbx
  40351f:	5d                   	pop    %rbp
  403520:	c3                   	retq   

0000000000403521 <gsi_is_send_json_msg>:
	 * Parameter:   [in] struct gsi_json_msg* p_json_msg - pointer to message structure
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_is_send_json_msg(struct gsi_net_tcp* p_client, struct gsi_json_msg* p_json_msg)
{
  403521:	55                   	push   %rbp
  403522:	48 89 e5             	mov    %rsp,%rbp
  403525:	41 54                	push   %r12
  403527:	53                   	push   %rbx
  403528:	48 83 ec 40          	sub    $0x40,%rsp
  40352c:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  403530:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  403534:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40353b:	00 00 
  40353d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  403541:	31 c0                	xor    %eax,%eax
	struct gsi_cs_tcp_message msg;
	struct json_object *p_json = NULL;
  403543:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  40354a:	00 
	char* s_full_object = NULL;
  40354b:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  403552:	00 

	// Check input validation
	if ((NULL == p_client) || (NULL == p_json_msg))
  403553:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  403558:	74 07                	je     403561 <gsi_is_send_json_msg+0x40>
  40355a:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  40355f:	75 41                	jne    4035a2 <gsi_is_send_json_msg+0x81>
	{
		LOG_ERROR("invalid arguments!");
  403561:	b8 00 00 00 00       	mov    $0x0,%eax
  403566:	e8 71 33 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40356b:	48 89 c3             	mov    %rax,%rbx
  40356e:	b8 00 00 00 00       	mov    $0x0,%eax
  403573:	e8 df 30 00 00       	callq  406657 <gsi_get_saved_file>
  403578:	41 b8 d1 00 00 00    	mov    $0xd1,%r8d
  40357e:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403583:	48 89 da             	mov    %rbx,%rdx
  403586:	be 40 86 40 00       	mov    $0x408640,%esi
  40358b:	48 89 c7             	mov    %rax,%rdi
  40358e:	b8 00 00 00 00       	mov    $0x0,%eax
  403593:	e8 28 31 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  403598:	b8 01 00 00 00       	mov    $0x1,%eax
  40359d:	e9 41 02 00 00       	jmpq   4037e3 <gsi_is_send_json_msg+0x2c2>
	}

	// Reset message fields
	memset(&msg, 0, sizeof(msg));
  4035a2:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  4035a6:	ba 18 00 00 00       	mov    $0x18,%edx
  4035ab:	be 00 00 00 00       	mov    $0x0,%esi
  4035b0:	48 89 c7             	mov    %rax,%rdi
  4035b3:	e8 f8 e0 ff ff       	callq  4016b0 <memset@plt>

	// Set fields
	msg.e_type_msg = p_json_msg->i_msg_type;
  4035b8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  4035bc:	8b 00                	mov    (%rax),%eax
  4035be:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	msg.ui_port = p_client->ui_port;
  4035c1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4035c5:	8b 40 28             	mov    0x28(%rax),%eax
  4035c8:	89 45 d0             	mov    %eax,-0x30(%rbp)
	p_json_msg->ui_port = p_client->ui_port;
  4035cb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4035cf:	8b 50 28             	mov    0x28(%rax),%edx
  4035d2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  4035d6:	89 50 08             	mov    %edx,0x8(%rax)

	// Create new json object
	p_json = json_object_new_object();
  4035d9:	e8 62 e0 ff ff       	callq  401640 <json_object_new_object@plt>
  4035de:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	if (NULL == p_json)
  4035e2:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  4035e7:	75 41                	jne    40362a <gsi_is_send_json_msg+0x109>
	{
		LOG_ERROR("allocate new json object failed");
  4035e9:	b8 00 00 00 00       	mov    $0x0,%eax
  4035ee:	e8 e9 32 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4035f3:	48 89 c3             	mov    %rax,%rbx
  4035f6:	b8 00 00 00 00       	mov    $0x0,%eax
  4035fb:	e8 57 30 00 00       	callq  406657 <gsi_get_saved_file>
  403600:	41 b8 e1 00 00 00    	mov    $0xe1,%r8d
  403606:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40360b:	48 89 da             	mov    %rbx,%rdx
  40360e:	be 78 86 40 00       	mov    $0x408678,%esi
  403613:	48 89 c7             	mov    %rax,%rdi
  403616:	b8 00 00 00 00       	mov    $0x0,%eax
  40361b:	e8 a0 30 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  403620:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403625:	e9 b9 01 00 00       	jmpq   4037e3 <gsi_is_send_json_msg+0x2c2>
	}

	// Stringify the json-msg to string. using JSON-C library functions
	// create object for each member field in structure and its value
	s_full_object = gsi_build_parse_json_obj_to_string(p_json, p_json_msg);
  40362a:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  40362e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  403632:	48 89 d6             	mov    %rdx,%rsi
  403635:	48 89 c7             	mov    %rax,%rdi
  403638:	e8 d1 0d 00 00       	callq  40440e <gsi_build_parse_json_obj_to_string>
  40363d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	if (NULL == s_full_object)
  403641:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  403646:	75 4d                	jne    403695 <gsi_is_send_json_msg+0x174>
	{
		LOG_ERROR("json object to string failed");
  403648:	b8 00 00 00 00       	mov    $0x0,%eax
  40364d:	e8 8a 32 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403652:	48 89 c3             	mov    %rax,%rbx
  403655:	b8 00 00 00 00       	mov    $0x0,%eax
  40365a:	e8 f8 2f 00 00       	callq  406657 <gsi_get_saved_file>
  40365f:	41 b8 ea 00 00 00    	mov    $0xea,%r8d
  403665:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40366a:	48 89 da             	mov    %rbx,%rdx
  40366d:	be c0 86 40 00       	mov    $0x4086c0,%esi
  403672:	48 89 c7             	mov    %rax,%rdi
  403675:	b8 00 00 00 00       	mov    $0x0,%eax
  40367a:	e8 41 30 00 00       	callq  4066c0 <gsi_is_write_to_log>
		json_object_put(p_json);
  40367f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  403683:	48 89 c7             	mov    %rax,%rdi
  403686:	e8 85 e2 ff ff       	callq  401910 <json_object_put@plt>
		return GSI_JSON_ERROR;
  40368b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403690:	e9 4e 01 00 00       	jmpq   4037e3 <gsi_is_send_json_msg+0x2c2>
	}

	LOG_DEBUG("\nJSON:\n%s\n", s_full_object);
  403695:	b8 00 00 00 00       	mov    $0x0,%eax
  40369a:	e8 3d 32 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40369f:	48 89 c3             	mov    %rax,%rbx
  4036a2:	b8 00 00 00 00       	mov    $0x0,%eax
  4036a7:	e8 ab 2f 00 00       	callq  406657 <gsi_get_saved_file>
  4036ac:	48 89 c7             	mov    %rax,%rdi
  4036af:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4036b3:	49 89 c1             	mov    %rax,%r9
  4036b6:	41 b8 ef 00 00 00    	mov    $0xef,%r8d
  4036bc:	b9 70 85 40 00       	mov    $0x408570,%ecx
  4036c1:	48 89 da             	mov    %rbx,%rdx
  4036c4:	be 00 87 40 00       	mov    $0x408700,%esi
  4036c9:	b8 00 00 00 00       	mov    $0x0,%eax
  4036ce:	e8 ed 2f 00 00       	callq  4066c0 <gsi_is_write_to_log>

	// Get full length
	msg.ui_len = strlen(s_full_object) + 1;
  4036d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4036d7:	48 89 c7             	mov    %rax,%rdi
  4036da:	e8 41 df ff ff       	callq  401620 <strlen@plt>
  4036df:	83 c0 01             	add    $0x1,%eax
  4036e2:	89 45 d8             	mov    %eax,-0x28(%rbp)

	// Duplicate the new message
	msg.s_message = gsi_build_parse_strdup(s_full_object);
  4036e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4036e9:	48 89 c7             	mov    %rax,%rdi
  4036ec:	e8 95 15 00 00       	callq  404c86 <gsi_build_parse_strdup>
  4036f1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (NULL == msg.s_message)
  4036f5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4036f9:	48 85 c0             	test   %rax,%rax
  4036fc:	75 4d                	jne    40374b <gsi_is_send_json_msg+0x22a>
	{
		LOG_ERROR("memory allocation for s_message failed");
  4036fe:	b8 00 00 00 00       	mov    $0x0,%eax
  403703:	e8 d4 31 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403708:	48 89 c3             	mov    %rax,%rbx
  40370b:	b8 00 00 00 00       	mov    $0x0,%eax
  403710:	e8 42 2f 00 00       	callq  406657 <gsi_get_saved_file>
  403715:	41 b8 f8 00 00 00    	mov    $0xf8,%r8d
  40371b:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403720:	48 89 da             	mov    %rbx,%rdx
  403723:	be 30 87 40 00       	mov    $0x408730,%esi
  403728:	48 89 c7             	mov    %rax,%rdi
  40372b:	b8 00 00 00 00       	mov    $0x0,%eax
  403730:	e8 8b 2f 00 00       	callq  4066c0 <gsi_is_write_to_log>
		json_object_put(p_json);
  403735:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  403739:	48 89 c7             	mov    %rax,%rdi
  40373c:	e8 cf e1 ff ff       	callq  401910 <json_object_put@plt>
		return GSI_JSON_ERROR;
  403741:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403746:	e9 98 00 00 00       	jmpq   4037e3 <gsi_is_send_json_msg+0x2c2>
	}

	// Free the json object
	json_object_put(p_json);
  40374b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  40374f:	48 89 c7             	mov    %rax,%rdi
  403752:	e8 b9 e1 ff ff       	callq  401910 <json_object_put@plt>

	// Send message to server
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_send(p_client, (char *)&msg))
  403757:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  40375b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40375f:	48 89 d6             	mov    %rdx,%rsi
  403762:	48 89 c7             	mov    %rax,%rdi
  403765:	e8 33 19 00 00       	callq  40509d <gsi_is_network_tcp_send>
  40376a:	85 c0                	test   %eax,%eax
  40376c:	74 5c                	je     4037ca <gsi_is_send_json_msg+0x2a9>
	{
		LOG_ERROR("send message failed on port %d", p_client->ui_port);
  40376e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  403772:	8b 58 28             	mov    0x28(%rax),%ebx
  403775:	b8 00 00 00 00       	mov    $0x0,%eax
  40377a:	e8 5d 31 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40377f:	49 89 c4             	mov    %rax,%r12
  403782:	b8 00 00 00 00       	mov    $0x0,%eax
  403787:	e8 cb 2e 00 00       	callq  406657 <gsi_get_saved_file>
  40378c:	41 89 d9             	mov    %ebx,%r9d
  40378f:	41 b8 03 01 00 00    	mov    $0x103,%r8d
  403795:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40379a:	4c 89 e2             	mov    %r12,%rdx
  40379d:	be 78 87 40 00       	mov    $0x408778,%esi
  4037a2:	48 89 c7             	mov    %rax,%rdi
  4037a5:	b8 00 00 00 00       	mov    $0x0,%eax
  4037aa:	e8 11 2f 00 00       	callq  4066c0 <gsi_is_write_to_log>

		// Free the message memory
		free(msg.s_message);
  4037af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4037b3:	48 89 c7             	mov    %rax,%rdi
  4037b6:	e8 95 dd ff ff       	callq  401550 <free@plt>
		msg.s_message = NULL;
  4037bb:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  4037c2:	00 

		return GSI_NET_RC_ERROR;
  4037c3:	b8 01 00 00 00       	mov    $0x1,%eax
  4037c8:	eb 19                	jmp    4037e3 <gsi_is_send_json_msg+0x2c2>
	}

	// Free the message memory
	free(msg.s_message);
  4037ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4037ce:	48 89 c7             	mov    %rax,%rdi
  4037d1:	e8 7a dd ff ff       	callq  401550 <free@plt>
	msg.s_message = NULL;
  4037d6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  4037dd:	00 

	return GSI_JSON_SUCCESS;
  4037de:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4037e3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  4037e7:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  4037ee:	00 00 
  4037f0:	74 05                	je     4037f7 <gsi_is_send_json_msg+0x2d6>
  4037f2:	e8 39 de ff ff       	callq  401630 <__stack_chk_fail@plt>
  4037f7:	48 83 c4 40          	add    $0x40,%rsp
  4037fb:	5b                   	pop    %rbx
  4037fc:	41 5c                	pop    %r12
  4037fe:	5d                   	pop    %rbp
  4037ff:	c3                   	retq   

0000000000403800 <gsi_is_recv_json_msg>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to message structure
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_is_recv_json_msg(struct gsi_net_tcp* p_server, struct gsi_json_msg* p_json_msg)
{
  403800:	55                   	push   %rbp
  403801:	48 89 e5             	mov    %rsp,%rbp
  403804:	41 54                	push   %r12
  403806:	53                   	push   %rbx
  403807:	48 83 ec 40          	sub    $0x40,%rsp
  40380b:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  40380f:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  403813:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40381a:	00 00 
  40381c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  403820:	31 c0                	xor    %eax,%eax
	struct gsi_cs_tcp_message msg;
	struct json_object *p_json = NULL;
  403822:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  403829:	00 

	// Check input validation
	if ((NULL == p_server) || (NULL == p_json_msg))
  40382a:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  40382f:	74 07                	je     403838 <gsi_is_recv_json_msg+0x38>
  403831:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  403836:	75 41                	jne    403879 <gsi_is_recv_json_msg+0x79>
	{
		LOG_ERROR("invalid arguments!");
  403838:	b8 00 00 00 00       	mov    $0x0,%eax
  40383d:	e8 9a 30 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403842:	48 89 c3             	mov    %rax,%rbx
  403845:	b8 00 00 00 00       	mov    $0x0,%eax
  40384a:	e8 08 2e 00 00       	callq  406657 <gsi_get_saved_file>
  40384f:	41 b8 23 01 00 00    	mov    $0x123,%r8d
  403855:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40385a:	48 89 da             	mov    %rbx,%rdx
  40385d:	be 40 86 40 00       	mov    $0x408640,%esi
  403862:	48 89 c7             	mov    %rax,%rdi
  403865:	b8 00 00 00 00       	mov    $0x0,%eax
  40386a:	e8 51 2e 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  40386f:	b8 01 00 00 00       	mov    $0x1,%eax
  403874:	e9 bb 01 00 00       	jmpq   403a34 <gsi_is_recv_json_msg+0x234>
	}

	// Read new message
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_server_read(p_server, (char *)&msg))
  403879:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  40387d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  403881:	48 89 d6             	mov    %rdx,%rsi
  403884:	48 89 c7             	mov    %rax,%rdi
  403887:	e8 dc 21 00 00       	callq  405a68 <gsi_is_network_tcp_server_read>
  40388c:	85 c0                	test   %eax,%eax
  40388e:	74 68                	je     4038f8 <gsi_is_recv_json_msg+0xf8>
	{
		LOG_ERROR("server read on port %d failed", p_server->ui_port);
  403890:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  403894:	8b 58 28             	mov    0x28(%rax),%ebx
  403897:	b8 00 00 00 00       	mov    $0x0,%eax
  40389c:	e8 3b 30 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4038a1:	49 89 c4             	mov    %rax,%r12
  4038a4:	b8 00 00 00 00       	mov    $0x0,%eax
  4038a9:	e8 a9 2d 00 00       	callq  406657 <gsi_get_saved_file>
  4038ae:	41 89 d9             	mov    %ebx,%r9d
  4038b1:	41 b8 2a 01 00 00    	mov    $0x12a,%r8d
  4038b7:	b9 70 85 40 00       	mov    $0x408570,%ecx
  4038bc:	4c 89 e2             	mov    %r12,%rdx
  4038bf:	be b8 87 40 00       	mov    $0x4087b8,%esi
  4038c4:	48 89 c7             	mov    %rax,%rdi
  4038c7:	b8 00 00 00 00       	mov    $0x0,%eax
  4038cc:	e8 ef 2d 00 00       	callq  4066c0 <gsi_is_write_to_log>

		// Check if need to free s_message
		if (NULL != msg.s_message)
  4038d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4038d5:	48 85 c0             	test   %rax,%rax
  4038d8:	74 14                	je     4038ee <gsi_is_recv_json_msg+0xee>
		{
			free(msg.s_message);
  4038da:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4038de:	48 89 c7             	mov    %rax,%rdi
  4038e1:	e8 6a dc ff ff       	callq  401550 <free@plt>
			msg.s_message = NULL;
  4038e6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  4038ed:	00 
		}

		return GSI_JSON_ERROR;
  4038ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4038f3:	e9 3c 01 00 00       	jmpq   403a34 <gsi_is_recv_json_msg+0x234>
	}

	LOG_DEBUG("\nGot JSON:\n%s\n", msg.s_message);
  4038f8:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  4038fc:	b8 00 00 00 00       	mov    $0x0,%eax
  403901:	e8 d6 2f 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403906:	49 89 c4             	mov    %rax,%r12
  403909:	b8 00 00 00 00       	mov    $0x0,%eax
  40390e:	e8 44 2d 00 00       	callq  406657 <gsi_get_saved_file>
  403913:	49 89 d9             	mov    %rbx,%r9
  403916:	41 b8 36 01 00 00    	mov    $0x136,%r8d
  40391c:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403921:	4c 89 e2             	mov    %r12,%rdx
  403924:	be f8 87 40 00       	mov    $0x4087f8,%esi
  403929:	48 89 c7             	mov    %rax,%rdi
  40392c:	b8 00 00 00 00       	mov    $0x0,%eax
  403931:	e8 8a 2d 00 00       	callq  4066c0 <gsi_is_write_to_log>

	// Convert string to json object using JSON-C library functions
	if (GSI_JSON_SUCCESS != gsi_build_parse_string_to_json_object(msg.s_message, &p_json))
  403936:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40393a:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  40393e:	48 89 d6             	mov    %rdx,%rsi
  403941:	48 89 c7             	mov    %rax,%rdi
  403944:	e8 29 0d 00 00       	callq  404672 <gsi_build_parse_string_to_json_object>
  403949:	85 c0                	test   %eax,%eax
  40394b:	74 61                	je     4039ae <gsi_is_recv_json_msg+0x1ae>
	{
		LOG_ERROR("convert string to json object failed");
  40394d:	b8 00 00 00 00       	mov    $0x0,%eax
  403952:	e8 85 2f 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403957:	48 89 c3             	mov    %rax,%rbx
  40395a:	b8 00 00 00 00       	mov    $0x0,%eax
  40395f:	e8 f3 2c 00 00       	callq  406657 <gsi_get_saved_file>
  403964:	41 b8 3b 01 00 00    	mov    $0x13b,%r8d
  40396a:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40396f:	48 89 da             	mov    %rbx,%rdx
  403972:	be 28 88 40 00       	mov    $0x408828,%esi
  403977:	48 89 c7             	mov    %rax,%rdi
  40397a:	b8 00 00 00 00       	mov    $0x0,%eax
  40397f:	e8 3c 2d 00 00       	callq  4066c0 <gsi_is_write_to_log>

		free(msg.s_message);
  403984:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403988:	48 89 c7             	mov    %rax,%rdi
  40398b:	e8 c0 db ff ff       	callq  401550 <free@plt>
		msg.s_message = NULL;
  403990:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  403997:	00 

		json_object_put(p_json);
  403998:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  40399c:	48 89 c7             	mov    %rax,%rdi
  40399f:	e8 6c df ff ff       	callq  401910 <json_object_put@plt>

		return GSI_JSON_ERROR;
  4039a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4039a9:	e9 86 00 00 00       	jmpq   403a34 <gsi_is_recv_json_msg+0x234>
	}

	// Free s_message, finish his job
	free(msg.s_message);
  4039ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4039b2:	48 89 c7             	mov    %rax,%rdi
  4039b5:	e8 96 db ff ff       	callq  401550 <free@plt>
	msg.s_message = NULL;
  4039ba:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  4039c1:	00 

	// Convert json object to json-msg object using JSON-C library functions
	if (GSI_JSON_SUCCESS != gsi_build_parse_json_object_to_json_msg(p_json, p_json_msg))
  4039c2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4039c6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  4039ca:	48 89 d6             	mov    %rdx,%rsi
  4039cd:	48 89 c7             	mov    %rax,%rdi
  4039d0:	e8 5f 0d 00 00       	callq  404734 <gsi_build_parse_json_object_to_json_msg>
  4039d5:	85 c0                	test   %eax,%eax
  4039d7:	74 4a                	je     403a23 <gsi_is_recv_json_msg+0x223>
	{
		LOG_ERROR("convert json object to json-msg failed");
  4039d9:	b8 00 00 00 00       	mov    $0x0,%eax
  4039de:	e8 f9 2e 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4039e3:	48 89 c3             	mov    %rax,%rbx
  4039e6:	b8 00 00 00 00       	mov    $0x0,%eax
  4039eb:	e8 67 2c 00 00       	callq  406657 <gsi_get_saved_file>
  4039f0:	41 b8 4c 01 00 00    	mov    $0x14c,%r8d
  4039f6:	b9 70 85 40 00       	mov    $0x408570,%ecx
  4039fb:	48 89 da             	mov    %rbx,%rdx
  4039fe:	be 70 88 40 00       	mov    $0x408870,%esi
  403a03:	48 89 c7             	mov    %rax,%rdi
  403a06:	b8 00 00 00 00       	mov    $0x0,%eax
  403a0b:	e8 b0 2c 00 00       	callq  4066c0 <gsi_is_write_to_log>

		json_object_put(p_json);
  403a10:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  403a14:	48 89 c7             	mov    %rax,%rdi
  403a17:	e8 f4 de ff ff       	callq  401910 <json_object_put@plt>

		return GSI_JSON_ERROR;
  403a1c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403a21:	eb 11                	jmp    403a34 <gsi_is_recv_json_msg+0x234>
	}

	// Free the json object
	json_object_put(p_json);
  403a23:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  403a27:	48 89 c7             	mov    %rax,%rdi
  403a2a:	e8 e1 de ff ff       	callq  401910 <json_object_put@plt>

	return GSI_JSON_SUCCESS;
  403a2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403a34:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  403a38:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  403a3f:	00 00 
  403a41:	74 05                	je     403a48 <gsi_is_recv_json_msg+0x248>
  403a43:	e8 e8 db ff ff       	callq  401630 <__stack_chk_fail@plt>
  403a48:	48 83 c4 40          	add    $0x40,%rsp
  403a4c:	5b                   	pop    %rbx
  403a4d:	41 5c                	pop    %r12
  403a4f:	5d                   	pop    %rbp
  403a50:	c3                   	retq   

0000000000403a51 <gsi_is_get_next_msg>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to message structure
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR *OR* GSI_JSON_READ_ERROR
#############################################################################*/
enum gsi_is_json_rc gsi_is_get_next_msg(FILE* f_msg_file, struct gsi_json_msg* p_json_msg)
{
  403a51:	55                   	push   %rbp
  403a52:	48 89 e5             	mov    %rsp,%rbp
  403a55:	53                   	push   %rbx
  403a56:	48 81 ec 28 04 00 00 	sub    $0x428,%rsp
  403a5d:	48 89 bd d8 fb ff ff 	mov    %rdi,-0x428(%rbp)
  403a64:	48 89 b5 d0 fb ff ff 	mov    %rsi,-0x430(%rbp)
  403a6b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  403a72:	00 00 
  403a74:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  403a78:	31 c0                	xor    %eax,%eax
	char s_msg_buffer[GSI_IS_BUFFER_SIZE];

	// Check input validation
	if ((NULL == f_msg_file) || (NULL == p_json_msg))
  403a7a:	48 83 bd d8 fb ff ff 	cmpq   $0x0,-0x428(%rbp)
  403a81:	00 
  403a82:	74 0a                	je     403a8e <gsi_is_get_next_msg+0x3d>
  403a84:	48 83 bd d0 fb ff ff 	cmpq   $0x0,-0x430(%rbp)
  403a8b:	00 
  403a8c:	75 41                	jne    403acf <gsi_is_get_next_msg+0x7e>
	{
		LOG_ERROR("invalid arguments!");
  403a8e:	b8 00 00 00 00       	mov    $0x0,%eax
  403a93:	e8 44 2e 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403a98:	48 89 c3             	mov    %rax,%rbx
  403a9b:	b8 00 00 00 00       	mov    $0x0,%eax
  403aa0:	e8 b2 2b 00 00       	callq  406657 <gsi_get_saved_file>
  403aa5:	41 b8 68 01 00 00    	mov    $0x168,%r8d
  403aab:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403ab0:	48 89 da             	mov    %rbx,%rdx
  403ab3:	be 40 86 40 00       	mov    $0x408640,%esi
  403ab8:	48 89 c7             	mov    %rax,%rdi
  403abb:	b8 00 00 00 00       	mov    $0x0,%eax
  403ac0:	e8 fb 2b 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  403ac5:	b8 01 00 00 00       	mov    $0x1,%eax
  403aca:	e9 d7 00 00 00       	jmpq   403ba6 <gsi_is_get_next_msg+0x155>
	}

	// Reset buffer
	memset(s_msg_buffer, 0, sizeof(s_msg_buffer));
  403acf:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  403ad6:	ba 00 04 00 00       	mov    $0x400,%edx
  403adb:	be 00 00 00 00       	mov    $0x0,%esi
  403ae0:	48 89 c7             	mov    %rax,%rdi
  403ae3:	e8 c8 db ff ff       	callq  4016b0 <memset@plt>

	// Get next message from Messages file
	if (NULL == fgets(s_msg_buffer, sizeof(s_msg_buffer), f_msg_file))
  403ae8:	48 8b 95 d8 fb ff ff 	mov    -0x428(%rbp),%rdx
  403aef:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  403af6:	be 00 04 00 00       	mov    $0x400,%esi
  403afb:	48 89 c7             	mov    %rax,%rdi
  403afe:	e8 fd db ff ff       	callq  401700 <fgets@plt>
  403b03:	48 85 c0             	test   %rax,%rax
  403b06:	75 3e                	jne    403b46 <gsi_is_get_next_msg+0xf5>
	{
		LOG_ERROR("couldn't read from messages file");
  403b08:	b8 00 00 00 00       	mov    $0x0,%eax
  403b0d:	e8 ca 2d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403b12:	48 89 c3             	mov    %rax,%rbx
  403b15:	b8 00 00 00 00       	mov    $0x0,%eax
  403b1a:	e8 38 2b 00 00       	callq  406657 <gsi_get_saved_file>
  403b1f:	41 b8 72 01 00 00    	mov    $0x172,%r8d
  403b25:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403b2a:	48 89 da             	mov    %rbx,%rdx
  403b2d:	be b8 88 40 00       	mov    $0x4088b8,%esi
  403b32:	48 89 c7             	mov    %rax,%rdi
  403b35:	b8 00 00 00 00       	mov    $0x0,%eax
  403b3a:	e8 81 2b 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_READ_ERROR;
  403b3f:	b8 04 00 00 00       	mov    $0x4,%eax
  403b44:	eb 60                	jmp    403ba6 <gsi_is_get_next_msg+0x155>
	}

	// Build message according to the current line that read from file
	if (0 != gsi_build_parse_build_msg(s_msg_buffer, p_json_msg))
  403b46:	48 8b 95 d0 fb ff ff 	mov    -0x430(%rbp),%rdx
  403b4d:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  403b54:	48 89 d6             	mov    %rdx,%rsi
  403b57:	48 89 c7             	mov    %rax,%rdi
  403b5a:	e8 65 00 00 00       	callq  403bc4 <gsi_build_parse_build_msg>
  403b5f:	85 c0                	test   %eax,%eax
  403b61:	74 3e                	je     403ba1 <gsi_is_get_next_msg+0x150>
	{
		LOG_ERROR("couldn't build message");
  403b63:	b8 00 00 00 00       	mov    $0x0,%eax
  403b68:	e8 6f 2d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403b6d:	48 89 c3             	mov    %rax,%rbx
  403b70:	b8 00 00 00 00       	mov    $0x0,%eax
  403b75:	e8 dd 2a 00 00       	callq  406657 <gsi_get_saved_file>
  403b7a:	41 b8 79 01 00 00    	mov    $0x179,%r8d
  403b80:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403b85:	48 89 da             	mov    %rbx,%rdx
  403b88:	be 00 89 40 00       	mov    $0x408900,%esi
  403b8d:	48 89 c7             	mov    %rax,%rdi
  403b90:	b8 00 00 00 00       	mov    $0x0,%eax
  403b95:	e8 26 2b 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  403b9a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403b9f:	eb 05                	jmp    403ba6 <gsi_is_get_next_msg+0x155>
	}

	return GSI_JSON_SUCCESS;
  403ba1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403ba6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  403baa:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  403bb1:	00 00 
  403bb3:	74 05                	je     403bba <gsi_is_get_next_msg+0x169>
  403bb5:	e8 76 da ff ff       	callq  401630 <__stack_chk_fail@plt>
  403bba:	48 81 c4 28 04 00 00 	add    $0x428,%rsp
  403bc1:	5b                   	pop    %rbx
  403bc2:	5d                   	pop    %rbp
  403bc3:	c3                   	retq   

0000000000403bc4 <gsi_build_parse_build_msg>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to json-msg object
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR *OR* GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_build_msg(char* s_line, struct gsi_json_msg* p_json_msg)
{
  403bc4:	55                   	push   %rbp
  403bc5:	48 89 e5             	mov    %rsp,%rbp
  403bc8:	53                   	push   %rbx
  403bc9:	48 83 ec 18          	sub    $0x18,%rsp
  403bcd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  403bd1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((NULL == s_line) || (NULL == p_json_msg))
  403bd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403bd9:	48 85 c0             	test   %rax,%rax
  403bdc:	74 07                	je     403be5 <gsi_build_parse_build_msg+0x21>
  403bde:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  403be3:	75 41                	jne    403c26 <gsi_build_parse_build_msg+0x62>
	{
		LOG_ERROR("invalid arguments!");
  403be5:	b8 00 00 00 00       	mov    $0x0,%eax
  403bea:	e8 ed 2c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403bef:	48 89 c3             	mov    %rax,%rbx
  403bf2:	b8 00 00 00 00       	mov    $0x0,%eax
  403bf7:	e8 5b 2a 00 00       	callq  406657 <gsi_get_saved_file>
  403bfc:	41 b8 90 01 00 00    	mov    $0x190,%r8d
  403c02:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403c07:	48 89 da             	mov    %rbx,%rdx
  403c0a:	be 40 86 40 00       	mov    $0x408640,%esi
  403c0f:	48 89 c7             	mov    %rax,%rdi
  403c12:	b8 00 00 00 00       	mov    $0x0,%eax
  403c17:	e8 a4 2a 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  403c1c:	b8 01 00 00 00       	mov    $0x1,%eax
  403c21:	e9 28 01 00 00       	jmpq   403d4e <gsi_build_parse_build_msg+0x18a>
	}

	// Set message type
	p_json_msg->i_msg_type = gsi_build_parse_get_msg_type(&s_line);
  403c26:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  403c2a:	48 89 c7             	mov    %rax,%rdi
  403c2d:	e8 23 01 00 00       	callq  403d55 <gsi_build_parse_get_msg_type>
  403c32:	89 c2                	mov    %eax,%edx
  403c34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403c38:	89 10                	mov    %edx,(%rax)
	if (GSI_JSON_ERROR == p_json_msg->i_msg_type)
  403c3a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403c3e:	8b 00                	mov    (%rax),%eax
  403c40:	83 f8 ff             	cmp    $0xffffffff,%eax
  403c43:	75 41                	jne    403c86 <gsi_build_parse_build_msg+0xc2>
	{
		LOG_ERROR("get message type failed");
  403c45:	b8 00 00 00 00       	mov    $0x0,%eax
  403c4a:	e8 8d 2c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403c4f:	48 89 c3             	mov    %rax,%rbx
  403c52:	b8 00 00 00 00       	mov    $0x0,%eax
  403c57:	e8 fb 29 00 00       	callq  406657 <gsi_get_saved_file>
  403c5c:	41 b8 98 01 00 00    	mov    $0x198,%r8d
  403c62:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403c67:	48 89 da             	mov    %rbx,%rdx
  403c6a:	be 38 89 40 00       	mov    $0x408938,%esi
  403c6f:	48 89 c7             	mov    %rax,%rdi
  403c72:	b8 00 00 00 00       	mov    $0x0,%eax
  403c77:	e8 44 2a 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  403c7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403c81:	e9 c8 00 00 00       	jmpq   403d4e <gsi_build_parse_build_msg+0x18a>
	}

	// Only if Regular message sent
	if (GSI_REGULAR_MSG == p_json_msg->i_msg_type)
  403c86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403c8a:	8b 00                	mov    (%rax),%eax
  403c8c:	83 f8 01             	cmp    $0x1,%eax
  403c8f:	0f 85 b4 00 00 00    	jne    403d49 <gsi_build_parse_build_msg+0x185>
	{
		// Set operation code
		p_json_msg->i_op_code = gsi_build_parse_get_msg_op_code(&s_line);
  403c95:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  403c99:	48 89 c7             	mov    %rax,%rdi
  403c9c:	e8 a3 01 00 00       	callq  403e44 <gsi_build_parse_get_msg_op_code>
  403ca1:	89 c2                	mov    %eax,%edx
  403ca3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403ca7:	89 50 04             	mov    %edx,0x4(%rax)
		if (GSI_JSON_ERROR == p_json_msg->i_op_code)
  403caa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403cae:	8b 40 04             	mov    0x4(%rax),%eax
  403cb1:	83 f8 ff             	cmp    $0xffffffff,%eax
  403cb4:	75 3e                	jne    403cf4 <gsi_build_parse_build_msg+0x130>
		{
			LOG_ERROR("get message op-code failed");
  403cb6:	b8 00 00 00 00       	mov    $0x0,%eax
  403cbb:	e8 1c 2c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403cc0:	48 89 c3             	mov    %rax,%rbx
  403cc3:	b8 00 00 00 00       	mov    $0x0,%eax
  403cc8:	e8 8a 29 00 00       	callq  406657 <gsi_get_saved_file>
  403ccd:	41 b8 a3 01 00 00    	mov    $0x1a3,%r8d
  403cd3:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403cd8:	48 89 da             	mov    %rbx,%rdx
  403cdb:	be 78 89 40 00       	mov    $0x408978,%esi
  403ce0:	48 89 c7             	mov    %rax,%rdi
  403ce3:	b8 00 00 00 00       	mov    $0x0,%eax
  403ce8:	e8 d3 29 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_JSON_ERROR;
  403ced:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403cf2:	eb 5a                	jmp    403d4e <gsi_build_parse_build_msg+0x18a>
		}

		// Set operation code arguments
		if (GSI_JSON_SUCCESS != gsi_build_parse_set_op_code_args(&s_line, p_json_msg))
  403cf4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  403cf8:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  403cfc:	48 89 d6             	mov    %rdx,%rsi
  403cff:	48 89 c7             	mov    %rax,%rdi
  403d02:	e8 b2 04 00 00       	callq  4041b9 <gsi_build_parse_set_op_code_args>
  403d07:	85 c0                	test   %eax,%eax
  403d09:	74 3e                	je     403d49 <gsi_build_parse_build_msg+0x185>
		{
			LOG_ERROR("set op-code-arguments failed");
  403d0b:	b8 00 00 00 00       	mov    $0x0,%eax
  403d10:	e8 c7 2b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403d15:	48 89 c3             	mov    %rax,%rbx
  403d18:	b8 00 00 00 00       	mov    $0x0,%eax
  403d1d:	e8 35 29 00 00       	callq  406657 <gsi_get_saved_file>
  403d22:	41 b8 aa 01 00 00    	mov    $0x1aa,%r8d
  403d28:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403d2d:	48 89 da             	mov    %rbx,%rdx
  403d30:	be b8 89 40 00       	mov    $0x4089b8,%esi
  403d35:	48 89 c7             	mov    %rax,%rdi
  403d38:	b8 00 00 00 00       	mov    $0x0,%eax
  403d3d:	e8 7e 29 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_JSON_ERROR;
  403d42:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403d47:	eb 05                	jmp    403d4e <gsi_build_parse_build_msg+0x18a>
		}
	}

	return GSI_JSON_SUCCESS;
  403d49:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403d4e:	48 83 c4 18          	add    $0x18,%rsp
  403d52:	5b                   	pop    %rbx
  403d53:	5d                   	pop    %rbp
  403d54:	c3                   	retq   

0000000000403d55 <gsi_build_parse_get_msg_type>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - Number that describe the type of the message
	 * 				Failure - GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_get_msg_type(char** s_line)
{
  403d55:	55                   	push   %rbp
  403d56:	48 89 e5             	mov    %rsp,%rbp
  403d59:	53                   	push   %rbx
  403d5a:	48 83 ec 28          	sub    $0x28,%rsp
  403d5e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int i_type = 0;
  403d62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	// Check input validation
	if (NULL == s_line)
  403d69:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  403d6e:	75 41                	jne    403db1 <gsi_build_parse_get_msg_type+0x5c>
	{
		LOG_ERROR("invalid argument!");
  403d70:	b8 00 00 00 00       	mov    $0x0,%eax
  403d75:	e8 62 2b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403d7a:	48 89 c3             	mov    %rax,%rbx
  403d7d:	b8 00 00 00 00       	mov    $0x0,%eax
  403d82:	e8 d0 28 00 00       	callq  406657 <gsi_get_saved_file>
  403d87:	41 b8 c0 01 00 00    	mov    $0x1c0,%r8d
  403d8d:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403d92:	48 89 da             	mov    %rbx,%rdx
  403d95:	be 90 85 40 00       	mov    $0x408590,%esi
  403d9a:	48 89 c7             	mov    %rax,%rdi
  403d9d:	b8 00 00 00 00       	mov    $0x0,%eax
  403da2:	e8 19 29 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  403da7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403dac:	e9 8c 00 00 00       	jmpq   403e3d <gsi_build_parse_get_msg_type+0xe8>
	}

	// Look at the first character in the current line: 'H'/'M'/'#'
	switch(**s_line)
  403db1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403db5:	48 8b 00             	mov    (%rax),%rax
  403db8:	0f b6 00             	movzbl (%rax),%eax
  403dbb:	0f be c0             	movsbl %al,%eax
  403dbe:	83 f8 48             	cmp    $0x48,%eax
  403dc1:	74 0c                	je     403dcf <gsi_build_parse_get_msg_type+0x7a>
  403dc3:	83 f8 4d             	cmp    $0x4d,%eax
  403dc6:	74 10                	je     403dd8 <gsi_build_parse_get_msg_type+0x83>
  403dc8:	83 f8 23             	cmp    $0x23,%eax
  403dcb:	74 14                	je     403de1 <gsi_build_parse_get_msg_type+0x8c>
  403dcd:	eb 1b                	jmp    403dea <gsi_build_parse_get_msg_type+0x95>
	{
	case GSI_IS_HEART_BEAT:
		i_type = GSI_HEARTBEAT_MSG;
  403dcf:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%rbp)
		break;
  403dd6:	eb 50                	jmp    403e28 <gsi_build_parse_get_msg_type+0xd3>
	case GSI_IS_MESSAGE:
		i_type = GSI_REGULAR_MSG;
  403dd8:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
		break;
  403ddf:	eb 47                	jmp    403e28 <gsi_build_parse_get_msg_type+0xd3>
	case GSI_IS_COMMENT:
		i_type = GSI_COMMENT;
  403de1:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%rbp)
		break;
  403de8:	eb 3e                	jmp    403e28 <gsi_build_parse_get_msg_type+0xd3>
	default:
		LOG_ERROR("classified message failed");
  403dea:	b8 00 00 00 00       	mov    $0x0,%eax
  403def:	e8 e8 2a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403df4:	48 89 c3             	mov    %rax,%rbx
  403df7:	b8 00 00 00 00       	mov    $0x0,%eax
  403dfc:	e8 56 28 00 00       	callq  406657 <gsi_get_saved_file>
  403e01:	41 b8 d1 01 00 00    	mov    $0x1d1,%r8d
  403e07:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403e0c:	48 89 da             	mov    %rbx,%rdx
  403e0f:	be f8 89 40 00       	mov    $0x4089f8,%esi
  403e14:	48 89 c7             	mov    %rax,%rdi
  403e17:	b8 00 00 00 00       	mov    $0x0,%eax
  403e1c:	e8 9f 28 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  403e21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403e26:	eb 15                	jmp    403e3d <gsi_build_parse_get_msg_type+0xe8>
	}

	// Move forward the line pointer
	++(*s_line);
  403e28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403e2c:	48 8b 00             	mov    (%rax),%rax
  403e2f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  403e33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403e37:	48 89 10             	mov    %rdx,(%rax)

	return i_type;
  403e3a:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  403e3d:	48 83 c4 28          	add    $0x28,%rsp
  403e41:	5b                   	pop    %rbx
  403e42:	5d                   	pop    %rbp
  403e43:	c3                   	retq   

0000000000403e44 <gsi_build_parse_get_msg_op_code>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - Number that describe the operation-code
	 * 				Failure - GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_get_msg_op_code(char** s_line)
{
  403e44:	55                   	push   %rbp
  403e45:	48 89 e5             	mov    %rsp,%rbp
  403e48:	53                   	push   %rbx
  403e49:	48 83 ec 28          	sub    $0x28,%rsp
  403e4d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int i_op_code = 0;
  403e51:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	// Check input validation
	if (NULL == s_line)
  403e58:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  403e5d:	75 41                	jne    403ea0 <gsi_build_parse_get_msg_op_code+0x5c>
	{
		LOG_ERROR("invalid argument!");
  403e5f:	b8 00 00 00 00       	mov    $0x0,%eax
  403e64:	e8 73 2a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403e69:	48 89 c3             	mov    %rax,%rbx
  403e6c:	b8 00 00 00 00       	mov    $0x0,%eax
  403e71:	e8 e1 27 00 00       	callq  406657 <gsi_get_saved_file>
  403e76:	41 b8 e9 01 00 00    	mov    $0x1e9,%r8d
  403e7c:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403e81:	48 89 da             	mov    %rbx,%rdx
  403e84:	be 90 85 40 00       	mov    $0x408590,%esi
  403e89:	48 89 c7             	mov    %rax,%rdi
  403e8c:	b8 00 00 00 00       	mov    $0x0,%eax
  403e91:	e8 2a 28 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  403e96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403e9b:	e9 6f 01 00 00       	jmpq   40400f <gsi_build_parse_get_msg_op_code+0x1cb>
	}

	// Skip the ':' at the beginning of the s_line
	++(*s_line);
  403ea0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403ea4:	48 8b 00             	mov    (%rax),%rax
  403ea7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  403eab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403eaf:	48 89 10             	mov    %rdx,(%rax)

	// Decode operation-code from s_line
	if (0 == strncmp(*s_line, GSI_IS_READ_FILE_BY_ID, strlen(GSI_IS_READ_FILE_BY_ID)))
  403eb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403eb6:	48 8b 00             	mov    (%rax),%rax
  403eb9:	ba 04 00 00 00       	mov    $0x4,%edx
  403ebe:	be 33 8a 40 00       	mov    $0x408a33,%esi
  403ec3:	48 89 c7             	mov    %rax,%rdi
  403ec6:	e8 b5 d6 ff ff       	callq  401580 <strncmp@plt>
  403ecb:	85 c0                	test   %eax,%eax
  403ecd:	75 0c                	jne    403edb <gsi_build_parse_get_msg_op_code+0x97>
	{
		i_op_code = GSI_READ_FILE_BY_ID;
  403ecf:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%rbp)
  403ed6:	e9 05 01 00 00       	jmpq   403fe0 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_READ_STR, strlen(GSI_IS_READ_STR)))
  403edb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403edf:	48 8b 00             	mov    (%rax),%rax
  403ee2:	ba 02 00 00 00       	mov    $0x2,%edx
  403ee7:	be 38 8a 40 00       	mov    $0x408a38,%esi
  403eec:	48 89 c7             	mov    %rax,%rdi
  403eef:	e8 8c d6 ff ff       	callq  401580 <strncmp@plt>
  403ef4:	85 c0                	test   %eax,%eax
  403ef6:	75 0c                	jne    403f04 <gsi_build_parse_get_msg_op_code+0xc0>
	{
		i_op_code = GSI_READ_STR;
  403ef8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  403eff:	e9 dc 00 00 00       	jmpq   403fe0 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_WRITE_STR, strlen(GSI_IS_WRITE_STR)))
  403f04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403f08:	48 8b 00             	mov    (%rax),%rax
  403f0b:	ba 02 00 00 00       	mov    $0x2,%edx
  403f10:	be 3b 8a 40 00       	mov    $0x408a3b,%esi
  403f15:	48 89 c7             	mov    %rax,%rdi
  403f18:	e8 63 d6 ff ff       	callq  401580 <strncmp@plt>
  403f1d:	85 c0                	test   %eax,%eax
  403f1f:	75 0c                	jne    403f2d <gsi_build_parse_get_msg_op_code+0xe9>
	{
		i_op_code = GSI_WRITE_STR;
  403f21:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  403f28:	e9 b3 00 00 00       	jmpq   403fe0 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_READ_FILE, strlen(GSI_IS_READ_FILE)))
  403f2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403f31:	48 8b 00             	mov    (%rax),%rax
  403f34:	ba 02 00 00 00       	mov    $0x2,%edx
  403f39:	be 3e 8a 40 00       	mov    $0x408a3e,%esi
  403f3e:	48 89 c7             	mov    %rax,%rdi
  403f41:	e8 3a d6 ff ff       	callq  401580 <strncmp@plt>
  403f46:	85 c0                	test   %eax,%eax
  403f48:	75 0c                	jne    403f56 <gsi_build_parse_get_msg_op_code+0x112>
	{
		i_op_code = GSI_READ_FILE;
  403f4a:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%rbp)
  403f51:	e9 8a 00 00 00       	jmpq   403fe0 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_WRITE_FILE, strlen(GSI_IS_WRITE_FILE)))
  403f56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403f5a:	48 8b 00             	mov    (%rax),%rax
  403f5d:	ba 02 00 00 00       	mov    $0x2,%edx
  403f62:	be 41 8a 40 00       	mov    $0x408a41,%esi
  403f67:	48 89 c7             	mov    %rax,%rdi
  403f6a:	e8 11 d6 ff ff       	callq  401580 <strncmp@plt>
  403f6f:	85 c0                	test   %eax,%eax
  403f71:	75 09                	jne    403f7c <gsi_build_parse_get_msg_op_code+0x138>
	{
		i_op_code = GSI_WRITE_FILE;
  403f73:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%rbp)
  403f7a:	eb 64                	jmp    403fe0 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_PRINT_LOG, strlen(GSI_IS_PRINT_LOG)))
  403f7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403f80:	48 8b 00             	mov    (%rax),%rax
  403f83:	ba 02 00 00 00       	mov    $0x2,%edx
  403f88:	be 44 8a 40 00       	mov    $0x408a44,%esi
  403f8d:	48 89 c7             	mov    %rax,%rdi
  403f90:	e8 eb d5 ff ff       	callq  401580 <strncmp@plt>
  403f95:	85 c0                	test   %eax,%eax
  403f97:	75 09                	jne    403fa2 <gsi_build_parse_get_msg_op_code+0x15e>
	{
		i_op_code = GSI_PRINT_LOG;
  403f99:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%rbp)
  403fa0:	eb 3e                	jmp    403fe0 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else
	{
		LOG_ERROR("invalid op code");
  403fa2:	b8 00 00 00 00       	mov    $0x0,%eax
  403fa7:	e8 30 29 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  403fac:	48 89 c3             	mov    %rax,%rbx
  403faf:	b8 00 00 00 00       	mov    $0x0,%eax
  403fb4:	e8 9e 26 00 00       	callq  406657 <gsi_get_saved_file>
  403fb9:	41 b8 0b 02 00 00    	mov    $0x20b,%r8d
  403fbf:	b9 70 85 40 00       	mov    $0x408570,%ecx
  403fc4:	48 89 da             	mov    %rbx,%rdx
  403fc7:	be 48 8a 40 00       	mov    $0x408a48,%esi
  403fcc:	48 89 c7             	mov    %rax,%rdi
  403fcf:	b8 00 00 00 00       	mov    $0x0,%eax
  403fd4:	e8 e7 26 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  403fd9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403fde:	eb 2f                	jmp    40400f <gsi_build_parse_get_msg_op_code+0x1cb>
	}

	// Move forward the line pointer
	if (GSI_READ_FILE_BY_ID == i_op_code)
  403fe0:	83 7d ec 05          	cmpl   $0x5,-0x14(%rbp)
  403fe4:	75 14                	jne    403ffa <gsi_build_parse_get_msg_op_code+0x1b6>
	{
		*s_line += strlen(GSI_IS_READ_FILE_BY_ID);
  403fe6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403fea:	48 8b 00             	mov    (%rax),%rax
  403fed:	48 8d 50 04          	lea    0x4(%rax),%rdx
  403ff1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403ff5:	48 89 10             	mov    %rdx,(%rax)
  403ff8:	eb 12                	jmp    40400c <gsi_build_parse_get_msg_op_code+0x1c8>
	}
	else
	{
		*s_line += strlen(GSI_IS_PRINT_LOG);
  403ffa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403ffe:	48 8b 00             	mov    (%rax),%rax
  404001:	48 8d 50 02          	lea    0x2(%rax),%rdx
  404005:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404009:	48 89 10             	mov    %rdx,(%rax)
	}

	return i_op_code;
  40400c:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  40400f:	48 83 c4 28          	add    $0x28,%rsp
  404013:	5b                   	pop    %rbx
  404014:	5d                   	pop    %rbp
  404015:	c3                   	retq   

0000000000404016 <gsi_build_parse_get_msg_index>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - Number that describe the index
	 * 				Failure - GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_get_msg_index(char** s_line)
{
  404016:	55                   	push   %rbp
  404017:	48 89 e5             	mov    %rsp,%rbp
  40401a:	53                   	push   %rbx
  40401b:	48 83 ec 28          	sub    $0x28,%rsp
  40401f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int i_index = 0;
  404023:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	// Check input validation
	if (NULL == s_line)
  40402a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  40402f:	75 3e                	jne    40406f <gsi_build_parse_get_msg_index+0x59>
	{
		LOG_ERROR("invalid argument!");
  404031:	b8 00 00 00 00       	mov    $0x0,%eax
  404036:	e8 a1 28 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40403b:	48 89 c3             	mov    %rax,%rbx
  40403e:	b8 00 00 00 00       	mov    $0x0,%eax
  404043:	e8 0f 26 00 00       	callq  406657 <gsi_get_saved_file>
  404048:	41 b8 2a 02 00 00    	mov    $0x22a,%r8d
  40404e:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404053:	48 89 da             	mov    %rbx,%rdx
  404056:	be 90 85 40 00       	mov    $0x408590,%esi
  40405b:	48 89 c7             	mov    %rax,%rdi
  40405e:	b8 00 00 00 00       	mov    $0x0,%eax
  404063:	e8 58 26 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  404068:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40406d:	eb 33                	jmp    4040a2 <gsi_build_parse_get_msg_index+0x8c>
	}

	// Skip the ':' at the beginning of the s_line
	++(*s_line);
  40406f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404073:	48 8b 00             	mov    (%rax),%rax
  404076:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40407a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40407e:	48 89 10             	mov    %rdx,(%rax)

	// Extract the index from the s_line, stops at ' '
	i_index = strtol(*s_line, s_line, 10);
  404081:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404085:	48 8b 00             	mov    (%rax),%rax
  404088:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  40408c:	ba 0a 00 00 00       	mov    $0xa,%edx
  404091:	48 89 ce             	mov    %rcx,%rsi
  404094:	48 89 c7             	mov    %rax,%rdi
  404097:	e8 d4 d6 ff ff       	callq  401770 <strtol@plt>
  40409c:	89 45 ec             	mov    %eax,-0x14(%rbp)

	return i_index;
  40409f:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  4040a2:	48 83 c4 28          	add    $0x28,%rsp
  4040a6:	5b                   	pop    %rbx
  4040a7:	5d                   	pop    %rbp
  4040a8:	c3                   	retq   

00000000004040a9 <gsi_build_parse_get_msg_len>:
	 * Parameter:   [in] char* s_msg - message
	 * Return:		Success - message's length
	 * 				Failure - GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_get_msg_len(char* s_msg)
{
  4040a9:	55                   	push   %rbp
  4040aa:	48 89 e5             	mov    %rsp,%rbp
  4040ad:	53                   	push   %rbx
  4040ae:	48 83 ec 18          	sub    $0x18,%rsp
  4040b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == s_msg)
  4040b6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4040bb:	75 3e                	jne    4040fb <gsi_build_parse_get_msg_len+0x52>
	{
		LOG_ERROR("invalid argument!");
  4040bd:	b8 00 00 00 00       	mov    $0x0,%eax
  4040c2:	e8 15 28 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4040c7:	48 89 c3             	mov    %rax,%rbx
  4040ca:	b8 00 00 00 00       	mov    $0x0,%eax
  4040cf:	e8 83 25 00 00       	callq  406657 <gsi_get_saved_file>
  4040d4:	41 b8 43 02 00 00    	mov    $0x243,%r8d
  4040da:	b9 70 85 40 00       	mov    $0x408570,%ecx
  4040df:	48 89 da             	mov    %rbx,%rdx
  4040e2:	be 90 85 40 00       	mov    $0x408590,%esi
  4040e7:	48 89 c7             	mov    %rax,%rdi
  4040ea:	b8 00 00 00 00       	mov    $0x0,%eax
  4040ef:	e8 cc 25 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  4040f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4040f9:	eb 0c                	jmp    404107 <gsi_build_parse_get_msg_len+0x5e>
	}

	return strlen(s_msg);
  4040fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4040ff:	48 89 c7             	mov    %rax,%rdi
  404102:	e8 19 d5 ff ff       	callq  401620 <strlen@plt>
}
  404107:	48 83 c4 18          	add    $0x18,%rsp
  40410b:	5b                   	pop    %rbx
  40410c:	5d                   	pop    %rbp
  40410d:	c3                   	retq   

000000000040410e <gsi_build_parse_get_msg_content>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - pointer to data
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_get_msg_content(char** s_line)
{
  40410e:	55                   	push   %rbp
  40410f:	48 89 e5             	mov    %rsp,%rbp
  404112:	53                   	push   %rbx
  404113:	48 83 ec 18          	sub    $0x18,%rsp
  404117:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == s_line)
  40411b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  404120:	75 50                	jne    404172 <gsi_build_parse_get_msg_content+0x64>
	{
		LOG_ERROR("invalid argument!");
  404122:	b8 00 00 00 00       	mov    $0x0,%eax
  404127:	e8 b0 27 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40412c:	48 89 c3             	mov    %rax,%rbx
  40412f:	b8 00 00 00 00       	mov    $0x0,%eax
  404134:	e8 1e 25 00 00       	callq  406657 <gsi_get_saved_file>
  404139:	41 b8 56 02 00 00    	mov    $0x256,%r8d
  40413f:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404144:	48 89 da             	mov    %rbx,%rdx
  404147:	be 90 85 40 00       	mov    $0x408590,%esi
  40414c:	48 89 c7             	mov    %rax,%rdi
  40414f:	b8 00 00 00 00       	mov    $0x0,%eax
  404154:	e8 67 25 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  404159:	b8 00 00 00 00       	mov    $0x0,%eax
  40415e:	eb 52                	jmp    4041b2 <gsi_build_parse_get_msg_content+0xa4>
	}

	// Skip the white spaces at the beginning of the s_line
	while (('\0' != **s_line) && (isspace(**s_line)))
	{
		++(*s_line);
  404160:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404164:	48 8b 00             	mov    (%rax),%rax
  404167:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40416b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40416f:	48 89 10             	mov    %rdx,(%rax)
		LOG_ERROR("invalid argument!");
		return NULL;
	}

	// Skip the white spaces at the beginning of the s_line
	while (('\0' != **s_line) && (isspace(**s_line)))
  404172:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404176:	48 8b 00             	mov    (%rax),%rax
  404179:	0f b6 00             	movzbl (%rax),%eax
  40417c:	84 c0                	test   %al,%al
  40417e:	74 2b                	je     4041ab <gsi_build_parse_get_msg_content+0x9d>
  404180:	e8 ab d7 ff ff       	callq  401930 <__ctype_b_loc@plt>
  404185:	48 8b 10             	mov    (%rax),%rdx
  404188:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40418c:	48 8b 00             	mov    (%rax),%rax
  40418f:	0f b6 00             	movzbl (%rax),%eax
  404192:	48 0f be c0          	movsbq %al,%rax
  404196:	48 01 c0             	add    %rax,%rax
  404199:	48 01 d0             	add    %rdx,%rax
  40419c:	0f b7 00             	movzwl (%rax),%eax
  40419f:	0f b7 c0             	movzwl %ax,%eax
  4041a2:	25 00 20 00 00       	and    $0x2000,%eax
  4041a7:	85 c0                	test   %eax,%eax
  4041a9:	75 b5                	jne    404160 <gsi_build_parse_get_msg_content+0x52>
	{
		++(*s_line);
	}

	return *s_line;
  4041ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4041af:	48 8b 00             	mov    (%rax),%rax
}
  4041b2:	48 83 c4 18          	add    $0x18,%rsp
  4041b6:	5b                   	pop    %rbx
  4041b7:	5d                   	pop    %rbp
  4041b8:	c3                   	retq   

00000000004041b9 <gsi_build_parse_set_op_code_args>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to json-msg object
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
static int gsi_build_parse_set_op_code_args(char** s_line, struct gsi_json_msg* p_json_msg)
{
  4041b9:	55                   	push   %rbp
  4041ba:	48 89 e5             	mov    %rsp,%rbp
  4041bd:	53                   	push   %rbx
  4041be:	48 83 ec 18          	sub    $0x18,%rsp
  4041c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4041c6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((NULL == s_line) || (NULL == p_json_msg))
  4041ca:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4041cf:	74 07                	je     4041d8 <gsi_build_parse_set_op_code_args+0x1f>
  4041d1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  4041d6:	75 41                	jne    404219 <gsi_build_parse_set_op_code_args+0x60>
	{
		LOG_ERROR("invalid arguments!");
  4041d8:	b8 00 00 00 00       	mov    $0x0,%eax
  4041dd:	e8 fa 26 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4041e2:	48 89 c3             	mov    %rax,%rbx
  4041e5:	b8 00 00 00 00       	mov    $0x0,%eax
  4041ea:	e8 68 24 00 00       	callq  406657 <gsi_get_saved_file>
  4041ef:	41 b8 71 02 00 00    	mov    $0x271,%r8d
  4041f5:	b9 70 85 40 00       	mov    $0x408570,%ecx
  4041fa:	48 89 da             	mov    %rbx,%rdx
  4041fd:	be 40 86 40 00       	mov    $0x408640,%esi
  404202:	48 89 c7             	mov    %rax,%rdi
  404205:	b8 00 00 00 00       	mov    $0x0,%eax
  40420a:	e8 b1 24 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  40420f:	b8 01 00 00 00       	mov    $0x1,%eax
  404214:	e9 ee 01 00 00       	jmpq   404407 <gsi_build_parse_set_op_code_args+0x24e>
	}

	switch(p_json_msg->i_op_code)
  404219:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40421d:	8b 40 04             	mov    0x4(%rax),%eax
  404220:	83 f8 05             	cmp    $0x5,%eax
  404223:	0f 87 94 01 00 00    	ja     4043bd <gsi_build_parse_set_op_code_args+0x204>
  404229:	89 c0                	mov    %eax,%eax
  40422b:	48 8b 04 c5 b8 8a 40 	mov    0x408ab8(,%rax,8),%rax
  404232:	00 
  404233:	ff e0                	jmpq   *%rax
	{
		case GSI_READ_STR:
			// Get index
			p_json_msg->i_index = gsi_build_parse_get_msg_index(s_line);
  404235:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404239:	48 89 c7             	mov    %rax,%rdi
  40423c:	e8 d5 fd ff ff       	callq  404016 <gsi_build_parse_get_msg_index>
  404241:	89 c2                	mov    %eax,%edx
  404243:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404247:	89 50 0c             	mov    %edx,0xc(%rax)
			break;
  40424a:	e9 b3 01 00 00       	jmpq   404402 <gsi_build_parse_set_op_code_args+0x249>

		case GSI_WRITE_STR:
			// Get index + length
			p_json_msg->i_index    = gsi_build_parse_get_msg_index(s_line);
  40424f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404253:	48 89 c7             	mov    %rax,%rdi
  404256:	e8 bb fd ff ff       	callq  404016 <gsi_build_parse_get_msg_index>
  40425b:	89 c2                	mov    %eax,%edx
  40425d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404261:	89 50 0c             	mov    %edx,0xc(%rax)
			p_json_msg->i_data_len = gsi_build_parse_get_msg_len(*s_line);
  404264:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404268:	48 8b 00             	mov    (%rax),%rax
  40426b:	48 89 c7             	mov    %rax,%rdi
  40426e:	e8 36 fe ff ff       	callq  4040a9 <gsi_build_parse_get_msg_len>
  404273:	89 c2                	mov    %eax,%edx
  404275:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404279:	89 50 10             	mov    %edx,0x10(%rax)

			// Duplicate message content
			p_json_msg->s_data  = gsi_build_parse_strdup(gsi_build_parse_get_msg_content(s_line));
  40427c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404280:	48 89 c7             	mov    %rax,%rdi
  404283:	e8 86 fe ff ff       	callq  40410e <gsi_build_parse_get_msg_content>
  404288:	48 89 c7             	mov    %rax,%rdi
  40428b:	e8 f6 09 00 00       	callq  404c86 <gsi_build_parse_strdup>
  404290:	48 89 c2             	mov    %rax,%rdx
  404293:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404297:	48 89 50 20          	mov    %rdx,0x20(%rax)
			if (NULL == p_json_msg->s_data)
  40429b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40429f:	48 8b 40 20          	mov    0x20(%rax),%rax
  4042a3:	48 85 c0             	test   %rax,%rax
  4042a6:	0f 85 4f 01 00 00    	jne    4043fb <gsi_build_parse_set_op_code_args+0x242>
			{
				return GSI_JSON_ERROR;
  4042ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4042b1:	e9 51 01 00 00       	jmpq   404407 <gsi_build_parse_set_op_code_args+0x24e>
			break;

		case GSI_READ_FILE:
		case GSI_PRINT_LOG:
			// Get file length
			p_json_msg->i_file_len = gsi_build_parse_get_msg_len(*s_line);
  4042b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4042ba:	48 8b 00             	mov    (%rax),%rax
  4042bd:	48 89 c7             	mov    %rax,%rdi
  4042c0:	e8 e4 fd ff ff       	callq  4040a9 <gsi_build_parse_get_msg_len>
  4042c5:	89 c2                	mov    %eax,%edx
  4042c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4042cb:	89 50 14             	mov    %edx,0x14(%rax)

			// Duplicate file name
			p_json_msg->s_file_name = gsi_build_parse_strdup(gsi_build_parse_get_file_name(s_line));
  4042ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4042d2:	48 89 c7             	mov    %rax,%rdi
  4042d5:	e8 7b 08 00 00       	callq  404b55 <gsi_build_parse_get_file_name>
  4042da:	48 89 c7             	mov    %rax,%rdi
  4042dd:	e8 a4 09 00 00       	callq  404c86 <gsi_build_parse_strdup>
  4042e2:	48 89 c2             	mov    %rax,%rdx
  4042e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4042e9:	48 89 50 18          	mov    %rdx,0x18(%rax)
			if (NULL == p_json_msg->s_file_name)
  4042ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4042f1:	48 8b 40 18          	mov    0x18(%rax),%rax
  4042f5:	48 85 c0             	test   %rax,%rax
  4042f8:	0f 85 00 01 00 00    	jne    4043fe <gsi_build_parse_set_op_code_args+0x245>
			{
				return GSI_JSON_ERROR;
  4042fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  404303:	e9 ff 00 00 00       	jmpq   404407 <gsi_build_parse_set_op_code_args+0x24e>
			break;

		case GSI_WRITE_FILE:
		case GSI_READ_FILE_BY_ID:
			// Get file length
			p_json_msg->i_file_len = gsi_build_parse_get_msg_len(*s_line);
  404308:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40430c:	48 8b 00             	mov    (%rax),%rax
  40430f:	48 89 c7             	mov    %rax,%rdi
  404312:	e8 92 fd ff ff       	callq  4040a9 <gsi_build_parse_get_msg_len>
  404317:	89 c2                	mov    %eax,%edx
  404319:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40431d:	89 50 14             	mov    %edx,0x14(%rax)

			// Duplicate file name
			p_json_msg->s_file_name = gsi_build_parse_strdup(gsi_build_parse_get_file_name(s_line));
  404320:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404324:	48 89 c7             	mov    %rax,%rdi
  404327:	e8 29 08 00 00       	callq  404b55 <gsi_build_parse_get_file_name>
  40432c:	48 89 c7             	mov    %rax,%rdi
  40432f:	e8 52 09 00 00       	callq  404c86 <gsi_build_parse_strdup>
  404334:	48 89 c2             	mov    %rax,%rdx
  404337:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40433b:	48 89 50 18          	mov    %rdx,0x18(%rax)
			if (NULL == p_json_msg->s_file_name)
  40433f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404343:	48 8b 40 18          	mov    0x18(%rax),%rax
  404347:	48 85 c0             	test   %rax,%rax
  40434a:	75 0a                	jne    404356 <gsi_build_parse_set_op_code_args+0x19d>
			{
				return GSI_JSON_ERROR;
  40434c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  404351:	e9 b1 00 00 00       	jmpq   404407 <gsi_build_parse_set_op_code_args+0x24e>
			}

			// Data length
			p_json_msg->i_data_len = gsi_build_parse_get_msg_len(*s_line);
  404356:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40435a:	48 8b 00             	mov    (%rax),%rax
  40435d:	48 89 c7             	mov    %rax,%rdi
  404360:	e8 44 fd ff ff       	callq  4040a9 <gsi_build_parse_get_msg_len>
  404365:	89 c2                	mov    %eax,%edx
  404367:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40436b:	89 50 10             	mov    %edx,0x10(%rax)

			// Allocate memory for s_data
			p_json_msg->s_data = gsi_build_parse_strdup(gsi_build_parse_get_msg_content(s_line));
  40436e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404372:	48 89 c7             	mov    %rax,%rdi
  404375:	e8 94 fd ff ff       	callq  40410e <gsi_build_parse_get_msg_content>
  40437a:	48 89 c7             	mov    %rax,%rdi
  40437d:	e8 04 09 00 00       	callq  404c86 <gsi_build_parse_strdup>
  404382:	48 89 c2             	mov    %rax,%rdx
  404385:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404389:	48 89 50 20          	mov    %rdx,0x20(%rax)
			if (NULL == p_json_msg->s_data)
  40438d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404391:	48 8b 40 20          	mov    0x20(%rax),%rax
  404395:	48 85 c0             	test   %rax,%rax
  404398:	75 67                	jne    404401 <gsi_build_parse_set_op_code_args+0x248>
			{
				free(p_json_msg->s_file_name);
  40439a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40439e:	48 8b 40 18          	mov    0x18(%rax),%rax
  4043a2:	48 89 c7             	mov    %rax,%rdi
  4043a5:	e8 a6 d1 ff ff       	callq  401550 <free@plt>
				p_json_msg->s_file_name = NULL;
  4043aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4043ae:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  4043b5:	00 

				return GSI_JSON_ERROR;
  4043b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4043bb:	eb 4a                	jmp    404407 <gsi_build_parse_set_op_code_args+0x24e>
			}

			break;

		default:
			LOG_ERROR("invalid operation code");
  4043bd:	b8 00 00 00 00       	mov    $0x0,%eax
  4043c2:	e8 15 25 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4043c7:	48 89 c3             	mov    %rax,%rbx
  4043ca:	b8 00 00 00 00       	mov    $0x0,%eax
  4043cf:	e8 83 22 00 00       	callq  406657 <gsi_get_saved_file>
  4043d4:	41 b8 b4 02 00 00    	mov    $0x2b4,%r8d
  4043da:	b9 70 85 40 00       	mov    $0x408570,%ecx
  4043df:	48 89 da             	mov    %rbx,%rdx
  4043e2:	be 80 8a 40 00       	mov    $0x408a80,%esi
  4043e7:	48 89 c7             	mov    %rax,%rdi
  4043ea:	b8 00 00 00 00       	mov    $0x0,%eax
  4043ef:	e8 cc 22 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_JSON_ERROR;
  4043f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4043f9:	eb 0c                	jmp    404407 <gsi_build_parse_set_op_code_args+0x24e>
			if (NULL == p_json_msg->s_data)
			{
				return GSI_JSON_ERROR;
			}

			break;
  4043fb:	90                   	nop
  4043fc:	eb 04                	jmp    404402 <gsi_build_parse_set_op_code_args+0x249>
			if (NULL == p_json_msg->s_file_name)
			{
				return GSI_JSON_ERROR;
			}

			break;
  4043fe:	90                   	nop
  4043ff:	eb 01                	jmp    404402 <gsi_build_parse_set_op_code_args+0x249>
				p_json_msg->s_file_name = NULL;

				return GSI_JSON_ERROR;
			}

			break;
  404401:	90                   	nop
		default:
			LOG_ERROR("invalid operation code");
			return GSI_JSON_ERROR;
	}

	return GSI_JSON_SUCCESS;
  404402:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404407:	48 83 c4 18          	add    $0x18,%rsp
  40440b:	5b                   	pop    %rbx
  40440c:	5d                   	pop    %rbp
  40440d:	c3                   	retq   

000000000040440e <gsi_build_parse_json_obj_to_string>:
	 * Parameter:   [in-out] struct json_object *p_json - pointer to json object to use JSON-C library
	 * Return:		Success - char* - string that contatins all the structure in json format
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_json_obj_to_string(struct json_object *p_json, struct gsi_json_msg* p_json_msg)
{
  40440e:	55                   	push   %rbp
  40440f:	48 89 e5             	mov    %rsp,%rbp
  404412:	53                   	push   %rbx
  404413:	48 83 ec 28          	sub    $0x28,%rsp
  404417:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  40441b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int i_ret = 0;
  40441f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	// Check input validation
	if (NULL == p_json_msg)
  404426:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  40442b:	75 41                	jne    40446e <gsi_build_parse_json_obj_to_string+0x60>
	{
		LOG_ERROR("invalid argument!");
  40442d:	b8 00 00 00 00       	mov    $0x0,%eax
  404432:	e8 a5 24 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404437:	48 89 c3             	mov    %rax,%rbx
  40443a:	b8 00 00 00 00       	mov    $0x0,%eax
  40443f:	e8 13 22 00 00       	callq  406657 <gsi_get_saved_file>
  404444:	41 b8 cc 02 00 00    	mov    $0x2cc,%r8d
  40444a:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40444f:	48 89 da             	mov    %rbx,%rdx
  404452:	be 90 85 40 00       	mov    $0x408590,%esi
  404457:	48 89 c7             	mov    %rax,%rdi
  40445a:	b8 00 00 00 00       	mov    $0x0,%eax
  40445f:	e8 5c 22 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  404464:	b8 00 00 00 00       	mov    $0x0,%eax
  404469:	e9 fd 01 00 00       	jmpq   40466b <gsi_build_parse_json_obj_to_string+0x25d>
	}

	// For each filed in structure - add object: <NAME>:<VALUE>
	i_ret += json_object_object_add(p_json, "Message Type",json_object_new_int(p_json_msg->i_msg_type));
  40446e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  404472:	8b 00                	mov    (%rax),%eax
  404474:	89 c7                	mov    %eax,%edi
  404476:	e8 c5 d2 ff ff       	callq  401740 <json_object_new_int@plt>
  40447b:	48 89 c2             	mov    %rax,%rdx
  40447e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404482:	be e8 8a 40 00       	mov    $0x408ae8,%esi
  404487:	48 89 c7             	mov    %rax,%rdi
  40448a:	e8 21 d3 ff ff       	callq  4017b0 <json_object_object_add@plt>
  40448f:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Op-Code", 	   json_object_new_int(p_json_msg->i_op_code));
  404492:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  404496:	8b 40 04             	mov    0x4(%rax),%eax
  404499:	89 c7                	mov    %eax,%edi
  40449b:	e8 a0 d2 ff ff       	callq  401740 <json_object_new_int@plt>
  4044a0:	48 89 c2             	mov    %rax,%rdx
  4044a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4044a7:	be f5 8a 40 00       	mov    $0x408af5,%esi
  4044ac:	48 89 c7             	mov    %rax,%rdi
  4044af:	e8 fc d2 ff ff       	callq  4017b0 <json_object_object_add@plt>
  4044b4:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Op-Str", 	   json_object_new_string(gsi_build_parse_op_code_to_string(p_json_msg->i_op_code)));
  4044b7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4044bb:	8b 40 04             	mov    0x4(%rax),%eax
  4044be:	89 c7                	mov    %eax,%edi
  4044c0:	e8 9a 08 00 00       	callq  404d5f <gsi_build_parse_op_code_to_string>
  4044c5:	48 89 c7             	mov    %rax,%rdi
  4044c8:	e8 03 d1 ff ff       	callq  4015d0 <json_object_new_string@plt>
  4044cd:	48 89 c2             	mov    %rax,%rdx
  4044d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4044d4:	be fd 8a 40 00       	mov    $0x408afd,%esi
  4044d9:	48 89 c7             	mov    %rax,%rdi
  4044dc:	e8 cf d2 ff ff       	callq  4017b0 <json_object_object_add@plt>
  4044e1:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Port", 	   json_object_new_int(p_json_msg->ui_port));
  4044e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4044e8:	8b 40 08             	mov    0x8(%rax),%eax
  4044eb:	89 c7                	mov    %eax,%edi
  4044ed:	e8 4e d2 ff ff       	callq  401740 <json_object_new_int@plt>
  4044f2:	48 89 c2             	mov    %rax,%rdx
  4044f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4044f9:	be 04 8b 40 00       	mov    $0x408b04,%esi
  4044fe:	48 89 c7             	mov    %rax,%rdi
  404501:	e8 aa d2 ff ff       	callq  4017b0 <json_object_object_add@plt>
  404506:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Index",   	   json_object_new_int(p_json_msg->i_index));
  404509:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40450d:	8b 40 0c             	mov    0xc(%rax),%eax
  404510:	89 c7                	mov    %eax,%edi
  404512:	e8 29 d2 ff ff       	callq  401740 <json_object_new_int@plt>
  404517:	48 89 c2             	mov    %rax,%rdx
  40451a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40451e:	be 09 8b 40 00       	mov    $0x408b09,%esi
  404523:	48 89 c7             	mov    %rax,%rdi
  404526:	e8 85 d2 ff ff       	callq  4017b0 <json_object_object_add@plt>
  40452b:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Data Length", json_object_new_int(p_json_msg->i_data_len));
  40452e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  404532:	8b 40 10             	mov    0x10(%rax),%eax
  404535:	89 c7                	mov    %eax,%edi
  404537:	e8 04 d2 ff ff       	callq  401740 <json_object_new_int@plt>
  40453c:	48 89 c2             	mov    %rax,%rdx
  40453f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404543:	be 0f 8b 40 00       	mov    $0x408b0f,%esi
  404548:	48 89 c7             	mov    %rax,%rdi
  40454b:	e8 60 d2 ff ff       	callq  4017b0 <json_object_object_add@plt>
  404550:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "File Length", json_object_new_int(p_json_msg->i_file_len));
  404553:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  404557:	8b 40 14             	mov    0x14(%rax),%eax
  40455a:	89 c7                	mov    %eax,%edi
  40455c:	e8 df d1 ff ff       	callq  401740 <json_object_new_int@plt>
  404561:	48 89 c2             	mov    %rax,%rdx
  404564:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404568:	be 1b 8b 40 00       	mov    $0x408b1b,%esi
  40456d:	48 89 c7             	mov    %rax,%rdi
  404570:	e8 3b d2 ff ff       	callq  4017b0 <json_object_object_add@plt>
  404575:	01 45 ec             	add    %eax,-0x14(%rbp)

	// Check if has file name or NULL
	if (NULL != p_json_msg->s_file_name)
  404578:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40457c:	48 8b 40 18          	mov    0x18(%rax),%rax
  404580:	48 85 c0             	test   %rax,%rax
  404583:	74 29                	je     4045ae <gsi_build_parse_json_obj_to_string+0x1a0>
	{
		i_ret += json_object_object_add(p_json, "File Name", json_object_new_string(p_json_msg->s_file_name));
  404585:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  404589:	48 8b 40 18          	mov    0x18(%rax),%rax
  40458d:	48 89 c7             	mov    %rax,%rdi
  404590:	e8 3b d0 ff ff       	callq  4015d0 <json_object_new_string@plt>
  404595:	48 89 c2             	mov    %rax,%rdx
  404598:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40459c:	be 27 8b 40 00       	mov    $0x408b27,%esi
  4045a1:	48 89 c7             	mov    %rax,%rdi
  4045a4:	e8 07 d2 ff ff       	callq  4017b0 <json_object_object_add@plt>
  4045a9:	01 45 ec             	add    %eax,-0x14(%rbp)
  4045ac:	eb 19                	jmp    4045c7 <gsi_build_parse_json_obj_to_string+0x1b9>
	}
	else
	{
		i_ret += json_object_object_add(p_json, "File Name", NULL);
  4045ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4045b2:	ba 00 00 00 00       	mov    $0x0,%edx
  4045b7:	be 27 8b 40 00       	mov    $0x408b27,%esi
  4045bc:	48 89 c7             	mov    %rax,%rdi
  4045bf:	e8 ec d1 ff ff       	callq  4017b0 <json_object_object_add@plt>
  4045c4:	01 45 ec             	add    %eax,-0x14(%rbp)
	}

	// Check if has data or NULL
	if (NULL != p_json_msg->s_data)
  4045c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4045cb:	48 8b 40 20          	mov    0x20(%rax),%rax
  4045cf:	48 85 c0             	test   %rax,%rax
  4045d2:	74 29                	je     4045fd <gsi_build_parse_json_obj_to_string+0x1ef>
	{
		i_ret += json_object_object_add(p_json, "Data", json_object_new_string(p_json_msg->s_data));
  4045d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4045d8:	48 8b 40 20          	mov    0x20(%rax),%rax
  4045dc:	48 89 c7             	mov    %rax,%rdi
  4045df:	e8 ec cf ff ff       	callq  4015d0 <json_object_new_string@plt>
  4045e4:	48 89 c2             	mov    %rax,%rdx
  4045e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4045eb:	be 31 8b 40 00       	mov    $0x408b31,%esi
  4045f0:	48 89 c7             	mov    %rax,%rdi
  4045f3:	e8 b8 d1 ff ff       	callq  4017b0 <json_object_object_add@plt>
  4045f8:	01 45 ec             	add    %eax,-0x14(%rbp)
  4045fb:	eb 19                	jmp    404616 <gsi_build_parse_json_obj_to_string+0x208>
	}
	else
	{
		i_ret += json_object_object_add(p_json, "Data", NULL);
  4045fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404601:	ba 00 00 00 00       	mov    $0x0,%edx
  404606:	be 31 8b 40 00       	mov    $0x408b31,%esi
  40460b:	48 89 c7             	mov    %rax,%rdi
  40460e:	e8 9d d1 ff ff       	callq  4017b0 <json_object_object_add@plt>
  404613:	01 45 ec             	add    %eax,-0x14(%rbp)
	}

	// Check status of adding all objects
	if (0 != i_ret)
  404616:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  40461a:	74 3e                	je     40465a <gsi_build_parse_json_obj_to_string+0x24c>
	{
		LOG_ERROR("json object add failed");
  40461c:	b8 00 00 00 00       	mov    $0x0,%eax
  404621:	e8 b6 22 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404626:	48 89 c3             	mov    %rax,%rbx
  404629:	b8 00 00 00 00       	mov    $0x0,%eax
  40462e:	e8 24 20 00 00       	callq  406657 <gsi_get_saved_file>
  404633:	41 b8 f0 02 00 00    	mov    $0x2f0,%r8d
  404639:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40463e:	48 89 da             	mov    %rbx,%rdx
  404641:	be 38 8b 40 00       	mov    $0x408b38,%esi
  404646:	48 89 c7             	mov    %rax,%rdi
  404649:	b8 00 00 00 00       	mov    $0x0,%eax
  40464e:	e8 6d 20 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  404653:	b8 00 00 00 00       	mov    $0x0,%eax
  404658:	eb 11                	jmp    40466b <gsi_build_parse_json_obj_to_string+0x25d>
	}

	// Converting the json object to string format, using JSON-C library function
	return (char *)json_object_to_json_string_ext(p_json, JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_SPACED);
  40465a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40465e:	be 03 00 00 00       	mov    $0x3,%esi
  404663:	48 89 c7             	mov    %rax,%rdi
  404666:	e8 85 d0 ff ff       	callq  4016f0 <json_object_to_json_string_ext@plt>
}
  40466b:	48 83 c4 28          	add    $0x28,%rsp
  40466f:	5b                   	pop    %rbx
  404670:	5d                   	pop    %rbp
  404671:	c3                   	retq   

0000000000404672 <gsi_build_parse_string_to_json_object>:
	 * Parameter:   [out] struct json_object** p_json - pointer to fill
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR *OR* GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_string_to_json_object(char *s_data, struct json_object** p_json)
{
  404672:	55                   	push   %rbp
  404673:	48 89 e5             	mov    %rsp,%rbp
  404676:	53                   	push   %rbx
  404677:	48 83 ec 18          	sub    $0x18,%rsp
  40467b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  40467f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if (NULL == s_data)
  404683:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  404688:	75 3e                	jne    4046c8 <gsi_build_parse_string_to_json_object+0x56>
	{
		LOG_ERROR("invalid argument!");
  40468a:	b8 00 00 00 00       	mov    $0x0,%eax
  40468f:	e8 48 22 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404694:	48 89 c3             	mov    %rax,%rbx
  404697:	b8 00 00 00 00       	mov    $0x0,%eax
  40469c:	e8 b6 1f 00 00       	callq  406657 <gsi_get_saved_file>
  4046a1:	41 b8 05 03 00 00    	mov    $0x305,%r8d
  4046a7:	b9 70 85 40 00       	mov    $0x408570,%ecx
  4046ac:	48 89 da             	mov    %rbx,%rdx
  4046af:	be 90 85 40 00       	mov    $0x408590,%esi
  4046b4:	48 89 c7             	mov    %rax,%rdi
  4046b7:	b8 00 00 00 00       	mov    $0x0,%eax
  4046bc:	e8 ff 1f 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  4046c1:	b8 01 00 00 00       	mov    $0x1,%eax
  4046c6:	eb 65                	jmp    40472d <gsi_build_parse_string_to_json_object+0xbb>
	}

	// parse the string to json object
	*p_json = json_tokener_parse(s_data);
  4046c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4046cc:	48 89 c7             	mov    %rax,%rdi
  4046cf:	e8 6c ce ff ff       	callq  401540 <json_tokener_parse@plt>
  4046d4:	48 89 c2             	mov    %rax,%rdx
  4046d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4046db:	48 89 10             	mov    %rdx,(%rax)
	if (NULL == *p_json)
  4046de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4046e2:	48 8b 00             	mov    (%rax),%rax
  4046e5:	48 85 c0             	test   %rax,%rax
  4046e8:	75 3e                	jne    404728 <gsi_build_parse_string_to_json_object+0xb6>
	{
		LOG_ERROR("string to json failed");
  4046ea:	b8 00 00 00 00       	mov    $0x0,%eax
  4046ef:	e8 e8 21 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4046f4:	48 89 c3             	mov    %rax,%rbx
  4046f7:	b8 00 00 00 00       	mov    $0x0,%eax
  4046fc:	e8 56 1f 00 00       	callq  406657 <gsi_get_saved_file>
  404701:	41 b8 0d 03 00 00    	mov    $0x30d,%r8d
  404707:	b9 70 85 40 00       	mov    $0x408570,%ecx
  40470c:	48 89 da             	mov    %rbx,%rdx
  40470f:	be 70 8b 40 00       	mov    $0x408b70,%esi
  404714:	48 89 c7             	mov    %rax,%rdi
  404717:	b8 00 00 00 00       	mov    $0x0,%eax
  40471c:	e8 9f 1f 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  404721:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  404726:	eb 05                	jmp    40472d <gsi_build_parse_string_to_json_object+0xbb>
	}

	return GSI_JSON_SUCCESS;
  404728:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40472d:	48 83 c4 18          	add    $0x18,%rsp
  404731:	5b                   	pop    %rbx
  404732:	5d                   	pop    %rbp
  404733:	c3                   	retq   

0000000000404734 <gsi_build_parse_json_object_to_json_msg>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to fill
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR *OR* GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_json_object_to_json_msg(struct json_object *p_json, struct gsi_json_msg* p_json_msg)
{
  404734:	55                   	push   %rbp
  404735:	48 89 e5             	mov    %rsp,%rbp
  404738:	53                   	push   %rbx
  404739:	48 83 ec 18          	sub    $0x18,%rsp
  40473d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  404741:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((NULL == p_json) || (NULL == p_json_msg))
  404745:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  40474a:	74 07                	je     404753 <gsi_build_parse_json_object_to_json_msg+0x1f>
  40474c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  404751:	75 41                	jne    404794 <gsi_build_parse_json_object_to_json_msg+0x60>
	{
		LOG_ERROR("invalid arguments!");
  404753:	b8 00 00 00 00       	mov    $0x0,%eax
  404758:	e8 7f 21 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40475d:	48 89 c3             	mov    %rax,%rbx
  404760:	b8 00 00 00 00       	mov    $0x0,%eax
  404765:	e8 ed 1e 00 00       	callq  406657 <gsi_get_saved_file>
  40476a:	41 b8 21 03 00 00    	mov    $0x321,%r8d
  404770:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404775:	48 89 da             	mov    %rbx,%rdx
  404778:	be 40 86 40 00       	mov    $0x408640,%esi
  40477d:	48 89 c7             	mov    %rax,%rdi
  404780:	b8 00 00 00 00       	mov    $0x0,%eax
  404785:	e8 36 1f 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  40478a:	b8 01 00 00 00       	mov    $0x1,%eax
  40478f:	e9 bf 00 00 00       	jmpq   404853 <gsi_build_parse_json_object_to_json_msg+0x11f>
	}

	// Initialize p_json_msg fields. using JSON-C library functions
	p_json_msg->i_msg_type = json_object_get_int(json_object_object_get(p_json, "Message Type"));
  404794:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404798:	be e8 8a 40 00       	mov    $0x408ae8,%esi
  40479d:	48 89 c7             	mov    %rax,%rdi
  4047a0:	e8 1b d1 ff ff       	callq  4018c0 <json_object_object_get@plt>
  4047a5:	48 89 c7             	mov    %rax,%rdi
  4047a8:	e8 63 cf ff ff       	callq  401710 <json_object_get_int@plt>
  4047ad:	89 c2                	mov    %eax,%edx
  4047af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4047b3:	89 10                	mov    %edx,(%rax)
	p_json_msg->i_op_code  = json_object_get_int(json_object_object_get(p_json, "Op-Code"));
  4047b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4047b9:	be f5 8a 40 00       	mov    $0x408af5,%esi
  4047be:	48 89 c7             	mov    %rax,%rdi
  4047c1:	e8 fa d0 ff ff       	callq  4018c0 <json_object_object_get@plt>
  4047c6:	48 89 c7             	mov    %rax,%rdi
  4047c9:	e8 42 cf ff ff       	callq  401710 <json_object_get_int@plt>
  4047ce:	89 c2                	mov    %eax,%edx
  4047d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4047d4:	89 50 04             	mov    %edx,0x4(%rax)
	p_json_msg->ui_port    = json_object_get_int(json_object_object_get(p_json, "Port"));
  4047d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4047db:	be 04 8b 40 00       	mov    $0x408b04,%esi
  4047e0:	48 89 c7             	mov    %rax,%rdi
  4047e3:	e8 d8 d0 ff ff       	callq  4018c0 <json_object_object_get@plt>
  4047e8:	48 89 c7             	mov    %rax,%rdi
  4047eb:	e8 20 cf ff ff       	callq  401710 <json_object_get_int@plt>
  4047f0:	89 c2                	mov    %eax,%edx
  4047f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4047f6:	89 50 08             	mov    %edx,0x8(%rax)

	// Initialize relevant fields according to operaion code
	if (GSI_JSON_SUCCESS != gsi_build_parse_handle_op_code(p_json, p_json_msg))
  4047f9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4047fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404801:	48 89 d6             	mov    %rdx,%rsi
  404804:	48 89 c7             	mov    %rax,%rdi
  404807:	e8 4e 00 00 00       	callq  40485a <gsi_build_parse_handle_op_code>
  40480c:	85 c0                	test   %eax,%eax
  40480e:	74 3e                	je     40484e <gsi_build_parse_json_object_to_json_msg+0x11a>
	{
		LOG_ERROR("couldn't handle op code");
  404810:	b8 00 00 00 00       	mov    $0x0,%eax
  404815:	e8 c2 20 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40481a:	48 89 c3             	mov    %rax,%rbx
  40481d:	b8 00 00 00 00       	mov    $0x0,%eax
  404822:	e8 30 1e 00 00       	callq  406657 <gsi_get_saved_file>
  404827:	41 b8 2d 03 00 00    	mov    $0x32d,%r8d
  40482d:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404832:	48 89 da             	mov    %rbx,%rdx
  404835:	be a8 8b 40 00       	mov    $0x408ba8,%esi
  40483a:	48 89 c7             	mov    %rax,%rdi
  40483d:	b8 00 00 00 00       	mov    $0x0,%eax
  404842:	e8 79 1e 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  404847:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40484c:	eb 05                	jmp    404853 <gsi_build_parse_json_object_to_json_msg+0x11f>
	}

	return GSI_JSON_SUCCESS;
  40484e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404853:	48 83 c4 18          	add    $0x18,%rsp
  404857:	5b                   	pop    %rbx
  404858:	5d                   	pop    %rbp
  404859:	c3                   	retq   

000000000040485a <gsi_build_parse_handle_op_code>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to fill
	 * Return: 		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR *OR* GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_handle_op_code(struct json_object *p_json, struct gsi_json_msg* p_json_msg)
{
  40485a:	55                   	push   %rbp
  40485b:	48 89 e5             	mov    %rsp,%rbp
  40485e:	53                   	push   %rbx
  40485f:	48 83 ec 18          	sub    $0x18,%rsp
  404863:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  404867:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if (NULL == p_json_msg)
  40486b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  404870:	75 41                	jne    4048b3 <gsi_build_parse_handle_op_code+0x59>
	{
		LOG_ERROR("invalid argument!");
  404872:	b8 00 00 00 00       	mov    $0x0,%eax
  404877:	e8 60 20 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40487c:	48 89 c3             	mov    %rax,%rbx
  40487f:	b8 00 00 00 00       	mov    $0x0,%eax
  404884:	e8 ce 1d 00 00       	callq  406657 <gsi_get_saved_file>
  404889:	41 b8 41 03 00 00    	mov    $0x341,%r8d
  40488f:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404894:	48 89 da             	mov    %rbx,%rdx
  404897:	be 90 85 40 00       	mov    $0x408590,%esi
  40489c:	48 89 c7             	mov    %rax,%rdi
  40489f:	b8 00 00 00 00       	mov    $0x0,%eax
  4048a4:	e8 17 1e 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  4048a9:	b8 01 00 00 00       	mov    $0x1,%eax
  4048ae:	e9 9b 02 00 00       	jmpq   404b4e <gsi_build_parse_handle_op_code+0x2f4>
	}

	switch (p_json_msg->i_op_code)
  4048b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4048b7:	8b 40 04             	mov    0x4(%rax),%eax
  4048ba:	83 f8 05             	cmp    $0x5,%eax
  4048bd:	0f 87 41 02 00 00    	ja     404b04 <gsi_build_parse_handle_op_code+0x2aa>
  4048c3:	89 c0                	mov    %eax,%eax
  4048c5:	48 8b 04 c5 38 8c 40 	mov    0x408c38(,%rax,8),%rax
  4048cc:	00 
  4048cd:	ff e0                	jmpq   *%rax
	{
		case GSI_READ_STR:
			// Get index
			p_json_msg->i_index = json_object_get_int(json_object_object_get(p_json, "Index"));
  4048cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4048d3:	be 09 8b 40 00       	mov    $0x408b09,%esi
  4048d8:	48 89 c7             	mov    %rax,%rdi
  4048db:	e8 e0 cf ff ff       	callq  4018c0 <json_object_object_get@plt>
  4048e0:	48 89 c7             	mov    %rax,%rdi
  4048e3:	e8 28 ce ff ff       	callq  401710 <json_object_get_int@plt>
  4048e8:	89 c2                	mov    %eax,%edx
  4048ea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4048ee:	89 50 0c             	mov    %edx,0xc(%rax)
			break;
  4048f1:	e9 53 02 00 00       	jmpq   404b49 <gsi_build_parse_handle_op_code+0x2ef>

		case GSI_WRITE_STR:
			// Get index and data length
			p_json_msg->i_index    = json_object_get_int(json_object_object_get(p_json, "Index"));
  4048f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4048fa:	be 09 8b 40 00       	mov    $0x408b09,%esi
  4048ff:	48 89 c7             	mov    %rax,%rdi
  404902:	e8 b9 cf ff ff       	callq  4018c0 <json_object_object_get@plt>
  404907:	48 89 c7             	mov    %rax,%rdi
  40490a:	e8 01 ce ff ff       	callq  401710 <json_object_get_int@plt>
  40490f:	89 c2                	mov    %eax,%edx
  404911:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404915:	89 50 0c             	mov    %edx,0xc(%rax)
			p_json_msg->i_data_len = json_object_get_int(json_object_object_get(p_json, "Data Length"));
  404918:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40491c:	be 0f 8b 40 00       	mov    $0x408b0f,%esi
  404921:	48 89 c7             	mov    %rax,%rdi
  404924:	e8 97 cf ff ff       	callq  4018c0 <json_object_object_get@plt>
  404929:	48 89 c7             	mov    %rax,%rdi
  40492c:	e8 df cd ff ff       	callq  401710 <json_object_get_int@plt>
  404931:	89 c2                	mov    %eax,%edx
  404933:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404937:	89 50 10             	mov    %edx,0x10(%rax)

			// Duplicate the data
			p_json_msg->s_data = gsi_build_parse_strdup(json_object_get_string(json_object_object_get(p_json, "Data")));
  40493a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40493e:	be 31 8b 40 00       	mov    $0x408b31,%esi
  404943:	48 89 c7             	mov    %rax,%rdi
  404946:	e8 75 cf ff ff       	callq  4018c0 <json_object_object_get@plt>
  40494b:	48 89 c7             	mov    %rax,%rdi
  40494e:	e8 bd cc ff ff       	callq  401610 <json_object_get_string@plt>
  404953:	48 89 c7             	mov    %rax,%rdi
  404956:	e8 2b 03 00 00       	callq  404c86 <gsi_build_parse_strdup>
  40495b:	48 89 c2             	mov    %rax,%rdx
  40495e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404962:	48 89 50 20          	mov    %rdx,0x20(%rax)
			if (NULL == p_json_msg->s_data)
  404966:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40496a:	48 8b 40 20          	mov    0x20(%rax),%rax
  40496e:	48 85 c0             	test   %rax,%rax
  404971:	0f 85 cb 01 00 00    	jne    404b42 <gsi_build_parse_handle_op_code+0x2e8>
			{
				return GSI_JSON_ERROR;
  404977:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40497c:	e9 cd 01 00 00       	jmpq   404b4e <gsi_build_parse_handle_op_code+0x2f4>
			break;

		case GSI_READ_FILE:
	    case GSI_PRINT_LOG:
			// Get file name length
			p_json_msg->i_file_len 	= json_object_get_int(json_object_object_get(p_json, "File Length"));
  404981:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404985:	be 1b 8b 40 00       	mov    $0x408b1b,%esi
  40498a:	48 89 c7             	mov    %rax,%rdi
  40498d:	e8 2e cf ff ff       	callq  4018c0 <json_object_object_get@plt>
  404992:	48 89 c7             	mov    %rax,%rdi
  404995:	e8 76 cd ff ff       	callq  401710 <json_object_get_int@plt>
  40499a:	89 c2                	mov    %eax,%edx
  40499c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4049a0:	89 50 14             	mov    %edx,0x14(%rax)

			// Duplicate the file name
			p_json_msg->s_file_name = gsi_build_parse_strdup(json_object_get_string(json_object_object_get(p_json, "File Name")));
  4049a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4049a7:	be 27 8b 40 00       	mov    $0x408b27,%esi
  4049ac:	48 89 c7             	mov    %rax,%rdi
  4049af:	e8 0c cf ff ff       	callq  4018c0 <json_object_object_get@plt>
  4049b4:	48 89 c7             	mov    %rax,%rdi
  4049b7:	e8 54 cc ff ff       	callq  401610 <json_object_get_string@plt>
  4049bc:	48 89 c7             	mov    %rax,%rdi
  4049bf:	e8 c2 02 00 00       	callq  404c86 <gsi_build_parse_strdup>
  4049c4:	48 89 c2             	mov    %rax,%rdx
  4049c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4049cb:	48 89 50 18          	mov    %rdx,0x18(%rax)
			if (NULL == p_json_msg->s_file_name)
  4049cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4049d3:	48 8b 40 18          	mov    0x18(%rax),%rax
  4049d7:	48 85 c0             	test   %rax,%rax
  4049da:	0f 85 65 01 00 00    	jne    404b45 <gsi_build_parse_handle_op_code+0x2eb>
			{
				return GSI_JSON_ERROR;
  4049e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4049e5:	e9 64 01 00 00       	jmpq   404b4e <gsi_build_parse_handle_op_code+0x2f4>

		case GSI_WRITE_FILE:
		case GSI_READ_FILE_BY_ID:

			// Get source file length
			p_json_msg->i_file_len 	= json_object_get_int(json_object_object_get(p_json, "File Length"));
  4049ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4049ee:	be 1b 8b 40 00       	mov    $0x408b1b,%esi
  4049f3:	48 89 c7             	mov    %rax,%rdi
  4049f6:	e8 c5 ce ff ff       	callq  4018c0 <json_object_object_get@plt>
  4049fb:	48 89 c7             	mov    %rax,%rdi
  4049fe:	e8 0d cd ff ff       	callq  401710 <json_object_get_int@plt>
  404a03:	89 c2                	mov    %eax,%edx
  404a05:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404a09:	89 50 14             	mov    %edx,0x14(%rax)

			// Duplicate the source file name
			p_json_msg->s_file_name = gsi_build_parse_strdup(json_object_get_string(json_object_object_get(p_json, "File Name")));
  404a0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404a10:	be 27 8b 40 00       	mov    $0x408b27,%esi
  404a15:	48 89 c7             	mov    %rax,%rdi
  404a18:	e8 a3 ce ff ff       	callq  4018c0 <json_object_object_get@plt>
  404a1d:	48 89 c7             	mov    %rax,%rdi
  404a20:	e8 eb cb ff ff       	callq  401610 <json_object_get_string@plt>
  404a25:	48 89 c7             	mov    %rax,%rdi
  404a28:	e8 59 02 00 00       	callq  404c86 <gsi_build_parse_strdup>
  404a2d:	48 89 c2             	mov    %rax,%rdx
  404a30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404a34:	48 89 50 18          	mov    %rdx,0x18(%rax)
			if (NULL == p_json_msg->s_file_name)
  404a38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404a3c:	48 8b 40 18          	mov    0x18(%rax),%rax
  404a40:	48 85 c0             	test   %rax,%rax
  404a43:	75 41                	jne    404a86 <gsi_build_parse_handle_op_code+0x22c>
			{
				LOG_ERROR("memory allocation for s_file_name failed");
  404a45:	b8 00 00 00 00       	mov    $0x0,%eax
  404a4a:	e8 8d 1e 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404a4f:	48 89 c3             	mov    %rax,%rbx
  404a52:	b8 00 00 00 00       	mov    $0x0,%eax
  404a57:	e8 fb 1b 00 00       	callq  406657 <gsi_get_saved_file>
  404a5c:	41 b8 72 03 00 00    	mov    $0x372,%r8d
  404a62:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404a67:	48 89 da             	mov    %rbx,%rdx
  404a6a:	be e8 8b 40 00       	mov    $0x408be8,%esi
  404a6f:	48 89 c7             	mov    %rax,%rdi
  404a72:	b8 00 00 00 00       	mov    $0x0,%eax
  404a77:	e8 44 1c 00 00       	callq  4066c0 <gsi_is_write_to_log>
				return GSI_JSON_ERROR;
  404a7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  404a81:	e9 c8 00 00 00       	jmpq   404b4e <gsi_build_parse_handle_op_code+0x2f4>
			}

			// Get destination file length
			p_json_msg->i_data_len = json_object_get_int(json_object_object_get(p_json, "Data Length"));
  404a86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404a8a:	be 0f 8b 40 00       	mov    $0x408b0f,%esi
  404a8f:	48 89 c7             	mov    %rax,%rdi
  404a92:	e8 29 ce ff ff       	callq  4018c0 <json_object_object_get@plt>
  404a97:	48 89 c7             	mov    %rax,%rdi
  404a9a:	e8 71 cc ff ff       	callq  401710 <json_object_get_int@plt>
  404a9f:	89 c2                	mov    %eax,%edx
  404aa1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404aa5:	89 50 10             	mov    %edx,0x10(%rax)

			// Duplicate the destination file name
			p_json_msg->s_data = gsi_build_parse_strdup(json_object_get_string(json_object_object_get(p_json, "Data")));
  404aa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404aac:	be 31 8b 40 00       	mov    $0x408b31,%esi
  404ab1:	48 89 c7             	mov    %rax,%rdi
  404ab4:	e8 07 ce ff ff       	callq  4018c0 <json_object_object_get@plt>
  404ab9:	48 89 c7             	mov    %rax,%rdi
  404abc:	e8 4f cb ff ff       	callq  401610 <json_object_get_string@plt>
  404ac1:	48 89 c7             	mov    %rax,%rdi
  404ac4:	e8 bd 01 00 00       	callq  404c86 <gsi_build_parse_strdup>
  404ac9:	48 89 c2             	mov    %rax,%rdx
  404acc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404ad0:	48 89 50 20          	mov    %rdx,0x20(%rax)
			if (NULL == p_json_msg->s_data)
  404ad4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404ad8:	48 8b 40 20          	mov    0x20(%rax),%rax
  404adc:	48 85 c0             	test   %rax,%rax
  404adf:	75 67                	jne    404b48 <gsi_build_parse_handle_op_code+0x2ee>
			{
				free(p_json_msg->s_file_name);
  404ae1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404ae5:	48 8b 40 18          	mov    0x18(%rax),%rax
  404ae9:	48 89 c7             	mov    %rax,%rdi
  404aec:	e8 5f ca ff ff       	callq  401550 <free@plt>
				p_json_msg->s_file_name = NULL;
  404af1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404af5:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  404afc:	00 

				return GSI_JSON_ERROR;
  404afd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  404b02:	eb 4a                	jmp    404b4e <gsi_build_parse_handle_op_code+0x2f4>
			}

			break;

		default:
			LOG_ERROR("invalid operation code");
  404b04:	b8 00 00 00 00       	mov    $0x0,%eax
  404b09:	e8 ce 1d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404b0e:	48 89 c3             	mov    %rax,%rbx
  404b11:	b8 00 00 00 00       	mov    $0x0,%eax
  404b16:	e8 3c 1b 00 00       	callq  406657 <gsi_get_saved_file>
  404b1b:	41 b8 86 03 00 00    	mov    $0x386,%r8d
  404b21:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404b26:	48 89 da             	mov    %rbx,%rdx
  404b29:	be 80 8a 40 00       	mov    $0x408a80,%esi
  404b2e:	48 89 c7             	mov    %rax,%rdi
  404b31:	b8 00 00 00 00       	mov    $0x0,%eax
  404b36:	e8 85 1b 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_JSON_ERROR;
  404b3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  404b40:	eb 0c                	jmp    404b4e <gsi_build_parse_handle_op_code+0x2f4>
			if (NULL == p_json_msg->s_data)
			{
				return GSI_JSON_ERROR;
			}

			break;
  404b42:	90                   	nop
  404b43:	eb 04                	jmp    404b49 <gsi_build_parse_handle_op_code+0x2ef>
			if (NULL == p_json_msg->s_file_name)
			{
				return GSI_JSON_ERROR;
			}

			break;
  404b45:	90                   	nop
  404b46:	eb 01                	jmp    404b49 <gsi_build_parse_handle_op_code+0x2ef>
				p_json_msg->s_file_name = NULL;

				return GSI_JSON_ERROR;
			}

			break;
  404b48:	90                   	nop
		default:
			LOG_ERROR("invalid operation code");
			return GSI_JSON_ERROR;
	}

	return GSI_JSON_SUCCESS;
  404b49:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404b4e:	48 83 c4 18          	add    $0x18,%rsp
  404b52:	5b                   	pop    %rbx
  404b53:	5d                   	pop    %rbp
  404b54:	c3                   	retq   

0000000000404b55 <gsi_build_parse_get_file_name>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - char* - source file name
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_get_file_name(char** s_line)
{
  404b55:	55                   	push   %rbp
  404b56:	48 89 e5             	mov    %rsp,%rbp
  404b59:	53                   	push   %rbx
  404b5a:	48 83 ec 28          	sub    $0x28,%rsp
  404b5e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	char* s_src_file = NULL;
  404b62:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  404b69:	00 
	char* s_runner = NULL;
  404b6a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  404b71:	00 

	// Check input validation
	if (NULL == s_line)
  404b72:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  404b77:	75 53                	jne    404bcc <gsi_build_parse_get_file_name+0x77>
	{
		LOG_ERROR("invalid argument!");
  404b79:	b8 00 00 00 00       	mov    $0x0,%eax
  404b7e:	e8 59 1d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404b83:	48 89 c3             	mov    %rax,%rbx
  404b86:	b8 00 00 00 00       	mov    $0x0,%eax
  404b8b:	e8 c7 1a 00 00       	callq  406657 <gsi_get_saved_file>
  404b90:	41 b8 9d 03 00 00    	mov    $0x39d,%r8d
  404b96:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404b9b:	48 89 da             	mov    %rbx,%rdx
  404b9e:	be 90 85 40 00       	mov    $0x408590,%esi
  404ba3:	48 89 c7             	mov    %rax,%rdi
  404ba6:	b8 00 00 00 00       	mov    $0x0,%eax
  404bab:	e8 10 1b 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  404bb0:	b8 00 00 00 00       	mov    $0x0,%eax
  404bb5:	e9 c5 00 00 00       	jmpq   404c7f <gsi_build_parse_get_file_name+0x12a>
	}

	//Skip all white space before the file name
	while (('\0' != **s_line) && (isspace(**s_line)))
	{
		++(*s_line);
  404bba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404bbe:	48 8b 00             	mov    (%rax),%rax
  404bc1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  404bc5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404bc9:	48 89 10             	mov    %rdx,(%rax)
		LOG_ERROR("invalid argument!");
		return NULL;
	}

	//Skip all white space before the file name
	while (('\0' != **s_line) && (isspace(**s_line)))
  404bcc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404bd0:	48 8b 00             	mov    (%rax),%rax
  404bd3:	0f b6 00             	movzbl (%rax),%eax
  404bd6:	84 c0                	test   %al,%al
  404bd8:	74 2b                	je     404c05 <gsi_build_parse_get_file_name+0xb0>
  404bda:	e8 51 cd ff ff       	callq  401930 <__ctype_b_loc@plt>
  404bdf:	48 8b 10             	mov    (%rax),%rdx
  404be2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404be6:	48 8b 00             	mov    (%rax),%rax
  404be9:	0f b6 00             	movzbl (%rax),%eax
  404bec:	48 0f be c0          	movsbq %al,%rax
  404bf0:	48 01 c0             	add    %rax,%rax
  404bf3:	48 01 d0             	add    %rdx,%rax
  404bf6:	0f b7 00             	movzwl (%rax),%eax
  404bf9:	0f b7 c0             	movzwl %ax,%eax
  404bfc:	25 00 20 00 00       	and    $0x2000,%eax
  404c01:	85 c0                	test   %eax,%eax
  404c03:	75 b5                	jne    404bba <gsi_build_parse_get_file_name+0x65>
	{
		++(*s_line);
	}

	// Start point to hold the name of the file
	s_src_file = *s_line;
  404c05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404c09:	48 8b 00             	mov    (%rax),%rax
  404c0c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// Runner pointer to run until meet white space
	s_runner = s_src_file;
  404c10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404c14:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// Main run loop
	while (!isspace(*s_runner) && ('\n' != *s_runner))
  404c18:	eb 05                	jmp    404c1f <gsi_build_parse_get_file_name+0xca>
	{
		++s_runner;
  404c1a:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)

	// Runner pointer to run until meet white space
	s_runner = s_src_file;

	// Main run loop
	while (!isspace(*s_runner) && ('\n' != *s_runner))
  404c1f:	e8 0c cd ff ff       	callq  401930 <__ctype_b_loc@plt>
  404c24:	48 8b 10             	mov    (%rax),%rdx
  404c27:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404c2b:	0f b6 00             	movzbl (%rax),%eax
  404c2e:	48 0f be c0          	movsbq %al,%rax
  404c32:	48 01 c0             	add    %rax,%rax
  404c35:	48 01 d0             	add    %rdx,%rax
  404c38:	0f b7 00             	movzwl (%rax),%eax
  404c3b:	0f b7 c0             	movzwl %ax,%eax
  404c3e:	25 00 20 00 00       	and    $0x2000,%eax
  404c43:	85 c0                	test   %eax,%eax
  404c45:	75 0b                	jne    404c52 <gsi_build_parse_get_file_name+0xfd>
  404c47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404c4b:	0f b6 00             	movzbl (%rax),%eax
  404c4e:	3c 0a                	cmp    $0xa,%al
  404c50:	75 c8                	jne    404c1a <gsi_build_parse_get_file_name+0xc5>
	{
		++s_runner;
	}

	// Split the string in the current position
	*s_runner = '\0';
  404c52:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404c56:	c6 00 00             	movb   $0x0,(%rax)

	// Move the original pointer by length of the file name
	*s_line += strlen(s_src_file) + 1;
  404c59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404c5d:	48 8b 18             	mov    (%rax),%rbx
  404c60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404c64:	48 89 c7             	mov    %rax,%rdi
  404c67:	e8 b4 c9 ff ff       	callq  401620 <strlen@plt>
  404c6c:	48 83 c0 01          	add    $0x1,%rax
  404c70:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  404c74:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404c78:	48 89 10             	mov    %rdx,(%rax)

	return s_src_file;
  404c7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  404c7f:	48 83 c4 28          	add    $0x28,%rsp
  404c83:	5b                   	pop    %rbx
  404c84:	5d                   	pop    %rbp
  404c85:	c3                   	retq   

0000000000404c86 <gsi_build_parse_strdup>:
	 * Parameter:   [in] char* s_src - source string
	 * Return:		Success - duplicate string
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_strdup(const char* s_src)
{
  404c86:	55                   	push   %rbp
  404c87:	48 89 e5             	mov    %rsp,%rbp
  404c8a:	53                   	push   %rbx
  404c8b:	48 83 ec 28          	sub    $0x28,%rsp
  404c8f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	char* s_dest = NULL;
  404c93:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  404c9a:	00 

	// Check input validation
	if (NULL == s_src)
  404c9b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  404ca0:	75 3e                	jne    404ce0 <gsi_build_parse_strdup+0x5a>
	{
		LOG_ERROR("invalid argument!");
  404ca2:	b8 00 00 00 00       	mov    $0x0,%eax
  404ca7:	e8 30 1c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404cac:	48 89 c3             	mov    %rax,%rbx
  404caf:	b8 00 00 00 00       	mov    $0x0,%eax
  404cb4:	e8 9e 19 00 00       	callq  406657 <gsi_get_saved_file>
  404cb9:	41 b8 ca 03 00 00    	mov    $0x3ca,%r8d
  404cbf:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404cc4:	48 89 da             	mov    %rbx,%rdx
  404cc7:	be 90 85 40 00       	mov    $0x408590,%esi
  404ccc:	48 89 c7             	mov    %rax,%rdi
  404ccf:	b8 00 00 00 00       	mov    $0x0,%eax
  404cd4:	e8 e7 19 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  404cd9:	b8 00 00 00 00       	mov    $0x0,%eax
  404cde:	eb 78                	jmp    404d58 <gsi_build_parse_strdup+0xd2>
	}

	// Allocate memory for the destination
	s_dest = (char *)malloc(strlen(s_src) + 1);
  404ce0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404ce4:	48 89 c7             	mov    %rax,%rdi
  404ce7:	e8 34 c9 ff ff       	callq  401620 <strlen@plt>
  404cec:	48 83 c0 01          	add    $0x1,%rax
  404cf0:	48 89 c7             	mov    %rax,%rdi
  404cf3:	e8 e8 ca ff ff       	callq  4017e0 <malloc@plt>
  404cf8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == s_dest)
  404cfc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  404d01:	75 3e                	jne    404d41 <gsi_build_parse_strdup+0xbb>
	{
		LOG_ERROR("memory allocation in for dupliaction failed");
  404d03:	b8 00 00 00 00       	mov    $0x0,%eax
  404d08:	e8 cf 1b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404d0d:	48 89 c3             	mov    %rax,%rbx
  404d10:	b8 00 00 00 00       	mov    $0x0,%eax
  404d15:	e8 3d 19 00 00       	callq  406657 <gsi_get_saved_file>
  404d1a:	41 b8 d2 03 00 00    	mov    $0x3d2,%r8d
  404d20:	b9 70 85 40 00       	mov    $0x408570,%ecx
  404d25:	48 89 da             	mov    %rbx,%rdx
  404d28:	be 68 8c 40 00       	mov    $0x408c68,%esi
  404d2d:	48 89 c7             	mov    %rax,%rdi
  404d30:	b8 00 00 00 00       	mov    $0x0,%eax
  404d35:	e8 86 19 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  404d3a:	b8 00 00 00 00       	mov    $0x0,%eax
  404d3f:	eb 17                	jmp    404d58 <gsi_build_parse_strdup+0xd2>
	}

	// Copy content
	strcpy(s_dest, s_src);
  404d41:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  404d45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404d49:	48 89 d6             	mov    %rdx,%rsi
  404d4c:	48 89 c7             	mov    %rax,%rdi
  404d4f:	e8 3c c8 ff ff       	callq  401590 <strcpy@plt>

	return s_dest;
  404d54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  404d58:	48 83 c4 28          	add    $0x28,%rsp
  404d5c:	5b                   	pop    %rbx
  404d5d:	5d                   	pop    %rbp
  404d5e:	c3                   	retq   

0000000000404d5f <gsi_build_parse_op_code_to_string>:
	 * Parameter:   [in] int i_op_code - op code number
	 * Return:		Success - op code as string literal
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_op_code_to_string(int i_op_code)
{
  404d5f:	55                   	push   %rbp
  404d60:	48 89 e5             	mov    %rsp,%rbp
  404d63:	89 7d fc             	mov    %edi,-0x4(%rbp)
	switch(i_op_code)
  404d66:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  404d6a:	77 37                	ja     404da3 <gsi_build_parse_op_code_to_string+0x44>
  404d6c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  404d6f:	48 8b 04 c5 f8 8c 40 	mov    0x408cf8(,%rax,8),%rax
  404d76:	00 
  404d77:	ff e0                	jmpq   *%rax
	{
		case GSI_READ_STR:
			return "READ_STR";
  404d79:	b8 b5 8c 40 00       	mov    $0x408cb5,%eax
  404d7e:	eb 28                	jmp    404da8 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_WRITE_STR:
			return "WRITE_STR";
  404d80:	b8 be 8c 40 00       	mov    $0x408cbe,%eax
  404d85:	eb 21                	jmp    404da8 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_READ_FILE:
			return "READ_FILE";
  404d87:	b8 c8 8c 40 00       	mov    $0x408cc8,%eax
  404d8c:	eb 1a                	jmp    404da8 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_PRINT_LOG:
			return "PRINT_LOG";
  404d8e:	b8 d2 8c 40 00       	mov    $0x408cd2,%eax
  404d93:	eb 13                	jmp    404da8 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_WRITE_FILE:
			return "WRITE_FILE";
  404d95:	b8 dc 8c 40 00       	mov    $0x408cdc,%eax
  404d9a:	eb 0c                	jmp    404da8 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_READ_FILE_BY_ID:
			return "READ_STR_BY_ID";
  404d9c:	b8 e7 8c 40 00       	mov    $0x408ce7,%eax
  404da1:	eb 05                	jmp    404da8 <gsi_build_parse_op_code_to_string+0x49>

		default:
			return NULL;
  404da3:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
  404da8:	5d                   	pop    %rbp
  404da9:	c3                   	retq   

0000000000404daa <gsi_is_network_tcp_reset>:
	 * Parameter:   [in] struct gsi_net_tcp* p_this - pointer to structure TCP
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_reset(struct gsi_net_tcp* p_this)
{
  404daa:	55                   	push   %rbp
  404dab:	48 89 e5             	mov    %rsp,%rbp
  404dae:	53                   	push   %rbx
  404daf:	48 83 ec 18          	sub    $0x18,%rsp
  404db3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == p_this)
  404db7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  404dbc:	75 3e                	jne    404dfc <gsi_is_network_tcp_reset+0x52>
	{
		LOG_ERROR("invalid argument!");
  404dbe:	b8 00 00 00 00       	mov    $0x0,%eax
  404dc3:	e8 14 1b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404dc8:	48 89 c3             	mov    %rax,%rbx
  404dcb:	b8 00 00 00 00       	mov    $0x0,%eax
  404dd0:	e8 82 18 00 00       	callq  406657 <gsi_get_saved_file>
  404dd5:	41 b8 2c 00 00 00    	mov    $0x2c,%r8d
  404ddb:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  404de0:	48 89 da             	mov    %rbx,%rdx
  404de3:	be 48 8d 40 00       	mov    $0x408d48,%esi
  404de8:	48 89 c7             	mov    %rax,%rdi
  404deb:	b8 00 00 00 00       	mov    $0x0,%eax
  404df0:	e8 cb 18 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404df5:	b8 01 00 00 00       	mov    $0x1,%eax
  404dfa:	eb 1b                	jmp    404e17 <gsi_is_network_tcp_reset+0x6d>
	}

	// Set all fields to 0/NULL according to their type
	memset(p_this, 0, sizeof(struct gsi_net_tcp));
  404dfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404e00:	ba 50 00 00 00       	mov    $0x50,%edx
  404e05:	be 00 00 00 00       	mov    $0x0,%esi
  404e0a:	48 89 c7             	mov    %rax,%rdi
  404e0d:	e8 9e c8 ff ff       	callq  4016b0 <memset@plt>

	return GSI_NET_RC_SUCCESS;
  404e12:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404e17:	48 83 c4 18          	add    $0x18,%rsp
  404e1b:	5b                   	pop    %rbx
  404e1c:	5d                   	pop    %rbp
  404e1d:	c3                   	retq   

0000000000404e1e <gsi_is_network_tcp_set_sockaddr>:
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_set_sockaddr(struct sockaddr_in *p_addr,
														  	    char *s_hostname,
																int i_port)
{
  404e1e:	55                   	push   %rbp
  404e1f:	48 89 e5             	mov    %rsp,%rbp
  404e22:	53                   	push   %rbx
  404e23:	48 83 ec 28          	sub    $0x28,%rsp
  404e27:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  404e2b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  404e2f:	89 55 dc             	mov    %edx,-0x24(%rbp)
	// Check input validation
	if (NULL == p_addr)
  404e32:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  404e37:	75 41                	jne    404e7a <gsi_is_network_tcp_set_sockaddr+0x5c>
	{
		LOG_ERROR("invalid argument!");
  404e39:	b8 00 00 00 00       	mov    $0x0,%eax
  404e3e:	e8 99 1a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404e43:	48 89 c3             	mov    %rax,%rbx
  404e46:	b8 00 00 00 00       	mov    $0x0,%eax
  404e4b:	e8 07 18 00 00       	callq  406657 <gsi_get_saved_file>
  404e50:	41 b8 48 00 00 00    	mov    $0x48,%r8d
  404e56:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  404e5b:	48 89 da             	mov    %rbx,%rdx
  404e5e:	be 48 8d 40 00       	mov    $0x408d48,%esi
  404e63:	48 89 c7             	mov    %rax,%rdi
  404e66:	b8 00 00 00 00       	mov    $0x0,%eax
  404e6b:	e8 50 18 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404e70:	b8 01 00 00 00       	mov    $0x1,%eax
  404e75:	e9 b7 00 00 00       	jmpq   404f31 <gsi_is_network_tcp_set_sockaddr+0x113>
	}

	// Setup socket parameters to INET (IPv4)
	p_addr->sin_family = AF_INET;
  404e7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404e7e:	66 c7 00 02 00       	movw   $0x2,(%rax)

	// Translate Hostname to IP Address
	if (0 >= inet_pton(AF_INET, s_hostname, &p_addr->sin_addr))
  404e83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404e87:	48 8d 50 04          	lea    0x4(%rax),%rdx
  404e8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404e8f:	48 89 c6             	mov    %rax,%rsi
  404e92:	bf 02 00 00 00       	mov    $0x2,%edi
  404e97:	e8 f4 c8 ff ff       	callq  401790 <inet_pton@plt>
  404e9c:	85 c0                	test   %eax,%eax
  404e9e:	7f 3e                	jg     404ede <gsi_is_network_tcp_set_sockaddr+0xc0>
	{
		LOG_ERROR("translation ip failed");
  404ea0:	b8 00 00 00 00       	mov    $0x0,%eax
  404ea5:	e8 32 1a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404eaa:	48 89 c3             	mov    %rax,%rbx
  404ead:	b8 00 00 00 00       	mov    $0x0,%eax
  404eb2:	e8 a0 17 00 00       	callq  406657 <gsi_get_saved_file>
  404eb7:	41 b8 52 00 00 00    	mov    $0x52,%r8d
  404ebd:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  404ec2:	48 89 da             	mov    %rbx,%rdx
  404ec5:	be 80 8d 40 00       	mov    $0x408d80,%esi
  404eca:	48 89 c7             	mov    %rax,%rdi
  404ecd:	b8 00 00 00 00       	mov    $0x0,%eax
  404ed2:	e8 e9 17 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404ed7:	b8 01 00 00 00       	mov    $0x1,%eax
  404edc:	eb 53                	jmp    404f31 <gsi_is_network_tcp_set_sockaddr+0x113>
	}

	// Translate Port to network byte order
	p_addr->sin_port = htons(i_port);
  404ede:	8b 45 dc             	mov    -0x24(%rbp),%eax
  404ee1:	0f b7 c0             	movzwl %ax,%eax
  404ee4:	89 c7                	mov    %eax,%edi
  404ee6:	e8 75 c7 ff ff       	callq  401660 <htons@plt>
  404eeb:	89 c2                	mov    %eax,%edx
  404eed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404ef1:	66 89 50 02          	mov    %dx,0x2(%rax)

	LOG_INFO("set socket parameters success");
  404ef5:	b8 00 00 00 00       	mov    $0x0,%eax
  404efa:	e8 dd 19 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404eff:	48 89 c3             	mov    %rax,%rbx
  404f02:	b8 00 00 00 00       	mov    $0x0,%eax
  404f07:	e8 4b 17 00 00       	callq  406657 <gsi_get_saved_file>
  404f0c:	41 b8 59 00 00 00    	mov    $0x59,%r8d
  404f12:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  404f17:	48 89 da             	mov    %rbx,%rdx
  404f1a:	be b8 8d 40 00       	mov    $0x408db8,%esi
  404f1f:	48 89 c7             	mov    %rax,%rdi
  404f22:	b8 00 00 00 00       	mov    $0x0,%eax
  404f27:	e8 94 17 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  404f2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404f31:	48 83 c4 28          	add    $0x28,%rsp
  404f35:	5b                   	pop    %rbx
  404f36:	5d                   	pop    %rbp
  404f37:	c3                   	retq   

0000000000404f38 <gsi_is_network_tcp_connect>:
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_connect(struct sockaddr_in *p_serv_addr,
													 	   int *p_socket_fd)
{
  404f38:	55                   	push   %rbp
  404f39:	48 89 e5             	mov    %rsp,%rbp
  404f3c:	53                   	push   %rbx
  404f3d:	48 83 ec 18          	sub    $0x18,%rsp
  404f41:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  404f45:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((NULL == p_serv_addr) || (NULL == p_socket_fd))
  404f49:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  404f4e:	74 07                	je     404f57 <gsi_is_network_tcp_connect+0x1f>
  404f50:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  404f55:	75 41                	jne    404f98 <gsi_is_network_tcp_connect+0x60>
	{
		LOG_ERROR("invalid arguments!");
  404f57:	b8 00 00 00 00       	mov    $0x0,%eax
  404f5c:	e8 7b 19 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404f61:	48 89 c3             	mov    %rax,%rbx
  404f64:	b8 00 00 00 00       	mov    $0x0,%eax
  404f69:	e8 e9 16 00 00       	callq  406657 <gsi_get_saved_file>
  404f6e:	41 b8 6f 00 00 00    	mov    $0x6f,%r8d
  404f74:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  404f79:	48 89 da             	mov    %rbx,%rdx
  404f7c:	be f8 8d 40 00       	mov    $0x408df8,%esi
  404f81:	48 89 c7             	mov    %rax,%rdi
  404f84:	b8 00 00 00 00       	mov    $0x0,%eax
  404f89:	e8 32 17 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404f8e:	b8 01 00 00 00       	mov    $0x1,%eax
  404f93:	e9 fe 00 00 00       	jmpq   405096 <gsi_is_network_tcp_connect+0x15e>
	}

	// Open a Socket and update p_socket_fd
	if (0 > (*p_socket_fd = socket(AF_INET, SOCK_STREAM, 0)))
  404f98:	ba 00 00 00 00       	mov    $0x0,%edx
  404f9d:	be 01 00 00 00       	mov    $0x1,%esi
  404fa2:	bf 02 00 00 00       	mov    $0x2,%edi
  404fa7:	e8 94 c9 ff ff       	callq  401940 <socket@plt>
  404fac:	89 c2                	mov    %eax,%edx
  404fae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404fb2:	89 10                	mov    %edx,(%rax)
  404fb4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  404fb8:	8b 00                	mov    (%rax),%eax
  404fba:	85 c0                	test   %eax,%eax
  404fbc:	79 41                	jns    404fff <gsi_is_network_tcp_connect+0xc7>
	{
		LOG_ERROR("socket fail");
  404fbe:	b8 00 00 00 00       	mov    $0x0,%eax
  404fc3:	e8 14 19 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  404fc8:	48 89 c3             	mov    %rax,%rbx
  404fcb:	b8 00 00 00 00       	mov    $0x0,%eax
  404fd0:	e8 82 16 00 00       	callq  406657 <gsi_get_saved_file>
  404fd5:	41 b8 76 00 00 00    	mov    $0x76,%r8d
  404fdb:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  404fe0:	48 89 da             	mov    %rbx,%rdx
  404fe3:	be 30 8e 40 00       	mov    $0x408e30,%esi
  404fe8:	48 89 c7             	mov    %rax,%rdi
  404feb:	b8 00 00 00 00       	mov    $0x0,%eax
  404ff0:	e8 cb 16 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404ff5:	b8 01 00 00 00       	mov    $0x1,%eax
  404ffa:	e9 97 00 00 00       	jmpq   405096 <gsi_is_network_tcp_connect+0x15e>
	}

	// Connect to Server
	if (0 > connect(*p_socket_fd, (struct sockaddr *)p_serv_addr, sizeof(struct sockaddr_in)))
  404fff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  405003:	8b 00                	mov    (%rax),%eax
  405005:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  405009:	ba 10 00 00 00       	mov    $0x10,%edx
  40500e:	48 89 ce             	mov    %rcx,%rsi
  405011:	89 c7                	mov    %eax,%edi
  405013:	e8 c8 c8 ff ff       	callq  4018e0 <connect@plt>
  405018:	85 c0                	test   %eax,%eax
  40501a:	79 3e                	jns    40505a <gsi_is_network_tcp_connect+0x122>
	{
		LOG_ERROR("connect fail");
  40501c:	b8 00 00 00 00       	mov    $0x0,%eax
  405021:	e8 b6 18 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405026:	48 89 c3             	mov    %rax,%rbx
  405029:	b8 00 00 00 00       	mov    $0x0,%eax
  40502e:	e8 24 16 00 00       	callq  406657 <gsi_get_saved_file>
  405033:	41 b8 7d 00 00 00    	mov    $0x7d,%r8d
  405039:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40503e:	48 89 da             	mov    %rbx,%rdx
  405041:	be 60 8e 40 00       	mov    $0x408e60,%esi
  405046:	48 89 c7             	mov    %rax,%rdi
  405049:	b8 00 00 00 00       	mov    $0x0,%eax
  40504e:	e8 6d 16 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_CONNECTERR;
  405053:	b8 04 00 00 00       	mov    $0x4,%eax
  405058:	eb 3c                	jmp    405096 <gsi_is_network_tcp_connect+0x15e>
	}

	LOG_INFO("connect success!");
  40505a:	b8 00 00 00 00       	mov    $0x0,%eax
  40505f:	e8 78 18 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405064:	48 89 c3             	mov    %rax,%rbx
  405067:	b8 00 00 00 00       	mov    $0x0,%eax
  40506c:	e8 e6 15 00 00       	callq  406657 <gsi_get_saved_file>
  405071:	41 b8 81 00 00 00    	mov    $0x81,%r8d
  405077:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40507c:	48 89 da             	mov    %rbx,%rdx
  40507f:	be 90 8e 40 00       	mov    $0x408e90,%esi
  405084:	48 89 c7             	mov    %rax,%rdi
  405087:	b8 00 00 00 00       	mov    $0x0,%eax
  40508c:	e8 2f 16 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  405091:	b8 00 00 00 00       	mov    $0x0,%eax
}
  405096:	48 83 c4 18          	add    $0x18,%rsp
  40509a:	5b                   	pop    %rbx
  40509b:	5d                   	pop    %rbp
  40509c:	c3                   	retq   

000000000040509d <gsi_is_network_tcp_send>:
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR *OR* GSI_NET_RC_CONNECTERR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_send(struct gsi_net_tcp *p_this,
														char *s_msg)
{
  40509d:	55                   	push   %rbp
  40509e:	48 89 e5             	mov    %rsp,%rbp
  4050a1:	53                   	push   %rbx
  4050a2:	48 83 ec 28          	sub    $0x28,%rsp
  4050a6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  4050aa:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int i_len = 0;
  4050ae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	int i_count = 0;
  4050b5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	struct gsi_cs_tcp_message *p_msg = (struct gsi_cs_tcp_message *)s_msg;
  4050bc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4050c0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// Check input validation
	if ((NULL == p_this) || (NULL == p_msg))
  4050c4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  4050c9:	74 07                	je     4050d2 <gsi_is_network_tcp_send+0x35>
  4050cb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4050d0:	75 41                	jne    405113 <gsi_is_network_tcp_send+0x76>
	{
		LOG_ERROR("invalid arguments!");
  4050d2:	b8 00 00 00 00       	mov    $0x0,%eax
  4050d7:	e8 00 18 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4050dc:	48 89 c3             	mov    %rax,%rbx
  4050df:	b8 00 00 00 00       	mov    $0x0,%eax
  4050e4:	e8 6e 15 00 00       	callq  406657 <gsi_get_saved_file>
  4050e9:	41 b8 98 00 00 00    	mov    $0x98,%r8d
  4050ef:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4050f4:	48 89 da             	mov    %rbx,%rdx
  4050f7:	be f8 8d 40 00       	mov    $0x408df8,%esi
  4050fc:	48 89 c7             	mov    %rax,%rdi
  4050ff:	b8 00 00 00 00       	mov    $0x0,%eax
  405104:	e8 b7 15 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405109:	b8 01 00 00 00       	mov    $0x1,%eax
  40510e:	e9 c1 01 00 00       	jmpq   4052d4 <gsi_is_network_tcp_send+0x237>
	}

	// Save message size for later comparison
	i_len = sizeof(*p_msg) - sizeof(char*);
  405113:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%rbp)
	/* 	Attempt to WRITE:
	 * 		if i_count == original requested i_len -- Success
	 * 		if i_count < 0 -- Error, Attempt to Re-Connect
	 * 		if 0 < i_count < i_len - Partial. Consider an Error
	 */
	while ((i_count = write(p_this->i_connection_fd, p_msg, i_len)) < 0)
  40511a:	e9 97 00 00 00       	jmpq   4051b6 <gsi_is_network_tcp_send+0x119>
	{
		LOG_INFO("try to reconnect...");
  40511f:	b8 00 00 00 00       	mov    $0x0,%eax
  405124:	e8 b3 17 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405129:	48 89 c3             	mov    %rax,%rbx
  40512c:	b8 00 00 00 00       	mov    $0x0,%eax
  405131:	e8 21 15 00 00       	callq  406657 <gsi_get_saved_file>
  405136:	41 b8 a6 00 00 00    	mov    $0xa6,%r8d
  40513c:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405141:	48 89 da             	mov    %rbx,%rdx
  405144:	be c8 8e 40 00       	mov    $0x408ec8,%esi
  405149:	48 89 c7             	mov    %rax,%rdi
  40514c:	b8 00 00 00 00       	mov    $0x0,%eax
  405151:	e8 6a 15 00 00       	callq  4066c0 <gsi_is_write_to_log>

		if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_connect(&p_this->serv_addr, &p_this->i_connection_fd))
  405156:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40515a:	48 8d 50 1c          	lea    0x1c(%rax),%rdx
  40515e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405162:	48 83 c0 2c          	add    $0x2c,%rax
  405166:	48 89 d6             	mov    %rdx,%rsi
  405169:	48 89 c7             	mov    %rax,%rdi
  40516c:	e8 c7 fd ff ff       	callq  404f38 <gsi_is_network_tcp_connect>
  405171:	85 c0                	test   %eax,%eax
  405173:	74 41                	je     4051b6 <gsi_is_network_tcp_send+0x119>
		{
			LOG_ERROR("connection failed!");
  405175:	b8 00 00 00 00       	mov    $0x0,%eax
  40517a:	e8 5d 17 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40517f:	48 89 c3             	mov    %rax,%rbx
  405182:	b8 00 00 00 00       	mov    $0x0,%eax
  405187:	e8 cb 14 00 00       	callq  406657 <gsi_get_saved_file>
  40518c:	41 b8 aa 00 00 00    	mov    $0xaa,%r8d
  405192:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405197:	48 89 da             	mov    %rbx,%rdx
  40519a:	be 00 8f 40 00       	mov    $0x408f00,%esi
  40519f:	48 89 c7             	mov    %rax,%rdi
  4051a2:	b8 00 00 00 00       	mov    $0x0,%eax
  4051a7:	e8 14 15 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_NET_RC_CONNECTERR;
  4051ac:	b8 04 00 00 00       	mov    $0x4,%eax
  4051b1:	e9 1e 01 00 00       	jmpq   4052d4 <gsi_is_network_tcp_send+0x237>
	/* 	Attempt to WRITE:
	 * 		if i_count == original requested i_len -- Success
	 * 		if i_count < 0 -- Error, Attempt to Re-Connect
	 * 		if 0 < i_count < i_len - Partial. Consider an Error
	 */
	while ((i_count = write(p_this->i_connection_fd, p_msg, i_len)) < 0)
  4051b6:	8b 45 e0             	mov    -0x20(%rbp),%eax
  4051b9:	48 63 d0             	movslq %eax,%rdx
  4051bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4051c0:	8b 40 1c             	mov    0x1c(%rax),%eax
  4051c3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  4051c7:	48 89 ce             	mov    %rcx,%rsi
  4051ca:	89 c7                	mov    %eax,%edi
  4051cc:	e8 0f c4 ff ff       	callq  4015e0 <write@plt>
  4051d1:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  4051d4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  4051d8:	0f 88 41 ff ff ff    	js     40511f <gsi_is_network_tcp_send+0x82>
			return GSI_NET_RC_CONNECTERR;
		}
	}

	// Send message content
	if ((GSI_REGULAR_MSG == p_msg->e_type_msg) &&
  4051de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4051e2:	8b 40 04             	mov    0x4(%rax),%eax
  4051e5:	83 f8 01             	cmp    $0x1,%eax
  4051e8:	75 68                	jne    405252 <gsi_is_network_tcp_send+0x1b5>
		(0 > write(p_this->i_connection_fd, p_msg->s_message, p_msg->ui_len)))
  4051ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4051ee:	8b 40 08             	mov    0x8(%rax),%eax
  4051f1:	89 c2                	mov    %eax,%edx
  4051f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4051f7:	48 8b 48 10          	mov    0x10(%rax),%rcx
  4051fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4051ff:	8b 40 1c             	mov    0x1c(%rax),%eax
  405202:	48 89 ce             	mov    %rcx,%rsi
  405205:	89 c7                	mov    %eax,%edi
  405207:	e8 d4 c3 ff ff       	callq  4015e0 <write@plt>
			return GSI_NET_RC_CONNECTERR;
		}
	}

	// Send message content
	if ((GSI_REGULAR_MSG == p_msg->e_type_msg) &&
  40520c:	48 85 c0             	test   %rax,%rax
  40520f:	79 41                	jns    405252 <gsi_is_network_tcp_send+0x1b5>
		(0 > write(p_this->i_connection_fd, p_msg->s_message, p_msg->ui_len)))
	{
		LOG_ERROR("write message failed");
  405211:	b8 00 00 00 00       	mov    $0x0,%eax
  405216:	e8 c1 16 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40521b:	48 89 c3             	mov    %rax,%rbx
  40521e:	b8 00 00 00 00       	mov    $0x0,%eax
  405223:	e8 2f 14 00 00       	callq  406657 <gsi_get_saved_file>
  405228:	41 b8 b3 00 00 00    	mov    $0xb3,%r8d
  40522e:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405233:	48 89 da             	mov    %rbx,%rdx
  405236:	be 38 8f 40 00       	mov    $0x408f38,%esi
  40523b:	48 89 c7             	mov    %rax,%rdi
  40523e:	b8 00 00 00 00       	mov    $0x0,%eax
  405243:	e8 78 14 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405248:	b8 01 00 00 00       	mov    $0x1,%eax
  40524d:	e9 82 00 00 00       	jmpq   4052d4 <gsi_is_network_tcp_send+0x237>
	}

	// Case of: 0 < i_count < i_len
	if (i_count < i_len)
  405252:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  405255:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  405258:	7d 3e                	jge    405298 <gsi_is_network_tcp_send+0x1fb>
	{
		LOG_ERROR("partial write");
  40525a:	b8 00 00 00 00       	mov    $0x0,%eax
  40525f:	e8 78 16 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405264:	48 89 c3             	mov    %rax,%rbx
  405267:	b8 00 00 00 00       	mov    $0x0,%eax
  40526c:	e8 e6 13 00 00       	callq  406657 <gsi_get_saved_file>
  405271:	41 b8 ba 00 00 00    	mov    $0xba,%r8d
  405277:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40527c:	48 89 da             	mov    %rbx,%rdx
  40527f:	be 70 8f 40 00       	mov    $0x408f70,%esi
  405284:	48 89 c7             	mov    %rax,%rdi
  405287:	b8 00 00 00 00       	mov    $0x0,%eax
  40528c:	e8 2f 14 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405291:	b8 01 00 00 00       	mov    $0x1,%eax
  405296:	eb 3c                	jmp    4052d4 <gsi_is_network_tcp_send+0x237>
	}

	LOG_INFO("message sent successfully");
  405298:	b8 00 00 00 00       	mov    $0x0,%eax
  40529d:	e8 3a 16 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4052a2:	48 89 c3             	mov    %rax,%rbx
  4052a5:	b8 00 00 00 00       	mov    $0x0,%eax
  4052aa:	e8 a8 13 00 00       	callq  406657 <gsi_get_saved_file>
  4052af:	41 b8 be 00 00 00    	mov    $0xbe,%r8d
  4052b5:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4052ba:	48 89 da             	mov    %rbx,%rdx
  4052bd:	be a0 8f 40 00       	mov    $0x408fa0,%esi
  4052c2:	48 89 c7             	mov    %rax,%rdi
  4052c5:	b8 00 00 00 00       	mov    $0x0,%eax
  4052ca:	e8 f1 13 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  4052cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4052d4:	48 83 c4 28          	add    $0x28,%rsp
  4052d8:	5b                   	pop    %rbx
  4052d9:	5d                   	pop    %rbp
  4052da:	c3                   	retq   

00000000004052db <gsi_is_network_tcp_client_init>:
	 * Parameter:   [in] char* s_tcp_addr - Address to connect to <IPAddress>:<Port>
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR *OR* GSI_NET_RC_CONNECTERR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_client_init(struct gsi_net_tcp *p_this, char* s_tcp_addr)
{
  4052db:	55                   	push   %rbp
  4052dc:	48 89 e5             	mov    %rsp,%rbp
  4052df:	53                   	push   %rbx
  4052e0:	48 83 ec 28          	sub    $0x28,%rsp
  4052e4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  4052e8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Check input validation
	if ((NULL == p_this) || (NULL == s_tcp_addr))
  4052ec:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  4052f1:	74 07                	je     4052fa <gsi_is_network_tcp_client_init+0x1f>
  4052f3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  4052f8:	75 41                	jne    40533b <gsi_is_network_tcp_client_init+0x60>
	{
		LOG_ERROR("invalid arguments!");
  4052fa:	b8 00 00 00 00       	mov    $0x0,%eax
  4052ff:	e8 d8 15 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405304:	48 89 c3             	mov    %rax,%rbx
  405307:	b8 00 00 00 00       	mov    $0x0,%eax
  40530c:	e8 46 13 00 00       	callq  406657 <gsi_get_saved_file>
  405311:	41 b8 d0 00 00 00    	mov    $0xd0,%r8d
  405317:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40531c:	48 89 da             	mov    %rbx,%rdx
  40531f:	be f8 8d 40 00       	mov    $0x408df8,%esi
  405324:	48 89 c7             	mov    %rax,%rdi
  405327:	b8 00 00 00 00       	mov    $0x0,%eax
  40532c:	e8 8f 13 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405331:	b8 01 00 00 00       	mov    $0x1,%eax
  405336:	e9 77 01 00 00       	jmpq   4054b2 <gsi_is_network_tcp_client_init+0x1d7>
	}

	// Initialize address parameters
	char* s_port = set_address_parameters(p_this, s_tcp_addr);
  40533b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  40533f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405343:	48 89 d6             	mov    %rdx,%rsi
  405346:	48 89 c7             	mov    %rax,%rdi
  405349:	e8 8c 0a 00 00       	callq  405dda <set_address_parameters>
  40534e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == s_port)
  405352:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  405357:	75 41                	jne    40539a <gsi_is_network_tcp_client_init+0xbf>
	{
		LOG_ERROR("invalid form of address");
  405359:	b8 00 00 00 00       	mov    $0x0,%eax
  40535e:	e8 79 15 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405363:	48 89 c3             	mov    %rax,%rbx
  405366:	b8 00 00 00 00       	mov    $0x0,%eax
  40536b:	e8 e7 12 00 00       	callq  406657 <gsi_get_saved_file>
  405370:	41 b8 d8 00 00 00    	mov    $0xd8,%r8d
  405376:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40537b:	48 89 da             	mov    %rbx,%rdx
  40537e:	be e0 8f 40 00       	mov    $0x408fe0,%esi
  405383:	48 89 c7             	mov    %rax,%rdi
  405386:	b8 00 00 00 00       	mov    $0x0,%eax
  40538b:	e8 30 13 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405390:	b8 01 00 00 00       	mov    $0x1,%eax
  405395:	e9 18 01 00 00       	jmpq   4054b2 <gsi_is_network_tcp_client_init+0x1d7>
	}

	// Set port member
	p_this->ui_port = atoi(s_port);
  40539a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40539e:	48 89 c7             	mov    %rax,%rdi
  4053a1:	e8 0a c5 ff ff       	callq  4018b0 <atoi@plt>
  4053a6:	89 c2                	mov    %eax,%edx
  4053a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4053ac:	89 50 28             	mov    %edx,0x28(%rax)

	// Set socket parameters
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_set_sockaddr(&p_this->serv_addr,
															   p_this->s_tcp_addr,
															   p_this->ui_port))
  4053af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4053b3:	8b 40 28             	mov    0x28(%rax),%eax

	// Set port member
	p_this->ui_port = atoi(s_port);

	// Set socket parameters
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_set_sockaddr(&p_this->serv_addr,
  4053b6:	89 c6                	mov    %eax,%esi
  4053b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4053bc:	48 8b 00             	mov    (%rax),%rax
  4053bf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  4053c3:	48 8d 4a 2c          	lea    0x2c(%rdx),%rcx
  4053c7:	89 f2                	mov    %esi,%edx
  4053c9:	48 89 c6             	mov    %rax,%rsi
  4053cc:	48 89 cf             	mov    %rcx,%rdi
  4053cf:	e8 4a fa ff ff       	callq  404e1e <gsi_is_network_tcp_set_sockaddr>
  4053d4:	85 c0                	test   %eax,%eax
  4053d6:	74 41                	je     405419 <gsi_is_network_tcp_client_init+0x13e>
															   p_this->s_tcp_addr,
															   p_this->ui_port))
	{
		LOG_ERROR("set socket parameters failed");
  4053d8:	b8 00 00 00 00       	mov    $0x0,%eax
  4053dd:	e8 fa 14 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4053e2:	48 89 c3             	mov    %rax,%rbx
  4053e5:	b8 00 00 00 00       	mov    $0x0,%eax
  4053ea:	e8 68 12 00 00       	callq  406657 <gsi_get_saved_file>
  4053ef:	41 b8 e4 00 00 00    	mov    $0xe4,%r8d
  4053f5:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4053fa:	48 89 da             	mov    %rbx,%rdx
  4053fd:	be 20 90 40 00       	mov    $0x409020,%esi
  405402:	48 89 c7             	mov    %rax,%rdi
  405405:	b8 00 00 00 00       	mov    $0x0,%eax
  40540a:	e8 b1 12 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  40540f:	b8 01 00 00 00       	mov    $0x1,%eax
  405414:	e9 99 00 00 00       	jmpq   4054b2 <gsi_is_network_tcp_client_init+0x1d7>
	}

	// Connect to Server
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_connect(&p_this->serv_addr, &p_this->i_connection_fd))
  405419:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40541d:	48 8d 50 1c          	lea    0x1c(%rax),%rdx
  405421:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405425:	48 83 c0 2c          	add    $0x2c,%rax
  405429:	48 89 d6             	mov    %rdx,%rsi
  40542c:	48 89 c7             	mov    %rax,%rdi
  40542f:	e8 04 fb ff ff       	callq  404f38 <gsi_is_network_tcp_connect>
  405434:	85 c0                	test   %eax,%eax
  405436:	74 3e                	je     405476 <gsi_is_network_tcp_client_init+0x19b>
	{
		LOG_ERROR("connection failed!");
  405438:	b8 00 00 00 00       	mov    $0x0,%eax
  40543d:	e8 9a 14 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405442:	48 89 c3             	mov    %rax,%rbx
  405445:	b8 00 00 00 00       	mov    $0x0,%eax
  40544a:	e8 08 12 00 00       	callq  406657 <gsi_get_saved_file>
  40544f:	41 b8 eb 00 00 00    	mov    $0xeb,%r8d
  405455:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40545a:	48 89 da             	mov    %rbx,%rdx
  40545d:	be 00 8f 40 00       	mov    $0x408f00,%esi
  405462:	48 89 c7             	mov    %rax,%rdi
  405465:	b8 00 00 00 00       	mov    $0x0,%eax
  40546a:	e8 51 12 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_CONNECTERR;
  40546f:	b8 04 00 00 00       	mov    $0x4,%eax
  405474:	eb 3c                	jmp    4054b2 <gsi_is_network_tcp_client_init+0x1d7>
	}

	LOG_INFO("client init successfully");
  405476:	b8 00 00 00 00       	mov    $0x0,%eax
  40547b:	e8 5c 14 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405480:	48 89 c3             	mov    %rax,%rbx
  405483:	b8 00 00 00 00       	mov    $0x0,%eax
  405488:	e8 ca 11 00 00       	callq  406657 <gsi_get_saved_file>
  40548d:	41 b8 ef 00 00 00    	mov    $0xef,%r8d
  405493:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405498:	48 89 da             	mov    %rbx,%rdx
  40549b:	be 60 90 40 00       	mov    $0x409060,%esi
  4054a0:	48 89 c7             	mov    %rax,%rdi
  4054a3:	b8 00 00 00 00       	mov    $0x0,%eax
  4054a8:	e8 13 12 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  4054ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4054b2:	48 83 c4 28          	add    $0x28,%rsp
  4054b6:	5b                   	pop    %rbx
  4054b7:	5d                   	pop    %rbp
  4054b8:	c3                   	retq   

00000000004054b9 <gsi_is_network_tcp_server_init>:
	 * Parameter:   [in] unsigned int ui_port - port to connect to
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_server_init(struct gsi_net_tcp *p_this, unsigned int ui_port)
{
  4054b9:	55                   	push   %rbp
  4054ba:	48 89 e5             	mov    %rsp,%rbp
  4054bd:	41 54                	push   %r12
  4054bf:	53                   	push   %rbx
  4054c0:	48 83 ec 20          	sub    $0x20,%rsp
  4054c4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  4054c8:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  4054cb:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4054d2:	00 00 
  4054d4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  4054d8:	31 c0                	xor    %eax,%eax
	// Check input validation
	if (NULL == p_this)
  4054da:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  4054df:	75 41                	jne    405522 <gsi_is_network_tcp_server_init+0x69>
	{
		LOG_ERROR("invalid arguments!");
  4054e1:	b8 00 00 00 00       	mov    $0x0,%eax
  4054e6:	e8 f1 13 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4054eb:	48 89 c3             	mov    %rax,%rbx
  4054ee:	b8 00 00 00 00       	mov    $0x0,%eax
  4054f3:	e8 5f 11 00 00       	callq  406657 <gsi_get_saved_file>
  4054f8:	41 b8 03 01 00 00    	mov    $0x103,%r8d
  4054fe:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405503:	48 89 da             	mov    %rbx,%rdx
  405506:	be f8 8d 40 00       	mov    $0x408df8,%esi
  40550b:	48 89 c7             	mov    %rax,%rdi
  40550e:	b8 00 00 00 00       	mov    $0x0,%eax
  405513:	e8 a8 11 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405518:	b8 01 00 00 00       	mov    $0x1,%eax
  40551d:	e9 b4 02 00 00       	jmpq   4057d6 <gsi_is_network_tcp_server_init+0x31d>
	}

	// Reset server parameters
	if(GSI_NET_RC_SUCCESS != gsi_is_network_tcp_reset(p_this))
  405522:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405526:	48 89 c7             	mov    %rax,%rdi
  405529:	e8 7c f8 ff ff       	callq  404daa <gsi_is_network_tcp_reset>
  40552e:	85 c0                	test   %eax,%eax
  405530:	74 41                	je     405573 <gsi_is_network_tcp_server_init+0xba>
	{
		LOG_ERROR("reset server parameters failed");
  405532:	b8 00 00 00 00       	mov    $0x0,%eax
  405537:	e8 a0 13 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40553c:	48 89 c3             	mov    %rax,%rbx
  40553f:	b8 00 00 00 00       	mov    $0x0,%eax
  405544:	e8 0e 11 00 00       	callq  406657 <gsi_get_saved_file>
  405549:	41 b8 0a 01 00 00    	mov    $0x10a,%r8d
  40554f:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405554:	48 89 da             	mov    %rbx,%rdx
  405557:	be a0 90 40 00       	mov    $0x4090a0,%esi
  40555c:	48 89 c7             	mov    %rax,%rdi
  40555f:	b8 00 00 00 00       	mov    $0x0,%eax
  405564:	e8 57 11 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405569:	b8 01 00 00 00       	mov    $0x1,%eax
  40556e:	e9 63 02 00 00       	jmpq   4057d6 <gsi_is_network_tcp_server_init+0x31d>
	}

	// Set local ip
	p_this->s_tcp_addr = "127.0.0.1";
  405573:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405577:	48 c7 00 e0 90 40 00 	movq   $0x4090e0,(%rax)
	p_this->ui_port = ui_port;
  40557e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405582:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  405585:	89 50 28             	mov    %edx,0x28(%rax)

	// Set socket parameters
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_set_sockaddr(&p_this->serv_addr,
															   p_this->s_tcp_addr,
															   p_this->ui_port))
  405588:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40558c:	8b 40 28             	mov    0x28(%rax),%eax
	// Set local ip
	p_this->s_tcp_addr = "127.0.0.1";
	p_this->ui_port = ui_port;

	// Set socket parameters
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_set_sockaddr(&p_this->serv_addr,
  40558f:	89 c6                	mov    %eax,%esi
  405591:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405595:	48 8b 00             	mov    (%rax),%rax
  405598:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40559c:	48 8d 4a 2c          	lea    0x2c(%rdx),%rcx
  4055a0:	89 f2                	mov    %esi,%edx
  4055a2:	48 89 c6             	mov    %rax,%rsi
  4055a5:	48 89 cf             	mov    %rcx,%rdi
  4055a8:	e8 71 f8 ff ff       	callq  404e1e <gsi_is_network_tcp_set_sockaddr>
  4055ad:	85 c0                	test   %eax,%eax
  4055af:	74 41                	je     4055f2 <gsi_is_network_tcp_server_init+0x139>
															   p_this->s_tcp_addr,
															   p_this->ui_port))
	{
		LOG_ERROR("set socket parameters failed");
  4055b1:	b8 00 00 00 00       	mov    $0x0,%eax
  4055b6:	e8 21 13 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4055bb:	48 89 c3             	mov    %rax,%rbx
  4055be:	b8 00 00 00 00       	mov    $0x0,%eax
  4055c3:	e8 8f 10 00 00       	callq  406657 <gsi_get_saved_file>
  4055c8:	41 b8 17 01 00 00    	mov    $0x117,%r8d
  4055ce:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4055d3:	48 89 da             	mov    %rbx,%rdx
  4055d6:	be 20 90 40 00       	mov    $0x409020,%esi
  4055db:	48 89 c7             	mov    %rax,%rdi
  4055de:	b8 00 00 00 00       	mov    $0x0,%eax
  4055e3:	e8 d8 10 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  4055e8:	b8 01 00 00 00       	mov    $0x1,%eax
  4055ed:	e9 e4 01 00 00       	jmpq   4057d6 <gsi_is_network_tcp_server_init+0x31d>
	}

	// Clear the field of last message
	p_this->s_last_msg = NULL;
  4055f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4055f6:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  4055fd:	00 

	// Create Listen Socket, used to receive connections
    p_this->i_listen_fd = socket(AF_INET, SOCK_STREAM, 0);
  4055fe:	ba 00 00 00 00       	mov    $0x0,%edx
  405603:	be 01 00 00 00       	mov    $0x1,%esi
  405608:	bf 02 00 00 00       	mov    $0x2,%edi
  40560d:	e8 2e c3 ff ff       	callq  401940 <socket@plt>
  405612:	89 c2                	mov    %eax,%edx
  405614:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405618:	89 50 18             	mov    %edx,0x18(%rax)
    if (0 > p_this->i_listen_fd)
  40561b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40561f:	8b 40 18             	mov    0x18(%rax),%eax
  405622:	85 c0                	test   %eax,%eax
  405624:	79 41                	jns    405667 <gsi_is_network_tcp_server_init+0x1ae>
    {
    	LOG_ERROR("socket failed");
  405626:	b8 00 00 00 00       	mov    $0x0,%eax
  40562b:	e8 ac 12 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405630:	48 89 c3             	mov    %rax,%rbx
  405633:	b8 00 00 00 00       	mov    $0x0,%eax
  405638:	e8 1a 10 00 00       	callq  406657 <gsi_get_saved_file>
  40563d:	41 b8 22 01 00 00    	mov    $0x122,%r8d
  405643:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405648:	48 89 da             	mov    %rbx,%rdx
  40564b:	be f0 90 40 00       	mov    $0x4090f0,%esi
  405650:	48 89 c7             	mov    %rax,%rdi
  405653:	b8 00 00 00 00       	mov    $0x0,%eax
  405658:	e8 63 10 00 00       	callq  4066c0 <gsi_is_write_to_log>
    	return GSI_NET_RC_ERROR;
  40565d:	b8 01 00 00 00       	mov    $0x1,%eax
  405662:	e9 6f 01 00 00       	jmpq   4057d6 <gsi_is_network_tcp_server_init+0x31d>
    }

    // Reuse local address
    int i_reuse_addr = GSI_IS_TRUE;
  405667:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%rbp)
    if(0 < setsockopt(p_this->i_listen_fd, SOL_SOCKET, SO_REUSEADDR, &i_reuse_addr, sizeof(int)))
  40566e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405672:	8b 40 18             	mov    0x18(%rax),%eax
  405675:	48 8d 55 e4          	lea    -0x1c(%rbp),%rdx
  405679:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  40567f:	48 89 d1             	mov    %rdx,%rcx
  405682:	ba 02 00 00 00       	mov    $0x2,%edx
  405687:	be 01 00 00 00       	mov    $0x1,%esi
  40568c:	89 c7                	mov    %eax,%edi
  40568e:	e8 2d bf ff ff       	callq  4015c0 <setsockopt@plt>
  405693:	85 c0                	test   %eax,%eax
  405695:	7e 41                	jle    4056d8 <gsi_is_network_tcp_server_init+0x21f>
	{
		LOG_ERROR("cannot set socket options");
  405697:	b8 00 00 00 00       	mov    $0x0,%eax
  40569c:	e8 3b 12 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4056a1:	48 89 c3             	mov    %rax,%rbx
  4056a4:	b8 00 00 00 00       	mov    $0x0,%eax
  4056a9:	e8 a9 0f 00 00       	callq  406657 <gsi_get_saved_file>
  4056ae:	41 b8 2a 01 00 00    	mov    $0x12a,%r8d
  4056b4:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4056b9:	48 89 da             	mov    %rbx,%rdx
  4056bc:	be 20 91 40 00       	mov    $0x409120,%esi
  4056c1:	48 89 c7             	mov    %rax,%rdi
  4056c4:	b8 00 00 00 00       	mov    $0x0,%eax
  4056c9:	e8 f2 0f 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  4056ce:	b8 01 00 00 00       	mov    $0x1,%eax
  4056d3:	e9 fe 00 00 00       	jmpq   4057d6 <gsi_is_network_tcp_server_init+0x31d>
	}

    // Bind the socket fd to specific address
    if (0 > bind(p_this->i_listen_fd, (struct sockaddr*)(&p_this->serv_addr), sizeof(struct sockaddr)))
  4056d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4056dc:	48 8d 48 2c          	lea    0x2c(%rax),%rcx
  4056e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4056e4:	8b 40 18             	mov    0x18(%rax),%eax
  4056e7:	ba 10 00 00 00       	mov    $0x10,%edx
  4056ec:	48 89 ce             	mov    %rcx,%rsi
  4056ef:	89 c7                	mov    %eax,%edi
  4056f1:	e8 3a c1 ff ff       	callq  401830 <bind@plt>
  4056f6:	85 c0                	test   %eax,%eax
  4056f8:	79 41                	jns    40573b <gsi_is_network_tcp_server_init+0x282>
    {
    	LOG_ERROR("bind failed");
  4056fa:	b8 00 00 00 00       	mov    $0x0,%eax
  4056ff:	e8 d8 11 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405704:	48 89 c3             	mov    %rax,%rbx
  405707:	b8 00 00 00 00       	mov    $0x0,%eax
  40570c:	e8 46 0f 00 00       	callq  406657 <gsi_get_saved_file>
  405711:	41 b8 31 01 00 00    	mov    $0x131,%r8d
  405717:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40571c:	48 89 da             	mov    %rbx,%rdx
  40571f:	be 60 91 40 00       	mov    $0x409160,%esi
  405724:	48 89 c7             	mov    %rax,%rdi
  405727:	b8 00 00 00 00       	mov    $0x0,%eax
  40572c:	e8 8f 0f 00 00       	callq  4066c0 <gsi_is_write_to_log>
    	return GSI_NET_RC_ERROR;
  405731:	b8 01 00 00 00       	mov    $0x1,%eax
  405736:	e9 9b 00 00 00       	jmpq   4057d6 <gsi_is_network_tcp_server_init+0x31d>
    }

    // Set socket to listen for connection requests
    if (0 > listen(p_this->i_listen_fd, GSI_IS_MAX_LISTEN))
  40573b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40573f:	8b 40 18             	mov    0x18(%rax),%eax
  405742:	be 0a 00 00 00       	mov    $0xa,%esi
  405747:	89 c7                	mov    %eax,%edi
  405749:	e8 b2 c0 ff ff       	callq  401800 <listen@plt>
  40574e:	85 c0                	test   %eax,%eax
  405750:	79 3e                	jns    405790 <gsi_is_network_tcp_server_init+0x2d7>
    {
    	LOG_ERROR("listen failed");
  405752:	b8 00 00 00 00       	mov    $0x0,%eax
  405757:	e8 80 11 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40575c:	48 89 c3             	mov    %rax,%rbx
  40575f:	b8 00 00 00 00       	mov    $0x0,%eax
  405764:	e8 ee 0e 00 00       	callq  406657 <gsi_get_saved_file>
  405769:	41 b8 38 01 00 00    	mov    $0x138,%r8d
  40576f:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405774:	48 89 da             	mov    %rbx,%rdx
  405777:	be 90 91 40 00       	mov    $0x409190,%esi
  40577c:	48 89 c7             	mov    %rax,%rdi
  40577f:	b8 00 00 00 00       	mov    $0x0,%eax
  405784:	e8 37 0f 00 00       	callq  4066c0 <gsi_is_write_to_log>
    	return GSI_NET_RC_ERROR;
  405789:	b8 01 00 00 00       	mov    $0x1,%eax
  40578e:	eb 46                	jmp    4057d6 <gsi_is_network_tcp_server_init+0x31d>
    }

    LOG_INFO("server is listening on port %d", p_this->ui_port);
  405790:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405794:	8b 58 28             	mov    0x28(%rax),%ebx
  405797:	b8 00 00 00 00       	mov    $0x0,%eax
  40579c:	e8 3b 11 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4057a1:	49 89 c4             	mov    %rax,%r12
  4057a4:	b8 00 00 00 00       	mov    $0x0,%eax
  4057a9:	e8 a9 0e 00 00       	callq  406657 <gsi_get_saved_file>
  4057ae:	41 89 d9             	mov    %ebx,%r9d
  4057b1:	41 b8 3c 01 00 00    	mov    $0x13c,%r8d
  4057b7:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4057bc:	4c 89 e2             	mov    %r12,%rdx
  4057bf:	be c0 91 40 00       	mov    $0x4091c0,%esi
  4057c4:	48 89 c7             	mov    %rax,%rdi
  4057c7:	b8 00 00 00 00       	mov    $0x0,%eax
  4057cc:	e8 ef 0e 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  4057d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4057d6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  4057da:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  4057e1:	00 00 
  4057e3:	74 05                	je     4057ea <gsi_is_network_tcp_server_init+0x331>
  4057e5:	e8 46 be ff ff       	callq  401630 <__stack_chk_fail@plt>
  4057ea:	48 83 c4 20          	add    $0x20,%rsp
  4057ee:	5b                   	pop    %rbx
  4057ef:	41 5c                	pop    %r12
  4057f1:	5d                   	pop    %rbp
  4057f2:	c3                   	retq   

00000000004057f3 <gsi_is_network_tcp_server_poll>:
	 * Parameter:   [in] struct gsi_net_tcp *p_this - pointer to structure TCP Server
	 * Return:		Success - GSI_NET_RC_HASDATA *OR* GSI_NET_RC_SUCCESS(non empty buffer)
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_server_poll(struct gsi_net_tcp *p_this)
{
  4057f3:	55                   	push   %rbp
  4057f4:	48 89 e5             	mov    %rsp,%rbp
  4057f7:	41 54                	push   %r12
  4057f9:	53                   	push   %rbx
  4057fa:	48 83 ec 20          	sub    $0x20,%rsp
  4057fe:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	// Check input validation
	if (NULL == p_this)
  405802:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  405807:	75 41                	jne    40584a <gsi_is_network_tcp_server_poll+0x57>
	{
		LOG_ERROR("invalid argument!");
  405809:	b8 00 00 00 00       	mov    $0x0,%eax
  40580e:	e8 c9 10 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405813:	48 89 c3             	mov    %rax,%rbx
  405816:	b8 00 00 00 00       	mov    $0x0,%eax
  40581b:	e8 37 0e 00 00       	callq  406657 <gsi_get_saved_file>
  405820:	41 b8 54 01 00 00    	mov    $0x154,%r8d
  405826:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40582b:	48 89 da             	mov    %rbx,%rdx
  40582e:	be 48 8d 40 00       	mov    $0x408d48,%esi
  405833:	48 89 c7             	mov    %rax,%rdi
  405836:	b8 00 00 00 00       	mov    $0x0,%eax
  40583b:	e8 80 0e 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405840:	b8 01 00 00 00       	mov    $0x1,%eax
  405845:	e9 15 02 00 00       	jmpq   405a5f <gsi_is_network_tcp_server_poll+0x26c>
	}

	// Setup POLL for Listen FD (Server connection requests)
	p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].fd 	= p_this->i_listen_fd;
  40584a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40584e:	8b 50 18             	mov    0x18(%rax),%edx
  405851:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405855:	89 50 3c             	mov    %edx,0x3c(%rax)
	p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].events = POLLIN;
  405858:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40585c:	66 c7 40 40 01 00    	movw   $0x1,0x40(%rax)
	if (0 == p_this->i_listen_fd)
  405862:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405866:	8b 40 18             	mov    0x18(%rax),%eax
  405869:	85 c0                	test   %eax,%eax
  40586b:	75 41                	jne    4058ae <gsi_is_network_tcp_server_poll+0xbb>
	{
		LOG_ERROR("server not listen");
  40586d:	b8 00 00 00 00       	mov    $0x0,%eax
  405872:	e8 65 10 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405877:	48 89 c3             	mov    %rax,%rbx
  40587a:	b8 00 00 00 00       	mov    $0x0,%eax
  40587f:	e8 d3 0d 00 00       	callq  406657 <gsi_get_saved_file>
  405884:	41 b8 5d 01 00 00    	mov    $0x15d,%r8d
  40588a:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40588f:	48 89 da             	mov    %rbx,%rdx
  405892:	be 00 92 40 00       	mov    $0x409200,%esi
  405897:	48 89 c7             	mov    %rax,%rdi
  40589a:	b8 00 00 00 00       	mov    $0x0,%eax
  40589f:	e8 1c 0e 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  4058a4:	b8 01 00 00 00       	mov    $0x1,%eax
  4058a9:	e9 b1 01 00 00       	jmpq   405a5f <gsi_is_network_tcp_server_poll+0x26c>
	}

	// If Already connected, Setup POLL for Connection FD as well
	if (0 < p_this->i_connection_fd)
  4058ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4058b2:	8b 40 1c             	mov    0x1c(%rax),%eax
  4058b5:	85 c0                	test   %eax,%eax
  4058b7:	7e 18                	jle    4058d1 <gsi_is_network_tcp_server_poll+0xde>
	{
		p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].fd	 = p_this->i_connection_fd;
  4058b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4058bd:	8b 50 1c             	mov    0x1c(%rax),%edx
  4058c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4058c4:	89 50 44             	mov    %edx,0x44(%rax)
		p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].events = POLLIN;
  4058c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4058cb:	66 c7 40 48 01 00    	movw   $0x1,0x48(%rax)
	}

	// Start poll to alert ready fds
	int i_rc = poll(p_this->pfds, GSI_IS_MAX_CONN, GSI_IS_POLL_DELAY_MSECS);
  4058d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4058d5:	48 83 c0 3c          	add    $0x3c,%rax
  4058d9:	ba 10 27 00 00       	mov    $0x2710,%edx
  4058de:	be 02 00 00 00       	mov    $0x2,%esi
  4058e3:	48 89 c7             	mov    %rax,%rdi
  4058e6:	e8 35 bf ff ff       	callq  401820 <poll@plt>
  4058eb:	89 45 ec             	mov    %eax,-0x14(%rbp)

	switch (i_rc)
  4058ee:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4058f1:	83 f8 08             	cmp    $0x8,%eax
  4058f4:	75 41                	jne    405937 <gsi_is_network_tcp_server_poll+0x144>
	{
		case POLLERR:
			LOG_ERROR("poll error!");
  4058f6:	b8 00 00 00 00       	mov    $0x0,%eax
  4058fb:	e8 dc 0f 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405900:	48 89 c3             	mov    %rax,%rbx
  405903:	b8 00 00 00 00       	mov    $0x0,%eax
  405908:	e8 4a 0d 00 00       	callq  406657 <gsi_get_saved_file>
  40590d:	41 b8 6e 01 00 00    	mov    $0x16e,%r8d
  405913:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405918:	48 89 da             	mov    %rbx,%rdx
  40591b:	be 38 92 40 00       	mov    $0x409238,%esi
  405920:	48 89 c7             	mov    %rax,%rdi
  405923:	b8 00 00 00 00       	mov    $0x0,%eax
  405928:	e8 93 0d 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_NET_RC_ERROR;
  40592d:	b8 01 00 00 00       	mov    $0x1,%eax
  405932:	e9 28 01 00 00       	jmpq   405a5f <gsi_is_network_tcp_server_poll+0x26c>
		default:
			if (p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].revents & POLLIN)
  405937:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40593b:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  40593f:	98                   	cwtl   
  405940:	83 e0 01             	and    $0x1,%eax
  405943:	85 c0                	test   %eax,%eax
  405945:	0f 84 ae 00 00 00    	je     4059f9 <gsi_is_network_tcp_server_poll+0x206>
			{
				// Accept New Connection
				p_this->i_connection_fd = accept(p_this->i_listen_fd, (struct sockaddr*)NULL, NULL);
  40594b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40594f:	8b 40 18             	mov    0x18(%rax),%eax
  405952:	ba 00 00 00 00       	mov    $0x0,%edx
  405957:	be 00 00 00 00       	mov    $0x0,%esi
  40595c:	89 c7                	mov    %eax,%edi
  40595e:	e8 3d bf ff ff       	callq  4018a0 <accept@plt>
  405963:	89 c2                	mov    %eax,%edx
  405965:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405969:	89 50 1c             	mov    %edx,0x1c(%rax)
				if (0 > p_this->i_connection_fd)
  40596c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405970:	8b 40 1c             	mov    0x1c(%rax),%eax
  405973:	85 c0                	test   %eax,%eax
  405975:	79 41                	jns    4059b8 <gsi_is_network_tcp_server_poll+0x1c5>
				{
					LOG_ERROR("accept failed!");
  405977:	b8 00 00 00 00       	mov    $0x0,%eax
  40597c:	e8 5b 0f 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405981:	48 89 c3             	mov    %rax,%rbx
  405984:	b8 00 00 00 00       	mov    $0x0,%eax
  405989:	e8 c9 0c 00 00       	callq  406657 <gsi_get_saved_file>
  40598e:	41 b8 77 01 00 00    	mov    $0x177,%r8d
  405994:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405999:	48 89 da             	mov    %rbx,%rdx
  40599c:	be 68 92 40 00       	mov    $0x409268,%esi
  4059a1:	48 89 c7             	mov    %rax,%rdi
  4059a4:	b8 00 00 00 00       	mov    $0x0,%eax
  4059a9:	e8 12 0d 00 00       	callq  4066c0 <gsi_is_write_to_log>
					return GSI_NET_RC_ERROR;
  4059ae:	b8 01 00 00 00       	mov    $0x1,%eax
  4059b3:	e9 a7 00 00 00       	jmpq   405a5f <gsi_is_network_tcp_server_poll+0x26c>
				}
				LOG_INFO("new connection accepted on port %d", p_this->ui_port);
  4059b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4059bc:	8b 58 28             	mov    0x28(%rax),%ebx
  4059bf:	b8 00 00 00 00       	mov    $0x0,%eax
  4059c4:	e8 13 0f 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4059c9:	49 89 c4             	mov    %rax,%r12
  4059cc:	b8 00 00 00 00       	mov    $0x0,%eax
  4059d1:	e8 81 0c 00 00       	callq  406657 <gsi_get_saved_file>
  4059d6:	41 89 d9             	mov    %ebx,%r9d
  4059d9:	41 b8 7a 01 00 00    	mov    $0x17a,%r8d
  4059df:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4059e4:	4c 89 e2             	mov    %r12,%rdx
  4059e7:	be 98 92 40 00       	mov    $0x409298,%esi
  4059ec:	48 89 c7             	mov    %rax,%rdi
  4059ef:	b8 00 00 00 00       	mov    $0x0,%eax
  4059f4:	e8 c7 0c 00 00       	callq  4066c0 <gsi_is_write_to_log>
			}

			if (p_this->i_connection_fd && (p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].revents & POLLIN))
  4059f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4059fd:	8b 40 1c             	mov    0x1c(%rax),%eax
  405a00:	85 c0                	test   %eax,%eax
  405a02:	74 1e                	je     405a22 <gsi_is_network_tcp_server_poll+0x22f>
  405a04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405a08:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  405a0c:	98                   	cwtl   
  405a0d:	83 e0 01             	and    $0x1,%eax
  405a10:	85 c0                	test   %eax,%eax
  405a12:	74 0e                	je     405a22 <gsi_is_network_tcp_server_poll+0x22f>
			{
				// Get Input from Channel
				return read_check_heartbeat(p_this);
  405a14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405a18:	48 89 c7             	mov    %rax,%rdi
  405a1b:	e8 ea 04 00 00       	callq  405f0a <read_check_heartbeat>
  405a20:	eb 3d                	jmp    405a5f <gsi_is_network_tcp_server_poll+0x26c>
			}

			break;
  405a22:	90                   	nop
	}

	LOG_INFO("server poll successfully");
  405a23:	b8 00 00 00 00       	mov    $0x0,%eax
  405a28:	e8 af 0e 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405a2d:	48 89 c3             	mov    %rax,%rbx
  405a30:	b8 00 00 00 00       	mov    $0x0,%eax
  405a35:	e8 1d 0c 00 00       	callq  406657 <gsi_get_saved_file>
  405a3a:	41 b8 86 01 00 00    	mov    $0x186,%r8d
  405a40:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405a45:	48 89 da             	mov    %rbx,%rdx
  405a48:	be e0 92 40 00       	mov    $0x4092e0,%esi
  405a4d:	48 89 c7             	mov    %rax,%rdi
  405a50:	b8 00 00 00 00       	mov    $0x0,%eax
  405a55:	e8 66 0c 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  405a5a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  405a5f:	48 83 c4 20          	add    $0x20,%rsp
  405a63:	5b                   	pop    %rbx
  405a64:	41 5c                	pop    %r12
  405a66:	5d                   	pop    %rbp
  405a67:	c3                   	retq   

0000000000405a68 <gsi_is_network_tcp_server_read>:
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure	- GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_server_read(struct gsi_net_tcp *p_this,
														 	   char* s_msg)
{
  405a68:	55                   	push   %rbp
  405a69:	48 89 e5             	mov    %rsp,%rbp
  405a6c:	53                   	push   %rbx
  405a6d:	48 83 ec 28          	sub    $0x28,%rsp
  405a71:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  405a75:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int i_count = 0;
  405a79:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	struct gsi_cs_tcp_message *p_msg = (struct gsi_cs_tcp_message *)s_msg;
  405a80:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  405a84:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// Check input validation
	if ((NULL == p_this) || (NULL == p_msg))
  405a88:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  405a8d:	74 07                	je     405a96 <gsi_is_network_tcp_server_read+0x2e>
  405a8f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  405a94:	75 41                	jne    405ad7 <gsi_is_network_tcp_server_read+0x6f>
	{
		LOG_ERROR("invalid arguments!");
  405a96:	b8 00 00 00 00       	mov    $0x0,%eax
  405a9b:	e8 3c 0e 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405aa0:	48 89 c3             	mov    %rax,%rbx
  405aa3:	b8 00 00 00 00       	mov    $0x0,%eax
  405aa8:	e8 aa 0b 00 00       	callq  406657 <gsi_get_saved_file>
  405aad:	41 b8 9d 01 00 00    	mov    $0x19d,%r8d
  405ab3:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405ab8:	48 89 da             	mov    %rbx,%rdx
  405abb:	be f8 8d 40 00       	mov    $0x408df8,%esi
  405ac0:	48 89 c7             	mov    %rax,%rdi
  405ac3:	b8 00 00 00 00       	mov    $0x0,%eax
  405ac8:	e8 f3 0b 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405acd:	b8 01 00 00 00       	mov    $0x1,%eax
  405ad2:	e9 8c 01 00 00       	jmpq   405c63 <gsi_is_network_tcp_server_read+0x1fb>
	}

	// Reset p_msg buffer
	memset(p_msg, 0, sizeof(struct gsi_cs_tcp_message));
  405ad7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405adb:	ba 18 00 00 00       	mov    $0x18,%edx
  405ae0:	be 00 00 00 00       	mov    $0x0,%esi
  405ae5:	48 89 c7             	mov    %rax,%rdi
  405ae8:	e8 c3 bb ff ff       	callq  4016b0 <memset@plt>

	// Check if buffer is empty
	if (NULL == p_this->s_last_msg)
  405aed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405af1:	48 8b 40 10          	mov    0x10(%rax),%rax
  405af5:	48 85 c0             	test   %rax,%rax
  405af8:	75 52                	jne    405b4c <gsi_is_network_tcp_server_read+0xe4>
	{
		if (GSI_NET_RC_ERROR == read_check_heartbeat(p_this))
  405afa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405afe:	48 89 c7             	mov    %rax,%rdi
  405b01:	e8 04 04 00 00       	callq  405f0a <read_check_heartbeat>
  405b06:	83 f8 01             	cmp    $0x1,%eax
  405b09:	75 41                	jne    405b4c <gsi_is_network_tcp_server_read+0xe4>
		{
			LOG_ERROR("heartbeat failed");
  405b0b:	b8 00 00 00 00       	mov    $0x0,%eax
  405b10:	e8 c7 0d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405b15:	48 89 c3             	mov    %rax,%rbx
  405b18:	b8 00 00 00 00       	mov    $0x0,%eax
  405b1d:	e8 35 0b 00 00       	callq  406657 <gsi_get_saved_file>
  405b22:	41 b8 a9 01 00 00    	mov    $0x1a9,%r8d
  405b28:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405b2d:	48 89 da             	mov    %rbx,%rdx
  405b30:	be 20 93 40 00       	mov    $0x409320,%esi
  405b35:	48 89 c7             	mov    %rax,%rdi
  405b38:	b8 00 00 00 00       	mov    $0x0,%eax
  405b3d:	e8 7e 0b 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_NET_RC_ERROR;
  405b42:	b8 01 00 00 00       	mov    $0x1,%eax
  405b47:	e9 17 01 00 00       	jmpq   405c63 <gsi_is_network_tcp_server_read+0x1fb>
		}
	}

	// Read the data from the buffer of last message
	i_count = strlen(p_this->s_last_msg) + 1;
  405b4c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405b50:	48 8b 40 10          	mov    0x10(%rax),%rax
  405b54:	48 89 c7             	mov    %rax,%rdi
  405b57:	e8 c4 ba ff ff       	callq  401620 <strlen@plt>
  405b5c:	83 c0 01             	add    $0x1,%eax
  405b5f:	89 45 e4             	mov    %eax,-0x1c(%rbp)

	// Allocate memory for s_message buffer
	p_msg->s_message = (char *)malloc(i_count);
  405b62:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  405b65:	48 98                	cltq   
  405b67:	48 89 c7             	mov    %rax,%rdi
  405b6a:	e8 71 bc ff ff       	callq  4017e0 <malloc@plt>
  405b6f:	48 89 c2             	mov    %rax,%rdx
  405b72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405b76:	48 89 50 10          	mov    %rdx,0x10(%rax)
	if (NULL == p_msg->s_message)
  405b7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405b7e:	48 8b 40 10          	mov    0x10(%rax),%rax
  405b82:	48 85 c0             	test   %rax,%rax
  405b85:	75 41                	jne    405bc8 <gsi_is_network_tcp_server_read+0x160>
	{
		LOG_ERROR("memory allocation for s_message failed");
  405b87:	b8 00 00 00 00       	mov    $0x0,%eax
  405b8c:	e8 4b 0d 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405b91:	48 89 c3             	mov    %rax,%rbx
  405b94:	b8 00 00 00 00       	mov    $0x0,%eax
  405b99:	e8 b9 0a 00 00       	callq  406657 <gsi_get_saved_file>
  405b9e:	41 b8 b5 01 00 00    	mov    $0x1b5,%r8d
  405ba4:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405ba9:	48 89 da             	mov    %rbx,%rdx
  405bac:	be 58 93 40 00       	mov    $0x409358,%esi
  405bb1:	48 89 c7             	mov    %rax,%rdi
  405bb4:	b8 00 00 00 00       	mov    $0x0,%eax
  405bb9:	e8 02 0b 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405bbe:	b8 01 00 00 00       	mov    $0x1,%eax
  405bc3:	e9 9b 00 00 00       	jmpq   405c63 <gsi_is_network_tcp_server_read+0x1fb>
	}

	// Copy the message content
	memcpy(p_msg->s_message, p_this->s_last_msg, i_count);
  405bc8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  405bcb:	48 63 d0             	movslq %eax,%rdx
  405bce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405bd2:	48 8b 48 10          	mov    0x10(%rax),%rcx
  405bd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405bda:	48 8b 40 10          	mov    0x10(%rax),%rax
  405bde:	48 89 ce             	mov    %rcx,%rsi
  405be1:	48 89 c7             	mov    %rax,%rdi
  405be4:	e8 97 bb ff ff       	callq  401780 <memcpy@plt>

	// Set message length
	p_msg->ui_len = i_count;
  405be9:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  405bec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405bf0:	89 50 08             	mov    %edx,0x8(%rax)

	// Set message type
	p_msg->e_type_msg = GSI_REGULAR_MSG;
  405bf3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405bf7:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)

	// Copy the content of ui_port
	p_msg->ui_port = p_this->ui_port;
  405bfe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405c02:	8b 50 28             	mov    0x28(%rax),%edx
  405c05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405c09:	89 10                	mov    %edx,(%rax)

	// Reset the last message buffer for the next message
	free(p_this->s_last_msg);
  405c0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405c0f:	48 8b 40 10          	mov    0x10(%rax),%rax
  405c13:	48 89 c7             	mov    %rax,%rdi
  405c16:	e8 35 b9 ff ff       	callq  401550 <free@plt>
	p_this->s_last_msg = NULL;
  405c1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405c1f:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  405c26:	00 

	LOG_INFO("server read new message");
  405c27:	b8 00 00 00 00       	mov    $0x0,%eax
  405c2c:	e8 ab 0c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405c31:	48 89 c3             	mov    %rax,%rbx
  405c34:	b8 00 00 00 00       	mov    $0x0,%eax
  405c39:	e8 19 0a 00 00       	callq  406657 <gsi_get_saved_file>
  405c3e:	41 b8 c9 01 00 00    	mov    $0x1c9,%r8d
  405c44:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405c49:	48 89 da             	mov    %rbx,%rdx
  405c4c:	be a0 93 40 00       	mov    $0x4093a0,%esi
  405c51:	48 89 c7             	mov    %rax,%rdi
  405c54:	b8 00 00 00 00       	mov    $0x0,%eax
  405c59:	e8 62 0a 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  405c5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  405c63:	48 83 c4 28          	add    $0x28,%rsp
  405c67:	5b                   	pop    %rbx
  405c68:	5d                   	pop    %rbp
  405c69:	c3                   	retq   

0000000000405c6a <gsi_is_network_tcp_server_cleanup>:
	 * Parameter:   [in] struct gsi_net_tcp *p_this - pointer to structure TCP Server
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_server_cleanup(struct gsi_net_tcp *p_this)
{
  405c6a:	55                   	push   %rbp
  405c6b:	48 89 e5             	mov    %rsp,%rbp
  405c6e:	53                   	push   %rbx
  405c6f:	48 83 ec 18          	sub    $0x18,%rsp
  405c73:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == p_this)
  405c77:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  405c7c:	75 41                	jne    405cbf <gsi_is_network_tcp_server_cleanup+0x55>
	{
		LOG_ERROR("invalid argument!");
  405c7e:	b8 00 00 00 00       	mov    $0x0,%eax
  405c83:	e8 54 0c 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405c88:	48 89 c3             	mov    %rax,%rbx
  405c8b:	b8 00 00 00 00       	mov    $0x0,%eax
  405c90:	e8 c2 09 00 00       	callq  406657 <gsi_get_saved_file>
  405c95:	41 b8 d9 01 00 00    	mov    $0x1d9,%r8d
  405c9b:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405ca0:	48 89 da             	mov    %rbx,%rdx
  405ca3:	be 48 8d 40 00       	mov    $0x408d48,%esi
  405ca8:	48 89 c7             	mov    %rax,%rdi
  405cab:	b8 00 00 00 00       	mov    $0x0,%eax
  405cb0:	e8 0b 0a 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405cb5:	b8 01 00 00 00       	mov    $0x1,%eax
  405cba:	e9 14 01 00 00       	jmpq   405dd3 <gsi_is_network_tcp_server_cleanup+0x169>
	}

	// Close connection socket (if open)
	if (p_this->i_connection_fd)
  405cbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405cc3:	8b 40 1c             	mov    0x1c(%rax),%eax
  405cc6:	85 c0                	test   %eax,%eax
  405cc8:	74 68                	je     405d32 <gsi_is_network_tcp_server_cleanup+0xc8>
	{
		if (0 > close(p_this->i_connection_fd))
  405cca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405cce:	8b 40 1c             	mov    0x1c(%rax),%eax
  405cd1:	89 c7                	mov    %eax,%edi
  405cd3:	e8 e8 b9 ff ff       	callq  4016c0 <close@plt>
  405cd8:	85 c0                	test   %eax,%eax
  405cda:	79 41                	jns    405d1d <gsi_is_network_tcp_server_cleanup+0xb3>
		{
			LOG_ERROR("close connection fd failed");
  405cdc:	b8 00 00 00 00       	mov    $0x0,%eax
  405ce1:	e8 f6 0b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405ce6:	48 89 c3             	mov    %rax,%rbx
  405ce9:	b8 00 00 00 00       	mov    $0x0,%eax
  405cee:	e8 64 09 00 00       	callq  406657 <gsi_get_saved_file>
  405cf3:	41 b8 e2 01 00 00    	mov    $0x1e2,%r8d
  405cf9:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405cfe:	48 89 da             	mov    %rbx,%rdx
  405d01:	be d8 93 40 00       	mov    $0x4093d8,%esi
  405d06:	48 89 c7             	mov    %rax,%rdi
  405d09:	b8 00 00 00 00       	mov    $0x0,%eax
  405d0e:	e8 ad 09 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_NET_RC_ERROR;
  405d13:	b8 01 00 00 00       	mov    $0x1,%eax
  405d18:	e9 b6 00 00 00       	jmpq   405dd3 <gsi_is_network_tcp_server_cleanup+0x169>
		}

		// Reset poll_fds array of connection type
		p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].fd	 = 0;
  405d1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405d21:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
		p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].events = 0;
  405d28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405d2c:	66 c7 40 48 00 00    	movw   $0x0,0x48(%rax)
	}

	// Close listen socket
	if (0 > close(p_this->i_listen_fd))
  405d32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405d36:	8b 40 18             	mov    0x18(%rax),%eax
  405d39:	89 c7                	mov    %eax,%edi
  405d3b:	e8 80 b9 ff ff       	callq  4016c0 <close@plt>
  405d40:	85 c0                	test   %eax,%eax
  405d42:	79 3e                	jns    405d82 <gsi_is_network_tcp_server_cleanup+0x118>
	{
		LOG_ERROR("close listen fd failed");
  405d44:	b8 00 00 00 00       	mov    $0x0,%eax
  405d49:	e8 8e 0b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405d4e:	48 89 c3             	mov    %rax,%rbx
  405d51:	b8 00 00 00 00       	mov    $0x0,%eax
  405d56:	e8 fc 08 00 00       	callq  406657 <gsi_get_saved_file>
  405d5b:	41 b8 ee 01 00 00    	mov    $0x1ee,%r8d
  405d61:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405d66:	48 89 da             	mov    %rbx,%rdx
  405d69:	be 18 94 40 00       	mov    $0x409418,%esi
  405d6e:	48 89 c7             	mov    %rax,%rdi
  405d71:	b8 00 00 00 00       	mov    $0x0,%eax
  405d76:	e8 45 09 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405d7b:	b8 01 00 00 00       	mov    $0x1,%eax
  405d80:	eb 51                	jmp    405dd3 <gsi_is_network_tcp_server_cleanup+0x169>
	}

	// Reset poll_fds array of listen type
	p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].fd		= 0;
  405d82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405d86:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].events	= 0;
  405d8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405d91:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)

	LOG_INFO("cleanup successfully\n");
  405d97:	b8 00 00 00 00       	mov    $0x0,%eax
  405d9c:	e8 3b 0b 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405da1:	48 89 c3             	mov    %rax,%rbx
  405da4:	b8 00 00 00 00       	mov    $0x0,%eax
  405da9:	e8 a9 08 00 00       	callq  406657 <gsi_get_saved_file>
  405dae:	41 b8 f6 01 00 00    	mov    $0x1f6,%r8d
  405db4:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405db9:	48 89 da             	mov    %rbx,%rdx
  405dbc:	be 50 94 40 00       	mov    $0x409450,%esi
  405dc1:	48 89 c7             	mov    %rax,%rdi
  405dc4:	b8 00 00 00 00       	mov    $0x0,%eax
  405dc9:	e8 f2 08 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  405dce:	b8 00 00 00 00       	mov    $0x0,%eax
}
  405dd3:	48 83 c4 18          	add    $0x18,%rsp
  405dd7:	5b                   	pop    %rbx
  405dd8:	5d                   	pop    %rbp
  405dd9:	c3                   	retq   

0000000000405dda <set_address_parameters>:
	 * Parameter:   [in] char* s_tcp_addr - address to connect to
	 * Return:		Success - char* - pointer to port as string
	 * 				Failure - NULL
#############################################################################*/
static char* set_address_parameters(struct gsi_net_tcp *p_this, char* s_tcp_addr)
{
  405dda:	55                   	push   %rbp
  405ddb:	48 89 e5             	mov    %rsp,%rbp
  405dde:	53                   	push   %rbx
  405ddf:	48 83 ec 28          	sub    $0x28,%rsp
  405de3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  405de7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Check input validation
	if ((NULL == p_this) || (NULL == s_tcp_addr))
  405deb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  405df0:	74 07                	je     405df9 <set_address_parameters+0x1f>
  405df2:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  405df7:	75 41                	jne    405e3a <set_address_parameters+0x60>
	{
		LOG_ERROR("invalid arguments!");
  405df9:	b8 00 00 00 00       	mov    $0x0,%eax
  405dfe:	e8 d9 0a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405e03:	48 89 c3             	mov    %rax,%rbx
  405e06:	b8 00 00 00 00       	mov    $0x0,%eax
  405e0b:	e8 47 08 00 00       	callq  406657 <gsi_get_saved_file>
  405e10:	41 b8 0a 02 00 00    	mov    $0x20a,%r8d
  405e16:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405e1b:	48 89 da             	mov    %rbx,%rdx
  405e1e:	be f8 8d 40 00       	mov    $0x408df8,%esi
  405e23:	48 89 c7             	mov    %rax,%rdi
  405e26:	b8 00 00 00 00       	mov    $0x0,%eax
  405e2b:	e8 90 08 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  405e30:	b8 00 00 00 00       	mov    $0x0,%eax
  405e35:	e9 c9 00 00 00       	jmpq   405f03 <set_address_parameters+0x129>
	}

	// Update the field in the pointer
	p_this->s_tcp_addr = s_tcp_addr;
  405e3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405e3e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  405e42:	48 89 10             	mov    %rdx,(%rax)

	// Find the ':' character inside the string
	char *s_port = strchr(p_this->s_tcp_addr, ':');
  405e45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405e49:	48 8b 00             	mov    (%rax),%rax
  405e4c:	be 3a 00 00 00       	mov    $0x3a,%esi
  405e51:	48 89 c7             	mov    %rax,%rdi
  405e54:	e8 17 b8 ff ff       	callq  401670 <strchr@plt>
  405e59:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == s_port)
  405e5d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  405e62:	75 3e                	jne    405ea2 <set_address_parameters+0xc8>
	{
		LOG_ERROR("The s_tcp_addr string doesn't contain ':'");
  405e64:	b8 00 00 00 00       	mov    $0x0,%eax
  405e69:	e8 6e 0a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405e6e:	48 89 c3             	mov    %rax,%rbx
  405e71:	b8 00 00 00 00       	mov    $0x0,%eax
  405e76:	e8 dc 07 00 00       	callq  406657 <gsi_get_saved_file>
  405e7b:	41 b8 15 02 00 00    	mov    $0x215,%r8d
  405e81:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405e86:	48 89 da             	mov    %rbx,%rdx
  405e89:	be 88 94 40 00       	mov    $0x409488,%esi
  405e8e:	48 89 c7             	mov    %rax,%rdi
  405e91:	b8 00 00 00 00       	mov    $0x0,%eax
  405e96:	e8 25 08 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  405e9b:	b8 00 00 00 00       	mov    $0x0,%eax
  405ea0:	eb 61                	jmp    405f03 <set_address_parameters+0x129>
	}

	// Split Connect String <host_ip>:<port number> to Host IP Addr and Port Number
	*s_port = '\0';
  405ea2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  405ea6:	c6 00 00             	movb   $0x0,(%rax)
	++s_port;
  405ea9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)

	// Clear the Serv Addr (struct sockaddr_in)
	memset(&p_this->serv_addr, 0, sizeof(p_this->serv_addr));
  405eae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405eb2:	48 83 c0 2c          	add    $0x2c,%rax
  405eb6:	ba 10 00 00 00       	mov    $0x10,%edx
  405ebb:	be 00 00 00 00       	mov    $0x0,%esi
  405ec0:	48 89 c7             	mov    %rax,%rdi
  405ec3:	e8 e8 b7 ff ff       	callq  4016b0 <memset@plt>

	LOG_INFO("set address parameters successfully");
  405ec8:	b8 00 00 00 00       	mov    $0x0,%eax
  405ecd:	e8 0a 0a 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405ed2:	48 89 c3             	mov    %rax,%rbx
  405ed5:	b8 00 00 00 00       	mov    $0x0,%eax
  405eda:	e8 78 07 00 00       	callq  406657 <gsi_get_saved_file>
  405edf:	41 b8 20 02 00 00    	mov    $0x220,%r8d
  405ee5:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405eea:	48 89 da             	mov    %rbx,%rdx
  405eed:	be d8 94 40 00       	mov    $0x4094d8,%esi
  405ef2:	48 89 c7             	mov    %rax,%rdi
  405ef5:	b8 00 00 00 00       	mov    $0x0,%eax
  405efa:	e8 c1 07 00 00       	callq  4066c0 <gsi_is_write_to_log>
	return s_port;
  405eff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  405f03:	48 83 c4 28          	add    $0x28,%rsp
  405f07:	5b                   	pop    %rbx
  405f08:	5d                   	pop    %rbp
  405f09:	c3                   	retq   

0000000000405f0a <read_check_heartbeat>:
	 * Parameter:   [in] struct gsi_net_tcp *p_this - pointer to structure TCP Server
	 * Return:		Success - GSI_NET_RC_HASDATA *OR* GSI_NET_RC_SUCCESS(non empty buffer)
	 * 				Failure - GSI_NET_RC_ERROR *OR* GSI_NET_RC_CONNECTERR
#############################################################################*/
static enum gsi_is_network_return_code read_check_heartbeat(struct gsi_net_tcp *p_this)
{
  405f0a:	55                   	push   %rbp
  405f0b:	48 89 e5             	mov    %rsp,%rbp
  405f0e:	41 54                	push   %r12
  405f10:	53                   	push   %rbx
  405f11:	48 83 ec 40          	sub    $0x40,%rsp
  405f15:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  405f19:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  405f20:	00 00 
  405f22:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  405f26:	31 c0                	xor    %eax,%eax
	struct gsi_cs_tcp_message msg;

	// Check input validation
	if (NULL == p_this)
  405f28:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  405f2d:	75 41                	jne    405f70 <read_check_heartbeat+0x66>
	{
		LOG_ERROR("invalid argument!");
  405f2f:	b8 00 00 00 00       	mov    $0x0,%eax
  405f34:	e8 a3 09 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405f39:	48 89 c3             	mov    %rax,%rbx
  405f3c:	b8 00 00 00 00       	mov    $0x0,%eax
  405f41:	e8 11 07 00 00       	callq  406657 <gsi_get_saved_file>
  405f46:	41 b8 33 02 00 00    	mov    $0x233,%r8d
  405f4c:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405f51:	48 89 da             	mov    %rbx,%rdx
  405f54:	be 48 8d 40 00       	mov    $0x408d48,%esi
  405f59:	48 89 c7             	mov    %rax,%rdi
  405f5c:	b8 00 00 00 00       	mov    $0x0,%eax
  405f61:	e8 5a 07 00 00       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  405f66:	b8 01 00 00 00       	mov    $0x1,%eax
  405f6b:	e9 16 05 00 00       	jmpq   406486 <read_check_heartbeat+0x57c>
	}

	// Reset message
	memset(&msg, 0, sizeof(msg));
  405f70:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  405f74:	ba 18 00 00 00       	mov    $0x18,%edx
  405f79:	be 00 00 00 00       	mov    $0x0,%esi
  405f7e:	48 89 c7             	mov    %rax,%rdi
  405f81:	e8 2a b7 ff ff       	callq  4016b0 <memset@plt>

	// Check if buffer is empty
	if (NULL == p_this->s_last_msg)
  405f86:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405f8a:	48 8b 40 10          	mov    0x10(%rax),%rax
  405f8e:	48 85 c0             	test   %rax,%rax
  405f91:	0f 85 ea 04 00 00    	jne    406481 <read_check_heartbeat+0x577>
	{
		// Read part of the structure to know what is the message length
		int i_count = read(p_this->i_connection_fd, &msg, sizeof(msg) - sizeof(char *));
  405f97:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405f9b:	8b 40 1c             	mov    0x1c(%rax),%eax
  405f9e:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  405fa2:	ba 10 00 00 00       	mov    $0x10,%edx
  405fa7:	48 89 ce             	mov    %rcx,%rsi
  405faa:	89 c7                	mov    %eax,%edi
  405fac:	e8 1f b7 ff ff       	callq  4016d0 <read@plt>
  405fb1:	89 45 cc             	mov    %eax,-0x34(%rbp)
		if (0 > i_count)
  405fb4:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  405fb8:	79 41                	jns    405ffb <read_check_heartbeat+0xf1>
		{
			LOG_ERROR("read failed");
  405fba:	b8 00 00 00 00       	mov    $0x0,%eax
  405fbf:	e8 18 09 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  405fc4:	48 89 c3             	mov    %rax,%rbx
  405fc7:	b8 00 00 00 00       	mov    $0x0,%eax
  405fcc:	e8 86 06 00 00       	callq  406657 <gsi_get_saved_file>
  405fd1:	41 b8 41 02 00 00    	mov    $0x241,%r8d
  405fd7:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  405fdc:	48 89 da             	mov    %rbx,%rdx
  405fdf:	be 20 95 40 00       	mov    $0x409520,%esi
  405fe4:	48 89 c7             	mov    %rax,%rdi
  405fe7:	b8 00 00 00 00       	mov    $0x0,%eax
  405fec:	e8 cf 06 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_NET_RC_ERROR;
  405ff1:	b8 01 00 00 00       	mov    $0x1,%eax
  405ff6:	e9 8b 04 00 00       	jmpq   406486 <read_check_heartbeat+0x57c>
		}
		else if (0 < i_count)
  405ffb:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  405fff:	0f 8e 33 04 00 00    	jle    406438 <read_check_heartbeat+0x52e>
		{
			LOG_DEBUG("first read %d bytes from fd: %d", i_count, p_this->i_connection_fd);
  406005:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  406009:	8b 58 1c             	mov    0x1c(%rax),%ebx
  40600c:	b8 00 00 00 00       	mov    $0x0,%eax
  406011:	e8 c6 08 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  406016:	49 89 c4             	mov    %rax,%r12
  406019:	b8 00 00 00 00       	mov    $0x0,%eax
  40601e:	e8 34 06 00 00       	callq  406657 <gsi_get_saved_file>
  406023:	48 89 c7             	mov    %rax,%rdi
  406026:	8b 45 cc             	mov    -0x34(%rbp),%eax
  406029:	48 83 ec 08          	sub    $0x8,%rsp
  40602d:	53                   	push   %rbx
  40602e:	41 89 c1             	mov    %eax,%r9d
  406031:	41 b8 46 02 00 00    	mov    $0x246,%r8d
  406037:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40603c:	4c 89 e2             	mov    %r12,%rdx
  40603f:	be 50 95 40 00       	mov    $0x409550,%esi
  406044:	b8 00 00 00 00       	mov    $0x0,%eax
  406049:	e8 72 06 00 00       	callq  4066c0 <gsi_is_write_to_log>
  40604e:	48 83 c4 10          	add    $0x10,%rsp
			LOG_DEBUG("msg type: %d", msg.e_type_msg);
  406052:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  406055:	b8 00 00 00 00       	mov    $0x0,%eax
  40605a:	e8 7d 08 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40605f:	49 89 c4             	mov    %rax,%r12
  406062:	b8 00 00 00 00       	mov    $0x0,%eax
  406067:	e8 eb 05 00 00       	callq  406657 <gsi_get_saved_file>
  40606c:	41 89 d9             	mov    %ebx,%r9d
  40606f:	41 b8 47 02 00 00    	mov    $0x247,%r8d
  406075:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40607a:	4c 89 e2             	mov    %r12,%rdx
  40607d:	be 98 95 40 00       	mov    $0x409598,%esi
  406082:	48 89 c7             	mov    %rax,%rdi
  406085:	b8 00 00 00 00       	mov    $0x0,%eax
  40608a:	e8 31 06 00 00       	callq  4066c0 <gsi_is_write_to_log>
			LOG_DEBUG("msg length: %d", msg.ui_len);
  40608f:	8b 5d d8             	mov    -0x28(%rbp),%ebx
  406092:	b8 00 00 00 00       	mov    $0x0,%eax
  406097:	e8 40 08 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40609c:	49 89 c4             	mov    %rax,%r12
  40609f:	b8 00 00 00 00       	mov    $0x0,%eax
  4060a4:	e8 ae 05 00 00       	callq  406657 <gsi_get_saved_file>
  4060a9:	41 89 d9             	mov    %ebx,%r9d
  4060ac:	41 b8 48 02 00 00    	mov    $0x248,%r8d
  4060b2:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4060b7:	4c 89 e2             	mov    %r12,%rdx
  4060ba:	be c8 95 40 00       	mov    $0x4095c8,%esi
  4060bf:	48 89 c7             	mov    %rax,%rdi
  4060c2:	b8 00 00 00 00       	mov    $0x0,%eax
  4060c7:	e8 f4 05 00 00       	callq  4066c0 <gsi_is_write_to_log>

			switch(msg.e_type_msg)
  4060cc:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  4060cf:	83 f8 01             	cmp    $0x1,%eax
  4060d2:	74 0e                	je     4060e2 <read_check_heartbeat+0x1d8>
  4060d4:	83 f8 02             	cmp    $0x2,%eax
  4060d7:	0f 84 bb 02 00 00    	je     406398 <read_check_heartbeat+0x48e>
  4060dd:	e9 18 03 00 00       	jmpq   4063fa <read_check_heartbeat+0x4f0>
			{
				case GSI_REGULAR_MSG:
				{
					if (GSI_IS_MAX_MSG_COUNT > p_this->i_msg_count)
  4060e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4060e6:	8b 40 24             	mov    0x24(%rax),%eax
  4060e9:	83 f8 04             	cmp    $0x4,%eax
  4060ec:	0f 8f 3b 02 00 00    	jg     40632d <read_check_heartbeat+0x423>
					{
						// Allocate memory for last message (free it in server_read function)
						p_this->s_last_msg = (char *)calloc(msg.ui_len, sizeof(char));
  4060f2:	8b 45 d8             	mov    -0x28(%rbp),%eax
  4060f5:	89 c0                	mov    %eax,%eax
  4060f7:	be 01 00 00 00       	mov    $0x1,%esi
  4060fc:	48 89 c7             	mov    %rax,%rdi
  4060ff:	e8 1c b6 ff ff       	callq  401720 <calloc@plt>
  406104:	48 89 c2             	mov    %rax,%rdx
  406107:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40610b:	48 89 50 10          	mov    %rdx,0x10(%rax)
						if (NULL == p_this->s_last_msg)
  40610f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  406113:	48 8b 40 10          	mov    0x10(%rax),%rax
  406117:	48 85 c0             	test   %rax,%rax
  40611a:	75 41                	jne    40615d <read_check_heartbeat+0x253>
						{
							LOG_ERROR("memory allocation for last message failed");
  40611c:	b8 00 00 00 00       	mov    $0x0,%eax
  406121:	e8 b6 07 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  406126:	48 89 c3             	mov    %rax,%rbx
  406129:	b8 00 00 00 00       	mov    $0x0,%eax
  40612e:	e8 24 05 00 00       	callq  406657 <gsi_get_saved_file>
  406133:	41 b8 54 02 00 00    	mov    $0x254,%r8d
  406139:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40613e:	48 89 da             	mov    %rbx,%rdx
  406141:	be f8 95 40 00       	mov    $0x4095f8,%esi
  406146:	48 89 c7             	mov    %rax,%rdi
  406149:	b8 00 00 00 00       	mov    $0x0,%eax
  40614e:	e8 6d 05 00 00       	callq  4066c0 <gsi_is_write_to_log>
							return GSI_NET_RC_ERROR;
  406153:	b8 01 00 00 00       	mov    $0x1,%eax
  406158:	e9 29 03 00 00       	jmpq   406486 <read_check_heartbeat+0x57c>
						}

						// Read the message form the connection_fd
						int i_count = 0;
  40615d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
						int i_res = 0;
  406164:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
						int i_len = msg.ui_len;
  40616b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  40616e:	89 45 c8             	mov    %eax,-0x38(%rbp)
						while (0 != i_len)
  406171:	e9 99 00 00 00       	jmpq   40620f <read_check_heartbeat+0x305>
						{
							i_count = read(p_this->i_connection_fd, p_this->s_last_msg + i_res, i_len);
  406176:	8b 45 c8             	mov    -0x38(%rbp),%eax
  406179:	48 63 d0             	movslq %eax,%rdx
  40617c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  406180:	48 8b 48 10          	mov    0x10(%rax),%rcx
  406184:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  406187:	48 98                	cltq   
  406189:	48 01 c1             	add    %rax,%rcx
  40618c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  406190:	8b 40 1c             	mov    0x1c(%rax),%eax
  406193:	48 89 ce             	mov    %rcx,%rsi
  406196:	89 c7                	mov    %eax,%edi
  406198:	e8 33 b5 ff ff       	callq  4016d0 <read@plt>
  40619d:	89 45 c0             	mov    %eax,-0x40(%rbp)
							if (0 > i_count)
  4061a0:	83 7d c0 00          	cmpl   $0x0,-0x40(%rbp)
  4061a4:	79 5d                	jns    406203 <read_check_heartbeat+0x2f9>
							{
								free(p_this->s_last_msg);
  4061a6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4061aa:	48 8b 40 10          	mov    0x10(%rax),%rax
  4061ae:	48 89 c7             	mov    %rax,%rdi
  4061b1:	e8 9a b3 ff ff       	callq  401550 <free@plt>
								p_this->s_last_msg = NULL;
  4061b6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4061ba:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  4061c1:	00 

								LOG_ERROR("read failed");
  4061c2:	b8 00 00 00 00       	mov    $0x0,%eax
  4061c7:	e8 10 07 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4061cc:	48 89 c3             	mov    %rax,%rbx
  4061cf:	b8 00 00 00 00       	mov    $0x0,%eax
  4061d4:	e8 7e 04 00 00       	callq  406657 <gsi_get_saved_file>
  4061d9:	41 b8 64 02 00 00    	mov    $0x264,%r8d
  4061df:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4061e4:	48 89 da             	mov    %rbx,%rdx
  4061e7:	be 20 95 40 00       	mov    $0x409520,%esi
  4061ec:	48 89 c7             	mov    %rax,%rdi
  4061ef:	b8 00 00 00 00       	mov    $0x0,%eax
  4061f4:	e8 c7 04 00 00       	callq  4066c0 <gsi_is_write_to_log>
								return GSI_NET_RC_ERROR;
  4061f9:	b8 01 00 00 00       	mov    $0x1,%eax
  4061fe:	e9 83 02 00 00       	jmpq   406486 <read_check_heartbeat+0x57c>
							}

							i_res += i_count;
  406203:	8b 45 c0             	mov    -0x40(%rbp),%eax
  406206:	01 45 c4             	add    %eax,-0x3c(%rbp)
							i_len -= i_count;
  406209:	8b 45 c0             	mov    -0x40(%rbp),%eax
  40620c:	29 45 c8             	sub    %eax,-0x38(%rbp)

						// Read the message form the connection_fd
						int i_count = 0;
						int i_res = 0;
						int i_len = msg.ui_len;
						while (0 != i_len)
  40620f:	83 7d c8 00          	cmpl   $0x0,-0x38(%rbp)
  406213:	0f 85 5d ff ff ff    	jne    406176 <read_check_heartbeat+0x26c>

							i_res += i_count;
							i_len -= i_count;
						}

						LOG_DEBUG("second read %d bytes from fd: %d", i_count, p_this->i_connection_fd);
  406219:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40621d:	8b 58 1c             	mov    0x1c(%rax),%ebx
  406220:	b8 00 00 00 00       	mov    $0x0,%eax
  406225:	e8 b2 06 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40622a:	49 89 c4             	mov    %rax,%r12
  40622d:	b8 00 00 00 00       	mov    $0x0,%eax
  406232:	e8 20 04 00 00       	callq  406657 <gsi_get_saved_file>
  406237:	48 89 c7             	mov    %rax,%rdi
  40623a:	8b 45 c0             	mov    -0x40(%rbp),%eax
  40623d:	48 83 ec 08          	sub    $0x8,%rsp
  406241:	53                   	push   %rbx
  406242:	41 89 c1             	mov    %eax,%r9d
  406245:	41 b8 6c 02 00 00    	mov    $0x26c,%r8d
  40624b:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  406250:	4c 89 e2             	mov    %r12,%rdx
  406253:	be 48 96 40 00       	mov    $0x409648,%esi
  406258:	b8 00 00 00 00       	mov    $0x0,%eax
  40625d:	e8 5e 04 00 00       	callq  4066c0 <gsi_is_write_to_log>
  406262:	48 83 c4 10          	add    $0x10,%rsp
						LOG_DEBUG("is message complete: %d", (strlen(p_this->s_last_msg) == (i_count - 1)));
  406266:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40626a:	48 8b 40 10          	mov    0x10(%rax),%rax
  40626e:	48 89 c7             	mov    %rax,%rdi
  406271:	e8 aa b3 ff ff       	callq  401620 <strlen@plt>
  406276:	48 89 c2             	mov    %rax,%rdx
  406279:	8b 45 c0             	mov    -0x40(%rbp),%eax
  40627c:	83 e8 01             	sub    $0x1,%eax
  40627f:	48 98                	cltq   
  406281:	48 39 c2             	cmp    %rax,%rdx
  406284:	0f 94 c0             	sete   %al
  406287:	0f b6 d8             	movzbl %al,%ebx
  40628a:	b8 00 00 00 00       	mov    $0x0,%eax
  40628f:	e8 48 06 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  406294:	49 89 c4             	mov    %rax,%r12
  406297:	b8 00 00 00 00       	mov    $0x0,%eax
  40629c:	e8 b6 03 00 00       	callq  406657 <gsi_get_saved_file>
  4062a1:	41 89 d9             	mov    %ebx,%r9d
  4062a4:	41 b8 6d 02 00 00    	mov    $0x26d,%r8d
  4062aa:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4062af:	4c 89 e2             	mov    %r12,%rdx
  4062b2:	be 90 96 40 00       	mov    $0x409690,%esi
  4062b7:	48 89 c7             	mov    %rax,%rdi
  4062ba:	b8 00 00 00 00       	mov    $0x0,%eax
  4062bf:	e8 fc 03 00 00       	callq  4066c0 <gsi_is_write_to_log>

						// Update the message counter
						++(p_this->i_msg_count);
  4062c4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4062c8:	8b 40 24             	mov    0x24(%rax),%eax
  4062cb:	8d 50 01             	lea    0x1(%rax),%edx
  4062ce:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4062d2:	89 50 24             	mov    %edx,0x24(%rax)

						// Reset the heart beat in case that we are in the first message
						if (1 == p_this->i_msg_count)
  4062d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4062d9:	8b 40 24             	mov    0x24(%rax),%eax
  4062dc:	83 f8 01             	cmp    $0x1,%eax
  4062df:	75 0b                	jne    4062ec <read_check_heartbeat+0x3e2>
						{
							p_this->i_heartbeat = 0;
  4062e1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4062e5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%rax)
						}

						LOG_INFO("has data");
  4062ec:	b8 00 00 00 00       	mov    $0x0,%eax
  4062f1:	e8 e6 05 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4062f6:	48 89 c3             	mov    %rax,%rbx
  4062f9:	b8 00 00 00 00       	mov    $0x0,%eax
  4062fe:	e8 54 03 00 00       	callq  406657 <gsi_get_saved_file>
  406303:	41 b8 78 02 00 00    	mov    $0x278,%r8d
  406309:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40630e:	48 89 da             	mov    %rbx,%rdx
  406311:	be d0 96 40 00       	mov    $0x4096d0,%esi
  406316:	48 89 c7             	mov    %rax,%rdi
  406319:	b8 00 00 00 00       	mov    $0x0,%eax
  40631e:	e8 9d 03 00 00       	callq  4066c0 <gsi_is_write_to_log>
						return GSI_NET_RC_HASDATA;
  406323:	b8 80 00 00 00       	mov    $0x80,%eax
  406328:	e9 59 01 00 00       	jmpq   406486 <read_check_heartbeat+0x57c>
					}
					else if ((GSI_IS_MAX_MSG_COUNT <= p_this->i_msg_count) && (p_this->i_heartbeat != 1))
  40632d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  406331:	8b 40 24             	mov    0x24(%rax),%eax
  406334:	83 f8 04             	cmp    $0x4,%eax
  406337:	0f 8e 43 01 00 00    	jle    406480 <read_check_heartbeat+0x576>
  40633d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  406341:	8b 40 20             	mov    0x20(%rax),%eax
  406344:	83 f8 01             	cmp    $0x1,%eax
  406347:	0f 84 33 01 00 00    	je     406480 <read_check_heartbeat+0x576>
					{
						// Enter here if after MAX_MSG_COUNT messages there is no heart beat
						LOG_ERROR("client on port %d is not responding...closing connection", p_this->ui_port);
  40634d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  406351:	8b 58 28             	mov    0x28(%rax),%ebx
  406354:	b8 00 00 00 00       	mov    $0x0,%eax
  406359:	e8 7e 05 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  40635e:	49 89 c4             	mov    %rax,%r12
  406361:	b8 00 00 00 00       	mov    $0x0,%eax
  406366:	e8 ec 02 00 00       	callq  406657 <gsi_get_saved_file>
  40636b:	41 89 d9             	mov    %ebx,%r9d
  40636e:	41 b8 7e 02 00 00    	mov    $0x27e,%r8d
  406374:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  406379:	4c 89 e2             	mov    %r12,%rdx
  40637c:	be 00 97 40 00       	mov    $0x409700,%esi
  406381:	48 89 c7             	mov    %rax,%rdi
  406384:	b8 00 00 00 00       	mov    $0x0,%eax
  406389:	e8 32 03 00 00       	callq  4066c0 <gsi_is_write_to_log>
						return GSI_NET_RC_CONNECTERR;
  40638e:	b8 04 00 00 00       	mov    $0x4,%eax
  406393:	e9 ee 00 00 00       	jmpq   406486 <read_check_heartbeat+0x57c>
					break;
				}
				case GSI_HEARTBEAT_MSG:
				{
					// Enter here if we got heart beat message
					++(p_this->i_heartbeat);
  406398:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40639c:	8b 40 20             	mov    0x20(%rax),%eax
  40639f:	8d 50 01             	lea    0x1(%rax),%edx
  4063a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4063a6:	89 50 20             	mov    %edx,0x20(%rax)

					// Reset message counter for next phase
					p_this->i_msg_count = 0;
  4063a9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4063ad:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%rax)
					LOG_INFO("got heartbeat from port: %d\n", p_this->ui_port);
  4063b4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4063b8:	8b 58 28             	mov    0x28(%rax),%ebx
  4063bb:	b8 00 00 00 00       	mov    $0x0,%eax
  4063c0:	e8 17 05 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  4063c5:	49 89 c4             	mov    %rax,%r12
  4063c8:	b8 00 00 00 00       	mov    $0x0,%eax
  4063cd:	e8 85 02 00 00       	callq  406657 <gsi_get_saved_file>
  4063d2:	41 89 d9             	mov    %ebx,%r9d
  4063d5:	41 b8 8a 02 00 00    	mov    $0x28a,%r8d
  4063db:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  4063e0:	4c 89 e2             	mov    %r12,%rdx
  4063e3:	be 60 97 40 00       	mov    $0x409760,%esi
  4063e8:	48 89 c7             	mov    %rax,%rdi
  4063eb:	b8 00 00 00 00       	mov    $0x0,%eax
  4063f0:	e8 cb 02 00 00       	callq  4066c0 <gsi_is_write_to_log>

					break;
  4063f5:	e9 87 00 00 00       	jmpq   406481 <read_check_heartbeat+0x577>
				}
				default:
					LOG_ERROR("classified message failed");
  4063fa:	b8 00 00 00 00       	mov    $0x0,%eax
  4063ff:	e8 d8 04 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  406404:	48 89 c3             	mov    %rax,%rbx
  406407:	b8 00 00 00 00       	mov    $0x0,%eax
  40640c:	e8 46 02 00 00       	callq  406657 <gsi_get_saved_file>
  406411:	41 b8 8f 02 00 00    	mov    $0x28f,%r8d
  406417:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  40641c:	48 89 da             	mov    %rbx,%rdx
  40641f:	be a0 97 40 00       	mov    $0x4097a0,%esi
  406424:	48 89 c7             	mov    %rax,%rdi
  406427:	b8 00 00 00 00       	mov    $0x0,%eax
  40642c:	e8 8f 02 00 00       	callq  4066c0 <gsi_is_write_to_log>
					return GSI_NET_RC_ERROR;
  406431:	b8 01 00 00 00       	mov    $0x1,%eax
  406436:	eb 4e                	jmp    406486 <read_check_heartbeat+0x57c>

			} /* end  of switch case */
		}
		else // i_count = 0 so there is connection error
		{
			LOG_ERROR("client on port %d closed his channel", p_this->ui_port);
  406438:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40643c:	8b 58 28             	mov    0x28(%rax),%ebx
  40643f:	b8 00 00 00 00       	mov    $0x0,%eax
  406444:	e8 93 04 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  406449:	49 89 c4             	mov    %rax,%r12
  40644c:	b8 00 00 00 00       	mov    $0x0,%eax
  406451:	e8 01 02 00 00       	callq  406657 <gsi_get_saved_file>
  406456:	41 89 d9             	mov    %ebx,%r9d
  406459:	41 b8 96 02 00 00    	mov    $0x296,%r8d
  40645f:	b9 28 8d 40 00       	mov    $0x408d28,%ecx
  406464:	4c 89 e2             	mov    %r12,%rdx
  406467:	be e0 97 40 00       	mov    $0x4097e0,%esi
  40646c:	48 89 c7             	mov    %rax,%rdi
  40646f:	b8 00 00 00 00       	mov    $0x0,%eax
  406474:	e8 47 02 00 00       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_NET_RC_CONNECTERR;
  406479:	b8 04 00 00 00       	mov    $0x4,%eax
  40647e:	eb 06                	jmp    406486 <read_check_heartbeat+0x57c>
					{
						// Enter here if after MAX_MSG_COUNT messages there is no heart beat
						LOG_ERROR("client on port %d is not responding...closing connection", p_this->ui_port);
						return GSI_NET_RC_CONNECTERR;
					}
					break;
  406480:	90                   	nop
			LOG_ERROR("client on port %d closed his channel", p_this->ui_port);
			return GSI_NET_RC_CONNECTERR;
		}
	}

	return GSI_NET_RC_SUCCESS;
  406481:	b8 00 00 00 00       	mov    $0x0,%eax
}
  406486:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  40648a:	64 48 33 34 25 28 00 	xor    %fs:0x28,%rsi
  406491:	00 00 
  406493:	74 05                	je     40649a <read_check_heartbeat+0x590>
  406495:	e8 96 b1 ff ff       	callq  401630 <__stack_chk_fail@plt>
  40649a:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  40649e:	5b                   	pop    %rbx
  40649f:	41 5c                	pop    %r12
  4064a1:	5d                   	pop    %rbp
  4064a2:	c3                   	retq   

00000000004064a3 <gsi_is_create_log_file>:
	 * 											  if NULL - set it to default path
	 * Return:		Success - FILE* - handler for the opened log_file
	 * 				Failure - NULL
#############################################################################*/
FILE* gsi_is_create_log_file(const char *s_log_name, char *s_log_path)
{
  4064a3:	55                   	push   %rbp
  4064a4:	48 89 e5             	mov    %rsp,%rbp
  4064a7:	48 81 ec 30 01 00 00 	sub    $0x130,%rsp
  4064ae:	48 89 bd d8 fe ff ff 	mov    %rdi,-0x128(%rbp)
  4064b5:	48 89 b5 d0 fe ff ff 	mov    %rsi,-0x130(%rbp)
  4064bc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4064c3:	00 00 
  4064c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4064c9:	31 c0                	xor    %eax,%eax
	FILE* f_log = NULL;
  4064cb:	48 c7 85 e8 fe ff ff 	movq   $0x0,-0x118(%rbp)
  4064d2:	00 00 00 00 
	char s_file_name[GSI_IS_LOG_MAX_FILE_NAME];
	int i_is_path_allocated = GSI_IS_LOG_FALSE;
  4064d6:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%rbp)
  4064dd:	00 00 00 

	// Check input validation
	if (NULL == s_log_name)
  4064e0:	48 83 bd d8 fe ff ff 	cmpq   $0x0,-0x128(%rbp)
  4064e7:	00 
  4064e8:	75 14                	jne    4064fe <gsi_is_create_log_file+0x5b>
	{
		printf("gsi_is_create_log_file: invalid argument\n");
  4064ea:	bf 28 98 40 00       	mov    $0x409828,%edi
  4064ef:	e8 bc b0 ff ff       	callq  4015b0 <puts@plt>
		return NULL;
  4064f4:	b8 00 00 00 00       	mov    $0x0,%eax
  4064f9:	e9 43 01 00 00       	jmpq   406641 <gsi_is_create_log_file+0x19e>
	}

	// Check if path is NULL - set it to default path
	if (NULL == s_log_path)
  4064fe:	48 83 bd d0 fe ff ff 	cmpq   $0x0,-0x130(%rbp)
  406505:	00 
  406506:	75 4a                	jne    406552 <gsi_is_create_log_file+0xaf>
	{
		s_log_path = malloc(sizeof(GSI_IS_LOG_DEFAULT_PATH));
  406508:	bf 05 00 00 00       	mov    $0x5,%edi
  40650d:	e8 ce b2 ff ff       	callq  4017e0 <malloc@plt>
  406512:	48 89 85 d0 fe ff ff 	mov    %rax,-0x130(%rbp)
		if (NULL == s_log_path)
  406519:	48 83 bd d0 fe ff ff 	cmpq   $0x0,-0x130(%rbp)
  406520:	00 
  406521:	75 14                	jne    406537 <gsi_is_create_log_file+0x94>
		{
			printf("gsi_is_create_log_file: memory allocation for path failed\n");
  406523:	bf 58 98 40 00       	mov    $0x409858,%edi
  406528:	e8 83 b0 ff ff       	callq  4015b0 <puts@plt>
			return NULL;
  40652d:	b8 00 00 00 00       	mov    $0x0,%eax
  406532:	e9 0a 01 00 00       	jmpq   406641 <gsi_is_create_log_file+0x19e>
		}

		i_is_path_allocated = GSI_IS_LOG_TRUE;
  406537:	c7 85 e4 fe ff ff 01 	movl   $0x1,-0x11c(%rbp)
  40653e:	00 00 00 
		strcpy(s_log_path, GSI_IS_LOG_DEFAULT_PATH);
  406541:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  406548:	c7 00 2f 74 6d 70    	movl   $0x706d742f,(%rax)
  40654e:	c6 40 04 00          	movb   $0x0,0x4(%rax)
	}

	// Create thread pool from parameters in config file
	g_p_thread_pool = gsi_is_thread_pool_create(GSI_IS_LOG_THREADS, GSI_IS_LOG_QUEUE);
  406552:	be 64 00 00 00       	mov    $0x64,%esi
  406557:	bf 01 00 00 00       	mov    $0x1,%edi
  40655c:	e8 4e 11 00 00       	callq  4076af <gsi_is_thread_pool_create>
  406561:	48 89 05 78 4d 20 00 	mov    %rax,0x204d78(%rip)        # 60b2e0 <g_p_thread_pool>
	if (NULL == g_p_thread_pool)
  406568:	48 8b 05 71 4d 20 00 	mov    0x204d71(%rip),%rax        # 60b2e0 <g_p_thread_pool>
  40656f:	48 85 c0             	test   %rax,%rax
  406572:	75 14                	jne    406588 <gsi_is_create_log_file+0xe5>
	{
		printf("gsi_is_create_log_file: memory allocation failed\n");
  406574:	bf 98 98 40 00       	mov    $0x409898,%edi
  406579:	e8 32 b0 ff ff       	callq  4015b0 <puts@plt>
		return NULL;
  40657e:	b8 00 00 00 00       	mov    $0x0,%eax
  406583:	e9 b9 00 00 00       	jmpq   406641 <gsi_is_create_log_file+0x19e>
	}

	// Build the log file name
	sprintf(s_file_name, "%s/%s-%s.log", s_log_path, s_log_name, gsi_is_gen_timestamp());
  406588:	b8 00 00 00 00       	mov    $0x0,%eax
  40658d:	e8 4a 03 00 00       	callq  4068dc <gsi_is_gen_timestamp>
  406592:	48 89 c6             	mov    %rax,%rsi
  406595:	48 8b 8d d8 fe ff ff 	mov    -0x128(%rbp),%rcx
  40659c:	48 8b 95 d0 fe ff ff 	mov    -0x130(%rbp),%rdx
  4065a3:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  4065aa:	49 89 f0             	mov    %rsi,%r8
  4065ad:	be c9 98 40 00       	mov    $0x4098c9,%esi
  4065b2:	48 89 c7             	mov    %rax,%rdi
  4065b5:	b8 00 00 00 00       	mov    $0x0,%eax
  4065ba:	e8 11 b3 ff ff       	callq  4018d0 <sprintf@plt>

	// Open file in append mode
	f_log = fopen(s_file_name, "a");
  4065bf:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  4065c6:	be d6 98 40 00       	mov    $0x4098d6,%esi
  4065cb:	48 89 c7             	mov    %rax,%rdi
  4065ce:	e8 9d b2 ff ff       	callq  401870 <fopen@plt>
  4065d3:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	if (NULL == f_log)
  4065da:	48 83 bd e8 fe ff ff 	cmpq   $0x0,-0x118(%rbp)
  4065e1:	00 
  4065e2:	75 25                	jne    406609 <gsi_is_create_log_file+0x166>
	{
		printf("gsi_is_create_log_file: failed to open log file\n");
  4065e4:	bf d8 98 40 00       	mov    $0x4098d8,%edi
  4065e9:	e8 c2 af ff ff       	callq  4015b0 <puts@plt>
		gsi_is_thread_pool_destroy(g_p_thread_pool, GSI_TP_DESTROY_IMMIDIATE);
  4065ee:	48 8b 05 eb 4c 20 00 	mov    0x204ceb(%rip),%rax        # 60b2e0 <g_p_thread_pool>
  4065f5:	be 02 00 00 00       	mov    $0x2,%esi
  4065fa:	48 89 c7             	mov    %rax,%rdi
  4065fd:	e8 46 14 00 00       	callq  407a48 <gsi_is_thread_pool_destroy>
		return NULL;
  406602:	b8 00 00 00 00       	mov    $0x0,%eax
  406607:	eb 38                	jmp    406641 <gsi_is_create_log_file+0x19e>
	}

	// Check if we allocated the path
	if (GSI_IS_LOG_TRUE == i_is_path_allocated)
  406609:	83 bd e4 fe ff ff 01 	cmpl   $0x1,-0x11c(%rbp)
  406610:	75 1a                	jne    40662c <gsi_is_create_log_file+0x189>
	{
		free (s_log_path);
  406612:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  406619:	48 89 c7             	mov    %rax,%rdi
  40661c:	e8 2f af ff ff       	callq  401550 <free@plt>
		s_log_path = NULL;
  406621:	48 c7 85 d0 fe ff ff 	movq   $0x0,-0x130(%rbp)
  406628:	00 00 00 00 
	}

	// Initialize global pointer to log file
	g_p_log_file = f_log;
  40662c:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  406633:	48 89 05 ae 4c 20 00 	mov    %rax,0x204cae(%rip)        # 60b2e8 <g_p_log_file>
	return f_log;
  40663a:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
}
  406641:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  406645:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
  40664c:	00 00 
  40664e:	74 05                	je     406655 <gsi_is_create_log_file+0x1b2>
  406650:	e8 db af ff ff       	callq  401630 <__stack_chk_fail@plt>
  406655:	c9                   	leaveq 
  406656:	c3                   	retq   

0000000000406657 <gsi_get_saved_file>:
	 * Description: return the FILE* pointer used to write to the log file
	 * Parameter:   [in] None
	 * Return:		FILE* - pointer to file
#############################################################################*/
FILE* gsi_get_saved_file()
{
  406657:	55                   	push   %rbp
  406658:	48 89 e5             	mov    %rsp,%rbp
	return g_p_log_file;
  40665b:	48 8b 05 86 4c 20 00 	mov    0x204c86(%rip),%rax        # 60b2e8 <g_p_log_file>
}
  406662:	5d                   	pop    %rbp
  406663:	c3                   	retq   

0000000000406664 <gsi_is_title_to_log>:
	 * Parameter:   [in] const char* s_title - content of the title to be logged
	 * Return:		Success - GSI_LOG_RC_SUCCESS
	 * 				Failure - GSI_LOG_RC_WRITE_ERROR *OR* GSI_LOG_RC_INVALID *OR* GSI_LOG_RC_MEMORY_ERROR
#############################################################################*/
enum gsi_is_log_rc gsi_is_title_to_log(FILE* f_log, const char* s_title)
{
  406664:	55                   	push   %rbp
  406665:	48 89 e5             	mov    %rsp,%rbp
  406668:	48 83 ec 10          	sub    $0x10,%rsp
  40666c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  406670:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check input validation
	if ((NULL == f_log) || (NULL == s_title))
  406674:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  406679:	74 07                	je     406682 <gsi_is_title_to_log+0x1e>
  40667b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  406680:	75 11                	jne    406693 <gsi_is_title_to_log+0x2f>
	{
		printf("gsi_is_title_to_log: invalid argumets\n");
  406682:	bf 08 99 40 00       	mov    $0x409908,%edi
  406687:	e8 24 af ff ff       	callq  4015b0 <puts@plt>
		return GSI_LOG_RC_INVALID;
  40668c:	b8 04 00 00 00       	mov    $0x4,%eax
  406691:	eb 2b                	jmp    4066be <gsi_is_title_to_log+0x5a>
	}

	fprintf(f_log,
  406693:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  406697:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40669b:	be 30 99 40 00       	mov    $0x409930,%esi
  4066a0:	48 89 c7             	mov    %rax,%rdi
  4066a3:	b8 00 00 00 00       	mov    $0x0,%eax
  4066a8:	e8 a3 b0 ff ff       	callq  401750 <fprintf@plt>
			"\n+++++++++++++++++++++++++++\n"
			"+\t[%s]   +\n"
			"+++++++++++++++++++++++++++\n",
			  s_title);
	fflush(f_log);
  4066ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4066b1:	48 89 c7             	mov    %rax,%rdi
  4066b4:	e8 37 b1 ff ff       	callq  4017f0 <fflush@plt>

	return GSI_LOG_RC_SUCCESS;
  4066b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4066be:	c9                   	leaveq 
  4066bf:	c3                   	retq   

00000000004066c0 <gsi_is_write_to_log>:
	 * Parameter:   [in] ... - List of parameters to be logged, must match s_format.
	 * Return:		Success - GSI_LOG_RC_SUCCESS
	 * 				Failure - GSI_LOG_RC_WRITE_ERROR *OR* GSI_LOG_RC_INVALID *OR* GSI_LOG_RC_MEMORY_ERROR
#############################################################################*/
enum gsi_is_log_rc gsi_is_write_to_log(FILE* f_log, const char* s_format, ...)
{
  4066c0:	55                   	push   %rbp
  4066c1:	48 89 e5             	mov    %rsp,%rbp
  4066c4:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  4066cb:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  4066d2:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  4066d9:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  4066e0:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  4066e7:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  4066ee:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  4066f5:	84 c0                	test   %al,%al
  4066f7:	74 20                	je     406719 <gsi_is_write_to_log+0x59>
  4066f9:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  4066fd:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  406701:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  406705:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  406709:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  40670d:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  406711:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  406715:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  406719:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  406720:	00 00 
  406722:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  406729:	31 c0                	xor    %eax,%eax
	va_list optional_args;
	struct gsi_thread_args* p_thread_args = NULL;
  40672b:	48 c7 85 28 ff ff ff 	movq   $0x0,-0xd8(%rbp)
  406732:	00 00 00 00 

	// Check input validation
	if ((NULL == f_log) || (NULL == s_format))
  406736:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  40673d:	00 
  40673e:	74 0a                	je     40674a <gsi_is_write_to_log+0x8a>
  406740:	48 83 bd 10 ff ff ff 	cmpq   $0x0,-0xf0(%rbp)
  406747:	00 
  406748:	75 14                	jne    40675e <gsi_is_write_to_log+0x9e>
	{
		printf("gsi_is_write_to_log: invalid argumets\n");
  40674a:	bf 78 99 40 00       	mov    $0x409978,%edi
  40674f:	e8 5c ae ff ff       	callq  4015b0 <puts@plt>
		return GSI_LOG_RC_INVALID;
  406754:	b8 04 00 00 00       	mov    $0x4,%eax
  406759:	e9 06 01 00 00       	jmpq   406864 <gsi_is_write_to_log+0x1a4>
	}

	// Allocate memory for thread argument structure. free by running thread in thread_write_log().
	p_thread_args = (struct gsi_thread_args *)malloc(sizeof(struct gsi_thread_args));
  40675e:	bf 60 04 00 00       	mov    $0x460,%edi
  406763:	e8 78 b0 ff ff       	callq  4017e0 <malloc@plt>
  406768:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	if (NULL == p_thread_args)
  40676f:	48 83 bd 28 ff ff ff 	cmpq   $0x0,-0xd8(%rbp)
  406776:	00 
  406777:	75 0a                	jne    406783 <gsi_is_write_to_log+0xc3>
	{
		return GSI_LOG_RC_MEMORY_ERROR;
  406779:	b8 05 00 00 00       	mov    $0x5,%eax
  40677e:	e9 e1 00 00 00       	jmpq   406864 <gsi_is_write_to_log+0x1a4>
	}

	// Set fields
	p_thread_args->thread_id = pthread_self();
  406783:	e8 c8 b0 ff ff       	callq  401850 <pthread_self@plt>
  406788:	48 89 c2             	mov    %rax,%rdx
  40678b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  406792:	48 89 10             	mov    %rdx,(%rax)
	p_thread_args->f_log = f_log;
  406795:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  40679c:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  4067a3:	48 89 50 08          	mov    %rdx,0x8(%rax)

	// Reset s_message
	memset(p_thread_args->s_message, 0, sizeof(p_thread_args->s_message));
  4067a7:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  4067ae:	48 83 c0 10          	add    $0x10,%rax
  4067b2:	ba 4c 04 00 00       	mov    $0x44c,%edx
  4067b7:	be 00 00 00 00       	mov    $0x0,%esi
  4067bc:	48 89 c7             	mov    %rax,%rdi
  4067bf:	e8 ec ae ff ff       	callq  4016b0 <memset@plt>

	// Build message
	va_start(optional_args, s_format);
  4067c4:	c7 85 30 ff ff ff 10 	movl   $0x10,-0xd0(%rbp)
  4067cb:	00 00 00 
  4067ce:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  4067d5:	00 00 00 
  4067d8:	48 8d 45 10          	lea    0x10(%rbp),%rax
  4067dc:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  4067e3:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  4067ea:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	vsprintf(p_thread_args->s_message, s_format, optional_args);
  4067f1:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  4067f8:	48 8d 48 10          	lea    0x10(%rax),%rcx
  4067fc:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  406803:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  40680a:	48 89 c6             	mov    %rax,%rsi
  40680d:	48 89 cf             	mov    %rcx,%rdi
  406810:	e8 2b b0 ff ff       	callq  401840 <vsprintf@plt>
	va_end(optional_args);

	// Add message work to Queue
	if (GSI_TP_RC_SUCCESS != gsi_is_thread_pool_add(g_p_thread_pool, thread_write_log, p_thread_args))
  406815:	48 8b 05 c4 4a 20 00 	mov    0x204ac4(%rip),%rax        # 60b2e0 <g_p_thread_pool>
  40681c:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  406823:	be 7e 69 40 00       	mov    $0x40697e,%esi
  406828:	48 89 c7             	mov    %rax,%rdi
  40682b:	e8 fb 10 00 00       	callq  40792b <gsi_is_thread_pool_add>
  406830:	85 c0                	test   %eax,%eax
  406832:	74 2b                	je     40685f <gsi_is_write_to_log+0x19f>
	{
		if (NULL != p_thread_args)
  406834:	48 83 bd 28 ff ff ff 	cmpq   $0x0,-0xd8(%rbp)
  40683b:	00 
  40683c:	74 1a                	je     406858 <gsi_is_write_to_log+0x198>
		{
			free(p_thread_args);
  40683e:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  406845:	48 89 c7             	mov    %rax,%rdi
  406848:	e8 03 ad ff ff       	callq  401550 <free@plt>
			p_thread_args = NULL;
  40684d:	48 c7 85 28 ff ff ff 	movq   $0x0,-0xd8(%rbp)
  406854:	00 00 00 00 
		}

		return GSI_LOG_RC_WRITE_ERROR;
  406858:	b8 03 00 00 00       	mov    $0x3,%eax
  40685d:	eb 05                	jmp    406864 <gsi_is_write_to_log+0x1a4>
	}

	return GSI_LOG_RC_SUCCESS;
  40685f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  406864:	48 8b 8d 48 ff ff ff 	mov    -0xb8(%rbp),%rcx
  40686b:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  406872:	00 00 
  406874:	74 05                	je     40687b <gsi_is_write_to_log+0x1bb>
  406876:	e8 b5 ad ff ff       	callq  401630 <__stack_chk_fail@plt>
  40687b:	c9                   	leaveq 
  40687c:	c3                   	retq   

000000000040687d <gsi_is_close_log>:
	 * Parameter:   [in] FILE* f_log - Handler to the log file.
	 * Return:		Success - GSI_LOG_RC_SUCCESS
	 * 				Failure - GSI_LOG_RC_CLOSE_ERROR *OR* GSI_LOG_RC_INVALID
#############################################################################*/
enum gsi_is_log_rc gsi_is_close_log(FILE* f_log)
{
  40687d:	55                   	push   %rbp
  40687e:	48 89 e5             	mov    %rsp,%rbp
  406881:	48 83 ec 10          	sub    $0x10,%rsp
  406885:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Check input validation
	if (NULL == f_log)
  406889:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  40688e:	75 07                	jne    406897 <gsi_is_close_log+0x1a>
	{
		return GSI_LOG_RC_INVALID;
  406890:	b8 04 00 00 00       	mov    $0x4,%eax
  406895:	eb 43                	jmp    4068da <gsi_is_close_log+0x5d>
	}

	// Destroy thread pool gracefully to write all the messages in the Queue
	gsi_is_thread_pool_destroy(g_p_thread_pool, GSI_TP_DESTROY_GRACEFUL);
  406897:	48 8b 05 42 4a 20 00 	mov    0x204a42(%rip),%rax        # 60b2e0 <g_p_thread_pool>
  40689e:	be 01 00 00 00       	mov    $0x1,%esi
  4068a3:	48 89 c7             	mov    %rax,%rdi
  4068a6:	e8 9d 11 00 00       	callq  407a48 <gsi_is_thread_pool_destroy>

	// Close the log file
	if (0 != fclose(f_log))
  4068ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4068af:	48 89 c7             	mov    %rax,%rdi
  4068b2:	e8 49 ad ff ff       	callq  401600 <fclose@plt>
  4068b7:	85 c0                	test   %eax,%eax
  4068b9:	74 07                	je     4068c2 <gsi_is_close_log+0x45>
	{
		return GSI_LOG_RC_CLOSE_ERROR;
  4068bb:	b8 02 00 00 00       	mov    $0x2,%eax
  4068c0:	eb 18                	jmp    4068da <gsi_is_close_log+0x5d>
	}

	// Reset pointer
	f_log = NULL;
  4068c2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  4068c9:	00 

	// Reset global pointer
	g_p_log_file = NULL;
  4068ca:	48 c7 05 13 4a 20 00 	movq   $0x0,0x204a13(%rip)        # 60b2e8 <g_p_log_file>
  4068d1:	00 00 00 00 

	return GSI_LOG_RC_SUCCESS;
  4068d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4068da:	c9                   	leaveq 
  4068db:	c3                   	retq   

00000000004068dc <gsi_is_gen_timestamp>:
	 * Description: Generate time stamp as string : "YYYY-MM-DD-HH:MM:SS"
	 * Parameter:   [in] None
	 * Return:		char* - time stamp as string
#############################################################################*/
char* gsi_is_gen_timestamp()
{
  4068dc:	55                   	push   %rbp
  4068dd:	48 89 e5             	mov    %rsp,%rbp
  4068e0:	48 83 ec 20          	sub    $0x20,%rsp
  4068e4:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4068eb:	00 00 
  4068ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4068f1:	31 c0                	xor    %eax,%eax
	static char s_time_stamp[GSI_IS_LOG_TIME_STAMP_LEN];

	time_t t = time(NULL);
  4068f3:	bf 00 00 00 00       	mov    $0x0,%edi
  4068f8:	e8 a3 ae ff ff       	callq  4017a0 <time@plt>
  4068fd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	struct tm *curr_time = localtime(&t);
  406901:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  406905:	48 89 c7             	mov    %rax,%rdi
  406908:	e8 63 ac ff ff       	callq  401570 <localtime@plt>
  40690d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	sprintf(s_time_stamp, "%04d-%02d-%02d-%02d:%02d:%02d",
  406911:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  406915:	8b 10                	mov    (%rax),%edx
  406917:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40691b:	8b 40 04             	mov    0x4(%rax),%eax
  40691e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  406922:	44 8b 49 08          	mov    0x8(%rcx),%r9d
  406926:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  40692a:	44 8b 41 0c          	mov    0xc(%rcx),%r8d
			curr_time->tm_year + 1900,
			curr_time->tm_mon + 1,
  40692e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  406932:	8b 49 10             	mov    0x10(%rcx),%ecx
	static char s_time_stamp[GSI_IS_LOG_TIME_STAMP_LEN];

	time_t t = time(NULL);
	struct tm *curr_time = localtime(&t);

	sprintf(s_time_stamp, "%04d-%02d-%02d-%02d:%02d:%02d",
  406935:	8d 79 01             	lea    0x1(%rcx),%edi
			curr_time->tm_year + 1900,
  406938:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  40693c:	8b 49 14             	mov    0x14(%rcx),%ecx
	static char s_time_stamp[GSI_IS_LOG_TIME_STAMP_LEN];

	time_t t = time(NULL);
	struct tm *curr_time = localtime(&t);

	sprintf(s_time_stamp, "%04d-%02d-%02d-%02d:%02d:%02d",
  40693f:	8d b1 6c 07 00 00    	lea    0x76c(%rcx),%esi
  406945:	52                   	push   %rdx
  406946:	50                   	push   %rax
  406947:	89 f9                	mov    %edi,%ecx
  406949:	89 f2                	mov    %esi,%edx
  40694b:	be 9e 99 40 00       	mov    $0x40999e,%esi
  406950:	bf f0 b2 60 00       	mov    $0x60b2f0,%edi
  406955:	b8 00 00 00 00       	mov    $0x0,%eax
  40695a:	e8 71 af ff ff       	callq  4018d0 <sprintf@plt>
  40695f:	48 83 c4 10          	add    $0x10,%rsp
			curr_time->tm_mday,
			curr_time->tm_hour,
			curr_time->tm_min,
			curr_time->tm_sec);

	return s_time_stamp;
  406963:	b8 f0 b2 60 00       	mov    $0x60b2f0,%eax
}
  406968:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  40696c:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
  406973:	00 00 
  406975:	74 05                	je     40697c <gsi_is_gen_timestamp+0xa0>
  406977:	e8 b4 ac ff ff       	callq  401630 <__stack_chk_fail@plt>
  40697c:	c9                   	leaveq 
  40697d:	c3                   	retq   

000000000040697e <thread_write_log>:
	 * 				Must free the s_message field that allocated by the calling function
	 * Parameter:   [in] void* p_args - pointer to struct gsi_thread_args
	 * Return:		Always NULL
#############################################################################*/
static void* thread_write_log(void* p_args)
{
  40697e:	55                   	push   %rbp
  40697f:	48 89 e5             	mov    %rsp,%rbp
  406982:	48 83 ec 20          	sub    $0x20,%rsp
  406986:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	struct gsi_thread_args* p_thread_args = (struct gsi_thread_args*)p_args;
  40698a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40698e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	// Check input validation
	if (NULL == p_args)
  406992:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  406997:	75 11                	jne    4069aa <thread_write_log+0x2c>
	{
		printf("p_args is NULL\n");
  406999:	bf bc 99 40 00       	mov    $0x4099bc,%edi
  40699e:	e8 0d ac ff ff       	callq  4015b0 <puts@plt>
		return NULL;
  4069a3:	b8 00 00 00 00       	mov    $0x0,%eax
  4069a8:	eb 76                	jmp    406a20 <thread_write_log+0xa2>
	}

	do
	{
		if (NULL == p_thread_args->f_log)
  4069aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4069ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  4069b2:	48 85 c0             	test   %rax,%rax
  4069b5:	75 0c                	jne    4069c3 <thread_write_log+0x45>
		{
			printf("f_log is NULL\n");
  4069b7:	bf cb 99 40 00       	mov    $0x4099cb,%edi
  4069bc:	e8 ef ab ff ff       	callq  4015b0 <puts@plt>
			break;
  4069c1:	eb 44                	jmp    406a07 <thread_write_log+0x89>
		}

		if (NULL == p_thread_args->s_message)
  4069c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4069c7:	48 83 c0 10          	add    $0x10,%rax
  4069cb:	48 85 c0             	test   %rax,%rax
  4069ce:	75 0c                	jne    4069dc <thread_write_log+0x5e>
		{
			printf("s_message is NULL\n");
  4069d0:	bf d9 99 40 00       	mov    $0x4099d9,%edi
  4069d5:	e8 d6 ab ff ff       	callq  4015b0 <puts@plt>
			break;
  4069da:	eb 2b                	jmp    406a07 <thread_write_log+0x89>
		}

		// Write the message into log file
		fputs(p_thread_args->s_message, p_thread_args->f_log);
  4069dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4069e0:	48 8b 40 08          	mov    0x8(%rax),%rax
  4069e4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4069e8:	48 83 c2 10          	add    $0x10,%rdx
  4069ec:	48 89 c6             	mov    %rax,%rsi
  4069ef:	48 89 d7             	mov    %rdx,%rdi
  4069f2:	e8 a9 ac ff ff       	callq  4016a0 <fputs@plt>
		fflush(p_thread_args->f_log);
  4069f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4069fb:	48 8b 40 08          	mov    0x8(%rax),%rax
  4069ff:	48 89 c7             	mov    %rax,%rdi
  406a02:	e8 e9 ad ff ff       	callq  4017f0 <fflush@plt>
	}
	while (0);

	free(p_args);
  406a07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406a0b:	48 89 c7             	mov    %rax,%rdi
  406a0e:	e8 3d ab ff ff       	callq  401550 <free@plt>
	p_args = NULL;
  406a13:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  406a1a:	00 

	return NULL;
  406a1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  406a20:	c9                   	leaveq 
  406a21:	c3                   	retq   

0000000000406a22 <gsi_parse_json_config_open>:
	 * Parameter:   [in] char* s_config_file - configuration file to open
	 * Return:		Success - pointer to open file
	 * 				Failure - NULL
#############################################################################*/
FILE* gsi_parse_json_config_open(char* s_config_file)
{
  406a22:	55                   	push   %rbp
  406a23:	48 89 e5             	mov    %rsp,%rbp
  406a26:	53                   	push   %rbx
  406a27:	48 83 ec 28          	sub    $0x28,%rsp
  406a2b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	FILE* f_config = NULL;
  406a2f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  406a36:	00 

	// Check input validation
	if (NULL == s_config_file)
  406a37:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  406a3c:	75 3e                	jne    406a7c <gsi_parse_json_config_open+0x5a>
	{
		LOG_ERROR("invalid configuration file");
  406a3e:	b8 00 00 00 00       	mov    $0x0,%eax
  406a43:	e8 94 fe ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406a48:	48 89 c3             	mov    %rax,%rbx
  406a4b:	b8 00 00 00 00       	mov    $0x0,%eax
  406a50:	e8 02 fc ff ff       	callq  406657 <gsi_get_saved_file>
  406a55:	41 b8 46 00 00 00    	mov    $0x46,%r8d
  406a5b:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406a60:	48 89 da             	mov    %rbx,%rdx
  406a63:	be 90 9a 40 00       	mov    $0x409a90,%esi
  406a68:	48 89 c7             	mov    %rax,%rdi
  406a6b:	b8 00 00 00 00       	mov    $0x0,%eax
  406a70:	e8 4b fc ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  406a75:	b8 00 00 00 00       	mov    $0x0,%eax
  406a7a:	eb 65                	jmp    406ae1 <gsi_parse_json_config_open+0xbf>
	}

	// Open the configuration file
	f_config = fopen(s_config_file, "r");
  406a7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  406a80:	be cc 9a 40 00       	mov    $0x409acc,%esi
  406a85:	48 89 c7             	mov    %rax,%rdi
  406a88:	e8 e3 ad ff ff       	callq  401870 <fopen@plt>
  406a8d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == f_config)
  406a91:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  406a96:	75 45                	jne    406add <gsi_parse_json_config_open+0xbb>
	{
		LOG_ERROR("failed to open: %s", s_config_file);
  406a98:	b8 00 00 00 00       	mov    $0x0,%eax
  406a9d:	e8 3a fe ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406aa2:	48 89 c3             	mov    %rax,%rbx
  406aa5:	b8 00 00 00 00       	mov    $0x0,%eax
  406aaa:	e8 a8 fb ff ff       	callq  406657 <gsi_get_saved_file>
  406aaf:	48 89 c7             	mov    %rax,%rdi
  406ab2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  406ab6:	49 89 c1             	mov    %rax,%r9
  406ab9:	41 b8 4e 00 00 00    	mov    $0x4e,%r8d
  406abf:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406ac4:	48 89 da             	mov    %rbx,%rdx
  406ac7:	be d0 9a 40 00       	mov    $0x409ad0,%esi
  406acc:	b8 00 00 00 00       	mov    $0x0,%eax
  406ad1:	e8 ea fb ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return NULL;
  406ad6:	b8 00 00 00 00       	mov    $0x0,%eax
  406adb:	eb 04                	jmp    406ae1 <gsi_parse_json_config_open+0xbf>
	}

	return f_config;
  406add:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  406ae1:	48 83 c4 28          	add    $0x28,%rsp
  406ae5:	5b                   	pop    %rbx
  406ae6:	5d                   	pop    %rbp
  406ae7:	c3                   	retq   

0000000000406ae8 <gsi_parse_json_config_close>:
	 * Parameter:   [in] FILE* f_config - pointer to open file to be closed
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_CLOSE_ERR *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
enum gsi_prase_json_config_rc gsi_parse_json_config_close(FILE* f_config)
{
  406ae8:	55                   	push   %rbp
  406ae9:	48 89 e5             	mov    %rsp,%rbp
  406aec:	53                   	push   %rbx
  406aed:	48 83 ec 18          	sub    $0x18,%rsp
  406af1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == f_config)
  406af5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  406afa:	75 3e                	jne    406b3a <gsi_parse_json_config_close+0x52>
	{
		LOG_ERROR("invalid argument");
  406afc:	b8 00 00 00 00       	mov    $0x0,%eax
  406b01:	e8 d6 fd ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406b06:	48 89 c3             	mov    %rax,%rbx
  406b09:	b8 00 00 00 00       	mov    $0x0,%eax
  406b0e:	e8 44 fb ff ff       	callq  406657 <gsi_get_saved_file>
  406b13:	41 b8 61 00 00 00    	mov    $0x61,%r8d
  406b19:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406b1e:	48 89 da             	mov    %rbx,%rdx
  406b21:	be 08 9b 40 00       	mov    $0x409b08,%esi
  406b26:	48 89 c7             	mov    %rax,%rdi
  406b29:	b8 00 00 00 00       	mov    $0x0,%eax
  406b2e:	e8 8d fb ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  406b33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  406b38:	eb 53                	jmp    406b8d <gsi_parse_json_config_close+0xa5>
	}

	// Close configuration file
	if (0 != fclose(f_config))
  406b3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406b3e:	48 89 c7             	mov    %rax,%rdi
  406b41:	e8 ba aa ff ff       	callq  401600 <fclose@plt>
  406b46:	85 c0                	test   %eax,%eax
  406b48:	74 3e                	je     406b88 <gsi_parse_json_config_close+0xa0>
	{
		LOG_ERROR("failed to close configuration file");
  406b4a:	b8 00 00 00 00       	mov    $0x0,%eax
  406b4f:	e8 88 fd ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406b54:	48 89 c3             	mov    %rax,%rbx
  406b57:	b8 00 00 00 00       	mov    $0x0,%eax
  406b5c:	e8 f6 fa ff ff       	callq  406657 <gsi_get_saved_file>
  406b61:	41 b8 68 00 00 00    	mov    $0x68,%r8d
  406b67:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406b6c:	48 89 da             	mov    %rbx,%rdx
  406b6f:	be 40 9b 40 00       	mov    $0x409b40,%esi
  406b74:	48 89 c7             	mov    %rax,%rdi
  406b77:	b8 00 00 00 00       	mov    $0x0,%eax
  406b7c:	e8 3f fb ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_CLOSE_ERR;
  406b81:	b8 02 00 00 00       	mov    $0x2,%eax
  406b86:	eb 05                	jmp    406b8d <gsi_parse_json_config_close+0xa5>
	}

	return GSI_PARSE_JSON_CONFIG_SUCCESS;
  406b88:	b8 00 00 00 00       	mov    $0x0,%eax
}
  406b8d:	48 83 c4 18          	add    $0x18,%rsp
  406b91:	5b                   	pop    %rbx
  406b92:	5d                   	pop    %rbp
  406b93:	c3                   	retq   

0000000000406b94 <gsi_parse_json_config_read_line>:
	 * Parameter:   [out] char* s_value - buffer to get the value of the parameter
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_READ_ERR *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
enum gsi_prase_json_config_rc gsi_parse_json_config_read_line(FILE* f_config, char* s_key, char* s_value)
{
  406b94:	55                   	push   %rbp
  406b95:	48 89 e5             	mov    %rsp,%rbp
  406b98:	53                   	push   %rbx
  406b99:	48 81 ec 48 01 00 00 	sub    $0x148,%rsp
  406ba0:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  406ba7:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
  406bae:	48 89 95 b8 fe ff ff 	mov    %rdx,-0x148(%rbp)
  406bb5:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  406bbc:	00 00 
  406bbe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  406bc2:	31 c0                	xor    %eax,%eax
	char s_line[GSI_PARSE_JSON_CONFIG_MAX_LINE];
	char* s_separator = NULL;
  406bc4:	48 c7 85 d8 fe ff ff 	movq   $0x0,-0x128(%rbp)
  406bcb:	00 00 00 00 

	// Check input validation
	if ((NULL == f_config) || (NULL == s_key) || (NULL == s_value))
  406bcf:	48 83 bd c8 fe ff ff 	cmpq   $0x0,-0x138(%rbp)
  406bd6:	00 
  406bd7:	74 14                	je     406bed <gsi_parse_json_config_read_line+0x59>
  406bd9:	48 83 bd c0 fe ff ff 	cmpq   $0x0,-0x140(%rbp)
  406be0:	00 
  406be1:	74 0a                	je     406bed <gsi_parse_json_config_read_line+0x59>
  406be3:	48 83 bd b8 fe ff ff 	cmpq   $0x0,-0x148(%rbp)
  406bea:	00 
  406beb:	75 41                	jne    406c2e <gsi_parse_json_config_read_line+0x9a>
	{
		LOG_ERROR("read_line: invalid arguments");
  406bed:	b8 00 00 00 00       	mov    $0x0,%eax
  406bf2:	e8 e5 fc ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406bf7:	48 89 c3             	mov    %rax,%rbx
  406bfa:	b8 00 00 00 00       	mov    $0x0,%eax
  406bff:	e8 53 fa ff ff       	callq  406657 <gsi_get_saved_file>
  406c04:	41 b8 80 00 00 00    	mov    $0x80,%r8d
  406c0a:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406c0f:	48 89 da             	mov    %rbx,%rdx
  406c12:	be 88 9b 40 00       	mov    $0x409b88,%esi
  406c17:	48 89 c7             	mov    %rax,%rdi
  406c1a:	b8 00 00 00 00       	mov    $0x0,%eax
  406c1f:	e8 9c fa ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  406c24:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  406c29:	e9 9c 01 00 00       	jmpq   406dca <gsi_parse_json_config_read_line+0x236>

	// Main loop - skip lines starts with '#' or empty lines
	do
	{
		// Reset buffer
		memset(s_line, 0, sizeof(s_line));
  406c2e:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  406c35:	ba 00 01 00 00       	mov    $0x100,%edx
  406c3a:	be 00 00 00 00       	mov    $0x0,%esi
  406c3f:	48 89 c7             	mov    %rax,%rdi
  406c42:	e8 69 aa ff ff       	callq  4016b0 <memset@plt>

		// Read line from file
		if (NULL == fgets(s_line, GSI_PARSE_JSON_CONFIG_MAX_LINE, f_config))
  406c47:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  406c4e:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  406c55:	be 00 01 00 00       	mov    $0x100,%esi
  406c5a:	48 89 c7             	mov    %rax,%rdi
  406c5d:	e8 9e aa ff ff       	callq  401700 <fgets@plt>
  406c62:	48 85 c0             	test   %rax,%rax
  406c65:	0f 85 95 00 00 00    	jne    406d00 <gsi_parse_json_config_read_line+0x16c>
		{
			// Check if get EOF
			if (feof(f_config))
  406c6b:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
  406c72:	48 89 c7             	mov    %rax,%rdi
  406c75:	e8 e6 aa ff ff       	callq  401760 <feof@plt>
  406c7a:	85 c0                	test   %eax,%eax
  406c7c:	74 41                	je     406cbf <gsi_parse_json_config_read_line+0x12b>
			{
				LOG_WARNING("get EOF from config file");
  406c7e:	b8 00 00 00 00       	mov    $0x0,%eax
  406c83:	e8 54 fc ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406c88:	48 89 c3             	mov    %rax,%rbx
  406c8b:	b8 00 00 00 00       	mov    $0x0,%eax
  406c90:	e8 c2 f9 ff ff       	callq  406657 <gsi_get_saved_file>
  406c95:	41 b8 90 00 00 00    	mov    $0x90,%r8d
  406c9b:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406ca0:	48 89 da             	mov    %rbx,%rdx
  406ca3:	be c8 9b 40 00       	mov    $0x409bc8,%esi
  406ca8:	48 89 c7             	mov    %rax,%rdi
  406cab:	b8 00 00 00 00       	mov    $0x0,%eax
  406cb0:	e8 0b fa ff ff       	callq  4066c0 <gsi_is_write_to_log>
				return GSI_PARSE_JSON_CONFIG_EOF;
  406cb5:	b8 04 00 00 00       	mov    $0x4,%eax
  406cba:	e9 0b 01 00 00       	jmpq   406dca <gsi_parse_json_config_read_line+0x236>
			}
			else
			{
				LOG_ERROR("couldn't read from file");
  406cbf:	b8 00 00 00 00       	mov    $0x0,%eax
  406cc4:	e8 13 fc ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406cc9:	48 89 c3             	mov    %rax,%rbx
  406ccc:	b8 00 00 00 00       	mov    $0x0,%eax
  406cd1:	e8 81 f9 ff ff       	callq  406657 <gsi_get_saved_file>
  406cd6:	41 b8 95 00 00 00    	mov    $0x95,%r8d
  406cdc:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406ce1:	48 89 da             	mov    %rbx,%rdx
  406ce4:	be 08 9c 40 00       	mov    $0x409c08,%esi
  406ce9:	48 89 c7             	mov    %rax,%rdi
  406cec:	b8 00 00 00 00       	mov    $0x0,%eax
  406cf1:	e8 ca f9 ff ff       	callq  4066c0 <gsi_is_write_to_log>
				return GSI_PARSE_JSON_CONFIG_READ_ERR;
  406cf6:	b8 03 00 00 00       	mov    $0x3,%eax
  406cfb:	e9 ca 00 00 00       	jmpq   406dca <gsi_parse_json_config_read_line+0x236>
			}
		}
	}
	while (('#' == s_line[0]) || ('\n' == s_line[0]));
  406d00:	0f b6 85 e0 fe ff ff 	movzbl -0x120(%rbp),%eax
  406d07:	3c 23                	cmp    $0x23,%al
  406d09:	0f 84 1f ff ff ff    	je     406c2e <gsi_parse_json_config_read_line+0x9a>
  406d0f:	0f b6 85 e0 fe ff ff 	movzbl -0x120(%rbp),%eax
  406d16:	3c 0a                	cmp    $0xa,%al
  406d18:	0f 84 10 ff ff ff    	je     406c2e <gsi_parse_json_config_read_line+0x9a>

	// Get the position of ':' char in the current line
	s_separator = strchr(s_line, ':');
  406d1e:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  406d25:	be 3a 00 00 00       	mov    $0x3a,%esi
  406d2a:	48 89 c7             	mov    %rax,%rdi
  406d2d:	e8 3e a9 ff ff       	callq  401670 <strchr@plt>
  406d32:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
	if (NULL == s_separator)
  406d39:	48 83 bd d8 fe ff ff 	cmpq   $0x0,-0x128(%rbp)
  406d40:	00 
  406d41:	75 3e                	jne    406d81 <gsi_parse_json_config_read_line+0x1ed>
	{
		LOG_ERROR("there is no separator ':' in the line");
  406d43:	b8 00 00 00 00       	mov    $0x0,%eax
  406d48:	e8 8f fb ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406d4d:	48 89 c3             	mov    %rax,%rbx
  406d50:	b8 00 00 00 00       	mov    $0x0,%eax
  406d55:	e8 fd f8 ff ff       	callq  406657 <gsi_get_saved_file>
  406d5a:	41 b8 a0 00 00 00    	mov    $0xa0,%r8d
  406d60:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406d65:	48 89 da             	mov    %rbx,%rdx
  406d68:	be 48 9c 40 00       	mov    $0x409c48,%esi
  406d6d:	48 89 c7             	mov    %rax,%rdi
  406d70:	b8 00 00 00 00       	mov    $0x0,%eax
  406d75:	e8 46 f9 ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_READ_ERR;
  406d7a:	b8 03 00 00 00       	mov    $0x3,%eax
  406d7f:	eb 49                	jmp    406dca <gsi_parse_json_config_read_line+0x236>
	}

	// Break the line into <KEY> <VALUE>
	*s_separator = 0;
  406d81:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
  406d88:	c6 00 00             	movb   $0x0,(%rax)

	// Set the buffers
	strcpy(s_key, s_line);
  406d8b:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  406d92:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  406d99:	48 89 d6             	mov    %rdx,%rsi
  406d9c:	48 89 c7             	mov    %rax,%rdi
  406d9f:	e8 ec a7 ff ff       	callq  401590 <strcpy@plt>
	strcpy(s_value, ++s_separator);
  406da4:	48 83 85 d8 fe ff ff 	addq   $0x1,-0x128(%rbp)
  406dab:	01 
  406dac:	48 8b 95 d8 fe ff ff 	mov    -0x128(%rbp),%rdx
  406db3:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  406dba:	48 89 d6             	mov    %rdx,%rsi
  406dbd:	48 89 c7             	mov    %rax,%rdi
  406dc0:	e8 cb a7 ff ff       	callq  401590 <strcpy@plt>

	return GSI_PARSE_JSON_CONFIG_SUCCESS;
  406dc5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  406dca:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  406dce:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  406dd5:	00 00 
  406dd7:	74 05                	je     406dde <gsi_parse_json_config_read_line+0x24a>
  406dd9:	e8 52 a8 ff ff       	callq  401630 <__stack_chk_fail@plt>
  406dde:	48 81 c4 48 01 00 00 	add    $0x148,%rsp
  406de5:	5b                   	pop    %rbx
  406de6:	5d                   	pop    %rbp
  406de7:	c3                   	retq   

0000000000406de8 <gsi_parse_json_config_get_next_entry>:
	 * Parameter:   [out] int* p_index - index of of given key OR -1 (if not found)
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_NOT_FOUND *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
enum gsi_prase_json_config_rc gsi_parse_json_config_get_next_entry(char* s_key, int* p_index)
{
  406de8:	55                   	push   %rbp
  406de9:	48 89 e5             	mov    %rsp,%rbp
  406dec:	53                   	push   %rbx
  406ded:	48 83 ec 28          	sub    $0x28,%rsp
  406df1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  406df5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Check input validation
	if ((NULL == s_key) || (NULL == p_index))
  406df9:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  406dfe:	74 07                	je     406e07 <gsi_parse_json_config_get_next_entry+0x1f>
  406e00:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  406e05:	75 41                	jne    406e48 <gsi_parse_json_config_get_next_entry+0x60>
	{
		LOG_ERROR("invalid arguments");
  406e07:	b8 00 00 00 00       	mov    $0x0,%eax
  406e0c:	e8 cb fa ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406e11:	48 89 c3             	mov    %rax,%rbx
  406e14:	b8 00 00 00 00       	mov    $0x0,%eax
  406e19:	e8 39 f8 ff ff       	callq  406657 <gsi_get_saved_file>
  406e1e:	41 b8 bb 00 00 00    	mov    $0xbb,%r8d
  406e24:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406e29:	48 89 da             	mov    %rbx,%rdx
  406e2c:	be 90 9c 40 00       	mov    $0x409c90,%esi
  406e31:	48 89 c7             	mov    %rax,%rdi
  406e34:	b8 00 00 00 00       	mov    $0x0,%eax
  406e39:	e8 82 f8 ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  406e3e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  406e43:	e9 9c 00 00 00       	jmpq   406ee4 <gsi_parse_json_config_get_next_entry+0xfc>
	}

	// Search the key in the map
	for (int i_option = 0; g_config_params_keys[i_option] != NULL; ++i_option)
  406e48:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  406e4f:	eb 34                	jmp    406e85 <gsi_parse_json_config_get_next_entry+0x9d>
	{
		if (0 == strcmp(s_key, g_config_params_keys[i_option]))
  406e51:	8b 45 ec             	mov    -0x14(%rbp),%eax
  406e54:	48 98                	cltq   
  406e56:	48 8b 14 c5 60 b2 60 	mov    0x60b260(,%rax,8),%rdx
  406e5d:	00 
  406e5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  406e62:	48 89 d6             	mov    %rdx,%rsi
  406e65:	48 89 c7             	mov    %rax,%rdi
  406e68:	e8 c3 a8 ff ff       	callq  401730 <strcmp@plt>
  406e6d:	85 c0                	test   %eax,%eax
  406e6f:	75 10                	jne    406e81 <gsi_parse_json_config_get_next_entry+0x99>
		{
			*p_index = i_option;
  406e71:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  406e75:	8b 55 ec             	mov    -0x14(%rbp),%edx
  406e78:	89 10                	mov    %edx,(%rax)
			return GSI_PARSE_JSON_CONFIG_SUCCESS;
  406e7a:	b8 00 00 00 00       	mov    $0x0,%eax
  406e7f:	eb 63                	jmp    406ee4 <gsi_parse_json_config_get_next_entry+0xfc>
		LOG_ERROR("invalid arguments");
		return GSI_PARSE_JSON_CONFIG_INVALID;
	}

	// Search the key in the map
	for (int i_option = 0; g_config_params_keys[i_option] != NULL; ++i_option)
  406e81:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  406e85:	8b 45 ec             	mov    -0x14(%rbp),%eax
  406e88:	48 98                	cltq   
  406e8a:	48 8b 04 c5 60 b2 60 	mov    0x60b260(,%rax,8),%rax
  406e91:	00 
  406e92:	48 85 c0             	test   %rax,%rax
  406e95:	75 ba                	jne    406e51 <gsi_parse_json_config_get_next_entry+0x69>
			return GSI_PARSE_JSON_CONFIG_SUCCESS;
		}
	}

	// Not found so index is -1
	*p_index = -1;
  406e97:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  406e9b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
	LOG_WARNING("key: %s not found", s_key);
  406ea1:	b8 00 00 00 00       	mov    $0x0,%eax
  406ea6:	e8 31 fa ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406eab:	48 89 c3             	mov    %rax,%rbx
  406eae:	b8 00 00 00 00       	mov    $0x0,%eax
  406eb3:	e8 9f f7 ff ff       	callq  406657 <gsi_get_saved_file>
  406eb8:	48 89 c7             	mov    %rax,%rdi
  406ebb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  406ebf:	49 89 c1             	mov    %rax,%r9
  406ec2:	41 b8 cb 00 00 00    	mov    $0xcb,%r8d
  406ec8:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406ecd:	48 89 da             	mov    %rbx,%rdx
  406ed0:	be c8 9c 40 00       	mov    $0x409cc8,%esi
  406ed5:	b8 00 00 00 00       	mov    $0x0,%eax
  406eda:	e8 e1 f7 ff ff       	callq  4066c0 <gsi_is_write_to_log>

	return GSI_PARSE_JSON_CONFIG_NOT_FOUND;
  406edf:	b8 05 00 00 00       	mov    $0x5,%eax
}
  406ee4:	48 83 c4 28          	add    $0x28,%rsp
  406ee8:	5b                   	pop    %rbx
  406ee9:	5d                   	pop    %rbp
  406eea:	c3                   	retq   

0000000000406eeb <gsi_parse_json_config_get_config>:
	 * Parameter:   [in] char* p_argv[] - vector of arguments from command line (argv)
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_OPEN_ERR *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
enum gsi_prase_json_config_rc gsi_parse_json_config_get_config(int i_argc, char* p_argv[])
{
  406eeb:	55                   	push   %rbp
  406eec:	48 89 e5             	mov    %rsp,%rbp
  406eef:	41 54                	push   %r12
  406ef1:	53                   	push   %rbx
  406ef2:	48 83 ec 20          	sub    $0x20,%rsp
  406ef6:	89 7d dc             	mov    %edi,-0x24(%rbp)
  406ef9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  406efd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  406f04:	00 00 
  406f06:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  406f0a:	31 c0                	xor    %eax,%eax
	int i_option_index = 0;
  406f0c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	int i_rc = 0;
  406f13:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)

	// Check input validation
	if ((0 > i_argc) || (NULL == p_argv))
  406f1a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  406f1e:	78 07                	js     406f27 <gsi_parse_json_config_get_config+0x3c>
  406f20:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  406f25:	75 41                	jne    406f68 <gsi_parse_json_config_get_config+0x7d>
	{
		LOG_ERROR("invalid arguments");
  406f27:	b8 00 00 00 00       	mov    $0x0,%eax
  406f2c:	e8 ab f9 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406f31:	48 89 c3             	mov    %rax,%rbx
  406f34:	b8 00 00 00 00       	mov    $0x0,%eax
  406f39:	e8 19 f7 ff ff       	callq  406657 <gsi_get_saved_file>
  406f3e:	41 b8 e1 00 00 00    	mov    $0xe1,%r8d
  406f44:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406f49:	48 89 da             	mov    %rbx,%rdx
  406f4c:	be 90 9c 40 00       	mov    $0x409c90,%esi
  406f51:	48 89 c7             	mov    %rax,%rdi
  406f54:	b8 00 00 00 00       	mov    $0x0,%eax
  406f59:	e8 62 f7 ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  406f5e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  406f63:	e9 e0 00 00 00       	jmpq   407048 <gsi_parse_json_config_get_config+0x15d>
	}

	// Parse command line arguments by getopt_long(), the argument is optional
	i_rc = getopt_long(i_argc, p_argv, "c::", &g_config_cmd_opts, &i_option_index);
  406f68:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  406f6c:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  406f70:	8b 45 dc             	mov    -0x24(%rbp),%eax
  406f73:	49 89 d0             	mov    %rdx,%r8
  406f76:	b9 40 b2 60 00       	mov    $0x60b240,%ecx
  406f7b:	ba fe 9c 40 00       	mov    $0x409cfe,%edx
  406f80:	89 c7                	mov    %eax,%edi
  406f82:	e8 c9 a6 ff ff       	callq  401650 <getopt_long@plt>
  406f87:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if (-1 == i_rc)
  406f8a:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%rbp)
  406f8e:	75 3e                	jne    406fce <gsi_parse_json_config_get_config+0xe3>
	{
		LOG_ERROR("usage error: <a.out> --config=[file]");
  406f90:	b8 00 00 00 00       	mov    $0x0,%eax
  406f95:	e8 42 f9 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  406f9a:	48 89 c3             	mov    %rax,%rbx
  406f9d:	b8 00 00 00 00       	mov    $0x0,%eax
  406fa2:	e8 b0 f6 ff ff       	callq  406657 <gsi_get_saved_file>
  406fa7:	41 b8 e9 00 00 00    	mov    $0xe9,%r8d
  406fad:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  406fb2:	48 89 da             	mov    %rbx,%rdx
  406fb5:	be 08 9d 40 00       	mov    $0x409d08,%esi
  406fba:	48 89 c7             	mov    %rax,%rdi
  406fbd:	b8 00 00 00 00       	mov    $0x0,%eax
  406fc2:	e8 f9 f6 ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_ERROR;
  406fc7:	b8 06 00 00 00       	mov    $0x6,%eax
  406fcc:	eb 7a                	jmp    407048 <gsi_parse_json_config_get_config+0x15d>
	}

	// No argument supplied so run default configuration.
	if (0 == strcmp("", optarg))
  406fce:	48 8b 05 eb 42 20 00 	mov    0x2042eb(%rip),%rax        # 60b2c0 <optarg@@GLIBC_2.2.5>
  406fd5:	0f b6 00             	movzbl (%rax),%eax
  406fd8:	84 c0                	test   %al,%al
  406fda:	75 0c                	jne    406fe8 <gsi_parse_json_config_get_config+0xfd>
	{
		gsi_parse_json_config_init_default_params();
  406fdc:	b8 00 00 00 00       	mov    $0x0,%eax
  406fe1:	e8 81 04 00 00       	callq  407467 <gsi_parse_json_config_init_default_params>
  406fe6:	eb 5b                	jmp    407043 <gsi_parse_json_config_get_config+0x158>
	}
	// Read from config file given in command line
	else
	{
		if (GSI_PARSE_JSON_CONFIG_SUCCESS != gsi_parse_json_config_init_from_config_file(optarg))
  406fe8:	48 8b 05 d1 42 20 00 	mov    0x2042d1(%rip),%rax        # 60b2c0 <optarg@@GLIBC_2.2.5>
  406fef:	48 89 c7             	mov    %rax,%rdi
  406ff2:	e8 15 05 00 00       	callq  40750c <gsi_parse_json_config_init_from_config_file>
  406ff7:	85 c0                	test   %eax,%eax
  406ff9:	74 48                	je     407043 <gsi_parse_json_config_get_config+0x158>
		{
			LOG_ERROR("failed to config parameters from file %s", optarg);
  406ffb:	48 8b 1d be 42 20 00 	mov    0x2042be(%rip),%rbx        # 60b2c0 <optarg@@GLIBC_2.2.5>
  407002:	b8 00 00 00 00       	mov    $0x0,%eax
  407007:	e8 d0 f8 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  40700c:	49 89 c4             	mov    %rax,%r12
  40700f:	b8 00 00 00 00       	mov    $0x0,%eax
  407014:	e8 3e f6 ff ff       	callq  406657 <gsi_get_saved_file>
  407019:	49 89 d9             	mov    %rbx,%r9
  40701c:	41 b8 f7 00 00 00    	mov    $0xf7,%r8d
  407022:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  407027:	4c 89 e2             	mov    %r12,%rdx
  40702a:	be 50 9d 40 00       	mov    $0x409d50,%esi
  40702f:	48 89 c7             	mov    %rax,%rdi
  407032:	b8 00 00 00 00       	mov    $0x0,%eax
  407037:	e8 84 f6 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			return GSI_PARSE_JSON_CONFIG_ERROR;
  40703c:	b8 06 00 00 00       	mov    $0x6,%eax
  407041:	eb 05                	jmp    407048 <gsi_parse_json_config_get_config+0x15d>
		}
	}

	return GSI_PARSE_JSON_CONFIG_SUCCESS;
  407043:	b8 00 00 00 00       	mov    $0x0,%eax
}
  407048:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  40704c:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  407053:	00 00 
  407055:	74 05                	je     40705c <gsi_parse_json_config_get_config+0x171>
  407057:	e8 d4 a5 ff ff       	callq  401630 <__stack_chk_fail@plt>
  40705c:	48 83 c4 20          	add    $0x20,%rsp
  407060:	5b                   	pop    %rbx
  407061:	41 5c                	pop    %r12
  407063:	5d                   	pop    %rbp
  407064:	c3                   	retq   

0000000000407065 <gsi_parse_json_config_parse_main_args>:
	 * Parameter:   [in] int i_index - index of the parameter to set its value
	 * Parameter:   [in] char* s_value - value to set
	 * Return:		None
#############################################################################*/
static void gsi_parse_json_config_parse_main_args(int i_index, char* s_value)
{
  407065:	55                   	push   %rbp
  407066:	48 89 e5             	mov    %rsp,%rbp
  407069:	41 54                	push   %r12
  40706b:	53                   	push   %rbx
  40706c:	48 83 ec 10          	sub    $0x10,%rsp
  407070:	89 7d ec             	mov    %edi,-0x14(%rbp)
  407073:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((0 > i_index) || (NULL == s_value))
  407077:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  40707b:	78 07                	js     407084 <gsi_parse_json_config_parse_main_args+0x1f>
  40707d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  407082:	75 3c                	jne    4070c0 <gsi_parse_json_config_parse_main_args+0x5b>
	{
		LOG_ERROR("invalid arguments");
  407084:	b8 00 00 00 00       	mov    $0x0,%eax
  407089:	e8 4e f8 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  40708e:	48 89 c3             	mov    %rax,%rbx
  407091:	b8 00 00 00 00       	mov    $0x0,%eax
  407096:	e8 bc f5 ff ff       	callq  406657 <gsi_get_saved_file>
  40709b:	41 b8 0e 01 00 00    	mov    $0x10e,%r8d
  4070a1:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  4070a6:	48 89 da             	mov    %rbx,%rdx
  4070a9:	be 90 9c 40 00       	mov    $0x409c90,%esi
  4070ae:	48 89 c7             	mov    %rax,%rdi
  4070b1:	b8 00 00 00 00       	mov    $0x0,%eax
  4070b6:	e8 05 f6 ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return;
  4070bb:	e9 9e 03 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>
	}

	switch(i_index)
  4070c0:	83 7d ec 08          	cmpl   $0x8,-0x14(%rbp)
  4070c4:	0f 87 5d 03 00 00    	ja     407427 <gsi_parse_json_config_parse_main_args+0x3c2>
  4070ca:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4070cd:	48 8b 04 c5 d0 9f 40 	mov    0x409fd0(,%rax,8),%rax
  4070d4:	00 
  4070d5:	ff e0                	jmpq   *%rax
	{
		// Server parameters
		case GSI_PARSE_JSON_PARAM_SERVER_PORT_1:
			g_config_server_params.ui_port1 = atoi(s_value);
  4070d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4070db:	48 89 c7             	mov    %rax,%rdi
  4070de:	e8 cd a7 ff ff       	callq  4018b0 <atoi@plt>
  4070e3:	89 05 37 42 20 00    	mov    %eax,0x204237(%rip)        # 60b320 <g_config_server_params>
			LOG_DEBUG("server_port_1: %d", g_config_server_params.ui_port1);
  4070e9:	8b 1d 31 42 20 00    	mov    0x204231(%rip),%ebx        # 60b320 <g_config_server_params>
  4070ef:	b8 00 00 00 00       	mov    $0x0,%eax
  4070f4:	e8 e3 f7 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  4070f9:	49 89 c4             	mov    %rax,%r12
  4070fc:	b8 00 00 00 00       	mov    $0x0,%eax
  407101:	e8 51 f5 ff ff       	callq  406657 <gsi_get_saved_file>
  407106:	41 89 d9             	mov    %ebx,%r9d
  407109:	41 b8 17 01 00 00    	mov    $0x117,%r8d
  40710f:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  407114:	4c 89 e2             	mov    %r12,%rdx
  407117:	be a0 9d 40 00       	mov    $0x409da0,%esi
  40711c:	48 89 c7             	mov    %rax,%rdi
  40711f:	b8 00 00 00 00       	mov    $0x0,%eax
  407124:	e8 97 f5 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  407129:	e9 30 03 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_PORT_2:
			g_config_server_params.ui_port2 = atoi(s_value);
  40712e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  407132:	48 89 c7             	mov    %rax,%rdi
  407135:	e8 76 a7 ff ff       	callq  4018b0 <atoi@plt>
  40713a:	89 05 e4 41 20 00    	mov    %eax,0x2041e4(%rip)        # 60b324 <g_config_server_params+0x4>
			LOG_DEBUG("server_port_2: %d", g_config_server_params.ui_port2);
  407140:	8b 1d de 41 20 00    	mov    0x2041de(%rip),%ebx        # 60b324 <g_config_server_params+0x4>
  407146:	b8 00 00 00 00       	mov    $0x0,%eax
  40714b:	e8 8c f7 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  407150:	49 89 c4             	mov    %rax,%r12
  407153:	b8 00 00 00 00       	mov    $0x0,%eax
  407158:	e8 fa f4 ff ff       	callq  406657 <gsi_get_saved_file>
  40715d:	41 89 d9             	mov    %ebx,%r9d
  407160:	41 b8 1c 01 00 00    	mov    $0x11c,%r8d
  407166:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  40716b:	4c 89 e2             	mov    %r12,%rdx
  40716e:	be d8 9d 40 00       	mov    $0x409dd8,%esi
  407173:	48 89 c7             	mov    %rax,%rdi
  407176:	b8 00 00 00 00       	mov    $0x0,%eax
  40717b:	e8 40 f5 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  407180:	e9 d9 02 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_PORT_3:
			g_config_server_params.ui_port3 = atoi(s_value);
  407185:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  407189:	48 89 c7             	mov    %rax,%rdi
  40718c:	e8 1f a7 ff ff       	callq  4018b0 <atoi@plt>
  407191:	89 05 91 41 20 00    	mov    %eax,0x204191(%rip)        # 60b328 <g_config_server_params+0x8>
			LOG_DEBUG("server_port_3: %d", g_config_server_params.ui_port3);
  407197:	8b 1d 8b 41 20 00    	mov    0x20418b(%rip),%ebx        # 60b328 <g_config_server_params+0x8>
  40719d:	b8 00 00 00 00       	mov    $0x0,%eax
  4071a2:	e8 35 f7 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  4071a7:	49 89 c4             	mov    %rax,%r12
  4071aa:	b8 00 00 00 00       	mov    $0x0,%eax
  4071af:	e8 a3 f4 ff ff       	callq  406657 <gsi_get_saved_file>
  4071b4:	41 89 d9             	mov    %ebx,%r9d
  4071b7:	41 b8 21 01 00 00    	mov    $0x121,%r8d
  4071bd:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  4071c2:	4c 89 e2             	mov    %r12,%rdx
  4071c5:	be 10 9e 40 00       	mov    $0x409e10,%esi
  4071ca:	48 89 c7             	mov    %rax,%rdi
  4071cd:	b8 00 00 00 00       	mov    $0x0,%eax
  4071d2:	e8 e9 f4 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  4071d7:	e9 82 02 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_IP:
			strcpy(g_config_server_params.s_ip ,s_value);
  4071dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4071e0:	48 89 c6             	mov    %rax,%rsi
  4071e3:	bf 30 b3 60 00       	mov    $0x60b330,%edi
  4071e8:	e8 a3 a3 ff ff       	callq  401590 <strcpy@plt>
			// Replace the '\n' by '\0'
			g_config_server_params.s_ip[strlen(g_config_server_params.s_ip) - 1] = '\0';
  4071ed:	bf 30 b3 60 00       	mov    $0x60b330,%edi
  4071f2:	e8 29 a4 ff ff       	callq  401620 <strlen@plt>
  4071f7:	48 83 e8 01          	sub    $0x1,%rax
  4071fb:	c6 80 30 b3 60 00 00 	movb   $0x0,0x60b330(%rax)
			LOG_DEBUG("server_ip: %s", g_config_server_params.s_ip);
  407202:	b8 00 00 00 00       	mov    $0x0,%eax
  407207:	e8 d0 f6 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  40720c:	48 89 c3             	mov    %rax,%rbx
  40720f:	b8 00 00 00 00       	mov    $0x0,%eax
  407214:	e8 3e f4 ff ff       	callq  406657 <gsi_get_saved_file>
  407219:	41 b9 30 b3 60 00    	mov    $0x60b330,%r9d
  40721f:	41 b8 28 01 00 00    	mov    $0x128,%r8d
  407225:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  40722a:	48 89 da             	mov    %rbx,%rdx
  40722d:	be 48 9e 40 00       	mov    $0x409e48,%esi
  407232:	48 89 c7             	mov    %rax,%rdi
  407235:	b8 00 00 00 00       	mov    $0x0,%eax
  40723a:	e8 81 f4 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  40723f:	e9 1a 02 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_TIMER:
			g_config_server_params.i_server_timer = atoi(s_value);
  407244:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  407248:	48 89 c7             	mov    %rax,%rdi
  40724b:	e8 60 a6 ff ff       	callq  4018b0 <atoi@plt>
  407250:	89 05 d6 40 20 00    	mov    %eax,0x2040d6(%rip)        # 60b32c <g_config_server_params+0xc>
			LOG_DEBUG("server_timer: %d", g_config_server_params.i_server_timer);
  407256:	8b 1d d0 40 20 00    	mov    0x2040d0(%rip),%ebx        # 60b32c <g_config_server_params+0xc>
  40725c:	b8 00 00 00 00       	mov    $0x0,%eax
  407261:	e8 76 f6 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  407266:	49 89 c4             	mov    %rax,%r12
  407269:	b8 00 00 00 00       	mov    $0x0,%eax
  40726e:	e8 e4 f3 ff ff       	callq  406657 <gsi_get_saved_file>
  407273:	41 89 d9             	mov    %ebx,%r9d
  407276:	41 b8 2d 01 00 00    	mov    $0x12d,%r8d
  40727c:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  407281:	4c 89 e2             	mov    %r12,%rdx
  407284:	be 78 9e 40 00       	mov    $0x409e78,%esi
  407289:	48 89 c7             	mov    %rax,%rdi
  40728c:	b8 00 00 00 00       	mov    $0x0,%eax
  407291:	e8 2a f4 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  407296:	e9 c3 01 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_DATA:
			strcpy(g_config_server_params.s_server_data_file, s_value);
  40729b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40729f:	48 89 c6             	mov    %rax,%rsi
  4072a2:	bf 40 b3 60 00       	mov    $0x60b340,%edi
  4072a7:	e8 e4 a2 ff ff       	callq  401590 <strcpy@plt>
			// Replace the '\n' by '\0'
			g_config_server_params.s_server_data_file[strlen(g_config_server_params.s_server_data_file) - 1] = '\0';
  4072ac:	bf 40 b3 60 00       	mov    $0x60b340,%edi
  4072b1:	e8 6a a3 ff ff       	callq  401620 <strlen@plt>
  4072b6:	48 83 e8 01          	sub    $0x1,%rax
  4072ba:	c6 80 40 b3 60 00 00 	movb   $0x0,0x60b340(%rax)
			LOG_DEBUG("server_data: %s", g_config_server_params.s_server_data_file);
  4072c1:	b8 00 00 00 00       	mov    $0x0,%eax
  4072c6:	e8 11 f6 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  4072cb:	48 89 c3             	mov    %rax,%rbx
  4072ce:	b8 00 00 00 00       	mov    $0x0,%eax
  4072d3:	e8 7f f3 ff ff       	callq  406657 <gsi_get_saved_file>
  4072d8:	41 b9 40 b3 60 00    	mov    $0x60b340,%r9d
  4072de:	41 b8 34 01 00 00    	mov    $0x134,%r8d
  4072e4:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  4072e9:	48 89 da             	mov    %rbx,%rdx
  4072ec:	be b0 9e 40 00       	mov    $0x409eb0,%esi
  4072f1:	48 89 c7             	mov    %rax,%rdi
  4072f4:	b8 00 00 00 00       	mov    $0x0,%eax
  4072f9:	e8 c2 f3 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  4072fe:	e9 5b 01 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		// Client parameters
		case GSI_PARSE_JSON_PARAM_CLIENT_PORT:
			g_config_client_params.ui_port = atoi(s_value);
  407303:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  407307:	48 89 c7             	mov    %rax,%rdi
  40730a:	e8 a1 a5 ff ff       	callq  4018b0 <atoi@plt>
  40730f:	89 05 ab 40 20 00    	mov    %eax,0x2040ab(%rip)        # 60b3c0 <g_config_client_params>
			LOG_DEBUG("client_port: %d", g_config_client_params.ui_port);
  407315:	8b 1d a5 40 20 00    	mov    0x2040a5(%rip),%ebx        # 60b3c0 <g_config_client_params>
  40731b:	b8 00 00 00 00       	mov    $0x0,%eax
  407320:	e8 b7 f5 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  407325:	49 89 c4             	mov    %rax,%r12
  407328:	b8 00 00 00 00       	mov    $0x0,%eax
  40732d:	e8 25 f3 ff ff       	callq  406657 <gsi_get_saved_file>
  407332:	41 89 d9             	mov    %ebx,%r9d
  407335:	41 b8 3a 01 00 00    	mov    $0x13a,%r8d
  40733b:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  407340:	4c 89 e2             	mov    %r12,%rdx
  407343:	be e8 9e 40 00       	mov    $0x409ee8,%esi
  407348:	48 89 c7             	mov    %rax,%rdi
  40734b:	b8 00 00 00 00       	mov    $0x0,%eax
  407350:	e8 6b f3 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  407355:	e9 04 01 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_CLIENT_IP:
			strcpy(g_config_client_params.s_ip ,s_value);
  40735a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40735e:	48 89 c6             	mov    %rax,%rsi
  407361:	bf c4 b3 60 00       	mov    $0x60b3c4,%edi
  407366:	e8 25 a2 ff ff       	callq  401590 <strcpy@plt>
			// Replace the '\n' by '\0'
			g_config_client_params.s_ip[strlen(g_config_client_params.s_ip) - 1] = '\0';
  40736b:	bf c4 b3 60 00       	mov    $0x60b3c4,%edi
  407370:	e8 ab a2 ff ff       	callq  401620 <strlen@plt>
  407375:	48 83 e8 01          	sub    $0x1,%rax
  407379:	c6 80 c4 b3 60 00 00 	movb   $0x0,0x60b3c4(%rax)
			LOG_DEBUG("client_ip: %s", g_config_client_params.s_ip);
  407380:	b8 00 00 00 00       	mov    $0x0,%eax
  407385:	e8 52 f5 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  40738a:	48 89 c3             	mov    %rax,%rbx
  40738d:	b8 00 00 00 00       	mov    $0x0,%eax
  407392:	e8 c0 f2 ff ff       	callq  406657 <gsi_get_saved_file>
  407397:	41 b9 c4 b3 60 00    	mov    $0x60b3c4,%r9d
  40739d:	41 b8 41 01 00 00    	mov    $0x141,%r8d
  4073a3:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  4073a8:	48 89 da             	mov    %rbx,%rdx
  4073ab:	be 20 9f 40 00       	mov    $0x409f20,%esi
  4073b0:	48 89 c7             	mov    %rax,%rdi
  4073b3:	b8 00 00 00 00       	mov    $0x0,%eax
  4073b8:	e8 03 f3 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  4073bd:	e9 9c 00 00 00       	jmpq   40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_CLIENT_MSG:
			strcpy(g_config_client_params.s_messages_file ,s_value);
  4073c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4073c6:	48 89 c6             	mov    %rax,%rsi
  4073c9:	bf d4 b3 60 00       	mov    $0x60b3d4,%edi
  4073ce:	e8 bd a1 ff ff       	callq  401590 <strcpy@plt>
			// Replace the '\n' by '\0'
			g_config_client_params.s_messages_file[strlen(g_config_client_params.s_messages_file) - 1] = '\0';
  4073d3:	bf d4 b3 60 00       	mov    $0x60b3d4,%edi
  4073d8:	e8 43 a2 ff ff       	callq  401620 <strlen@plt>
  4073dd:	48 83 e8 01          	sub    $0x1,%rax
  4073e1:	c6 80 d4 b3 60 00 00 	movb   $0x0,0x60b3d4(%rax)
			LOG_DEBUG("client_messages: %s", g_config_client_params.s_messages_file);
  4073e8:	b8 00 00 00 00       	mov    $0x0,%eax
  4073ed:	e8 ea f4 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  4073f2:	48 89 c3             	mov    %rax,%rbx
  4073f5:	b8 00 00 00 00       	mov    $0x0,%eax
  4073fa:	e8 58 f2 ff ff       	callq  406657 <gsi_get_saved_file>
  4073ff:	41 b9 d4 b3 60 00    	mov    $0x60b3d4,%r9d
  407405:	41 b8 48 01 00 00    	mov    $0x148,%r8d
  40740b:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  407410:	48 89 da             	mov    %rbx,%rdx
  407413:	be 50 9f 40 00       	mov    $0x409f50,%esi
  407418:	48 89 c7             	mov    %rax,%rdi
  40741b:	b8 00 00 00 00       	mov    $0x0,%eax
  407420:	e8 9b f2 ff ff       	callq  4066c0 <gsi_is_write_to_log>
			break;
  407425:	eb 37                	jmp    40745e <gsi_parse_json_config_parse_main_args+0x3f9>

		default:
			LOG_ERROR("index is not match to any option");
  407427:	b8 00 00 00 00       	mov    $0x0,%eax
  40742c:	e8 ab f4 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  407431:	48 89 c3             	mov    %rax,%rbx
  407434:	b8 00 00 00 00       	mov    $0x0,%eax
  407439:	e8 19 f2 ff ff       	callq  406657 <gsi_get_saved_file>
  40743e:	41 b8 4c 01 00 00    	mov    $0x14c,%r8d
  407444:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  407449:	48 89 da             	mov    %rbx,%rdx
  40744c:	be 88 9f 40 00       	mov    $0x409f88,%esi
  407451:	48 89 c7             	mov    %rax,%rdi
  407454:	b8 00 00 00 00       	mov    $0x0,%eax
  407459:	e8 62 f2 ff ff       	callq  4066c0 <gsi_is_write_to_log>
	}
}
  40745e:	48 83 c4 10          	add    $0x10,%rsp
  407462:	5b                   	pop    %rbx
  407463:	41 5c                	pop    %r12
  407465:	5d                   	pop    %rbp
  407466:	c3                   	retq   

0000000000407467 <gsi_parse_json_config_init_default_params>:
	 * Description: Initialize default parameters to server structure
	 * Parameter:   [in] None
	 * Return:		None
#############################################################################*/
static void gsi_parse_json_config_init_default_params()
{
  407467:	55                   	push   %rbp
  407468:	48 89 e5             	mov    %rsp,%rbp
	// Server parameters
	g_config_server_params.ui_port1 = 65533;
  40746b:	c7 05 ab 3e 20 00 fd 	movl   $0xfffd,0x203eab(%rip)        # 60b320 <g_config_server_params>
  407472:	ff 00 00 
	g_config_server_params.ui_port2 = 65534;
  407475:	c7 05 a5 3e 20 00 fe 	movl   $0xfffe,0x203ea5(%rip)        # 60b324 <g_config_server_params+0x4>
  40747c:	ff 00 00 
	g_config_server_params.ui_port3 = 65535;
  40747f:	c7 05 9f 3e 20 00 ff 	movl   $0xffff,0x203e9f(%rip)        # 60b328 <g_config_server_params+0x8>
  407486:	ff 00 00 
	g_config_server_params.i_server_timer = 0;
  407489:	c7 05 99 3e 20 00 00 	movl   $0x0,0x203e99(%rip)        # 60b32c <g_config_server_params+0xc>
  407490:	00 00 00 

	strcpy(g_config_server_params.s_ip, "127.0.0.1");
  407493:	48 b8 31 32 37 2e 30 	movabs $0x2e302e302e373231,%rax
  40749a:	2e 30 2e 
  40749d:	48 89 05 8c 3e 20 00 	mov    %rax,0x203e8c(%rip)        # 60b330 <g_config_server_params+0x10>
  4074a4:	66 c7 05 8b 3e 20 00 	movw   $0x31,0x203e8b(%rip)        # 60b338 <g_config_server_params+0x18>
  4074ab:	31 00 
	strcpy(g_config_server_params.s_server_data_file, "../src/server/test_files/server_data.txt");
  4074ad:	48 b8 2e 2e 2f 73 72 	movabs $0x732f6372732f2e2e,%rax
  4074b4:	63 2f 73 
  4074b7:	48 89 05 82 3e 20 00 	mov    %rax,0x203e82(%rip)        # 60b340 <g_config_server_params+0x20>
  4074be:	48 b8 65 72 76 65 72 	movabs $0x65742f7265767265,%rax
  4074c5:	2f 74 65 
  4074c8:	48 89 05 79 3e 20 00 	mov    %rax,0x203e79(%rip)        # 60b348 <g_config_server_params+0x28>
  4074cf:	48 b8 73 74 5f 66 69 	movabs $0x73656c69665f7473,%rax
  4074d6:	6c 65 73 
  4074d9:	48 89 05 70 3e 20 00 	mov    %rax,0x203e70(%rip)        # 60b350 <g_config_server_params+0x30>
  4074e0:	48 b8 2f 73 65 72 76 	movabs $0x5f7265767265732f,%rax
  4074e7:	65 72 5f 
  4074ea:	48 89 05 67 3e 20 00 	mov    %rax,0x203e67(%rip)        # 60b358 <g_config_server_params+0x38>
  4074f1:	48 b8 64 61 74 61 2e 	movabs $0x7478742e61746164,%rax
  4074f8:	74 78 74 
  4074fb:	48 89 05 5e 3e 20 00 	mov    %rax,0x203e5e(%rip)        # 60b360 <g_config_server_params+0x40>
  407502:	c6 05 5f 3e 20 00 00 	movb   $0x0,0x203e5f(%rip)        # 60b368 <g_config_server_params+0x48>
}
  407509:	90                   	nop
  40750a:	5d                   	pop    %rbp
  40750b:	c3                   	retq   

000000000040750c <gsi_parse_json_config_init_from_config_file>:
	 * Parameter:   [in] char* s_config_file - configuration file
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_OPEN_ERR *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
static enum gsi_prase_json_config_rc gsi_parse_json_config_init_from_config_file(char* s_config_file)
{
  40750c:	55                   	push   %rbp
  40750d:	48 89 e5             	mov    %rsp,%rbp
  407510:	53                   	push   %rbx
  407511:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp
  407518:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  40751f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  407526:	00 00 
  407528:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  40752c:	31 c0                	xor    %eax,%eax
	int i_param_index = 0;
  40752e:	c7 85 d0 fe ff ff 00 	movl   $0x0,-0x130(%rbp)
  407535:	00 00 00 
	int i_rc = GSI_PARSE_JSON_CONFIG_SUCCESS;
  407538:	c7 85 d4 fe ff ff 00 	movl   $0x0,-0x12c(%rbp)
  40753f:	00 00 00 
	char s_key[GSI_PARSE_JSON_CONFIG_MAX_KEY_LEN];
	char s_value[GSI_PARSE_JSON_CONFIG_MAX_VALUE_LEN];
	FILE* f_config = NULL;
  407542:	48 c7 85 d8 fe ff ff 	movq   $0x0,-0x128(%rbp)
  407549:	00 00 00 00 

	// Check input validation
	if (NULL == s_config_file)
  40754d:	48 83 bd c8 fe ff ff 	cmpq   $0x0,-0x138(%rbp)
  407554:	00 
  407555:	75 41                	jne    407598 <gsi_parse_json_config_init_from_config_file+0x8c>
	{
		LOG_ERROR("invalid argument");
  407557:	b8 00 00 00 00       	mov    $0x0,%eax
  40755c:	e8 7b f3 ff ff       	callq  4068dc <gsi_is_gen_timestamp>
  407561:	48 89 c3             	mov    %rax,%rbx
  407564:	b8 00 00 00 00       	mov    $0x0,%eax
  407569:	e8 e9 f0 ff ff       	callq  406657 <gsi_get_saved_file>
  40756e:	41 b8 74 01 00 00    	mov    $0x174,%r8d
  407574:	b9 70 9a 40 00       	mov    $0x409a70,%ecx
  407579:	48 89 da             	mov    %rbx,%rdx
  40757c:	be 08 9b 40 00       	mov    $0x409b08,%esi
  407581:	48 89 c7             	mov    %rax,%rdi
  407584:	b8 00 00 00 00       	mov    $0x0,%eax
  407589:	e8 32 f1 ff ff       	callq  4066c0 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  40758e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  407593:	e9 f9 00 00 00       	jmpq   407691 <gsi_parse_json_config_init_from_config_file+0x185>
	}

	// Open config file
	f_config = gsi_parse_json_config_open(s_config_file);
  407598:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
  40759f:	48 89 c7             	mov    %rax,%rdi
  4075a2:	e8 7b f4 ff ff       	callq  406a22 <gsi_parse_json_config_open>
  4075a7:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
	if (NULL == f_config)
  4075ae:	48 83 bd d8 fe ff ff 	cmpq   $0x0,-0x128(%rbp)
  4075b5:	00 
  4075b6:	75 0a                	jne    4075c2 <gsi_parse_json_config_init_from_config_file+0xb6>
	{
		return GSI_PARSE_JSON_CONFIG_OPEN_ERR;
  4075b8:	b8 01 00 00 00       	mov    $0x1,%eax
  4075bd:	e9 cf 00 00 00       	jmpq   407691 <gsi_parse_json_config_init_from_config_file+0x185>

	// Main loop to read all config parameters
	while (1)
	{
		// Reset buffers
		memset(s_key, 0, sizeof(s_key));
  4075c2:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  4075c9:	ba 80 00 00 00       	mov    $0x80,%edx
  4075ce:	be 00 00 00 00       	mov    $0x0,%esi
  4075d3:	48 89 c7             	mov    %rax,%rdi
  4075d6:	e8 d5 a0 ff ff       	callq  4016b0 <memset@plt>
		memset(s_value, 0, sizeof(s_value));
  4075db:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  4075e2:	ba 80 00 00 00       	mov    $0x80,%edx
  4075e7:	be 00 00 00 00       	mov    $0x0,%esi
  4075ec:	48 89 c7             	mov    %rax,%rdi
  4075ef:	e8 bc a0 ff ff       	callq  4016b0 <memset@plt>

		// Read the next line from config file
		i_rc = gsi_parse_json_config_read_line(f_config, s_key, s_value);
  4075f4:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
  4075fb:	48 8d 8d e0 fe ff ff 	lea    -0x120(%rbp),%rcx
  407602:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
  407609:	48 89 ce             	mov    %rcx,%rsi
  40760c:	48 89 c7             	mov    %rax,%rdi
  40760f:	e8 80 f5 ff ff       	callq  406b94 <gsi_parse_json_config_read_line>
  407614:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%rbp)
		if (GSI_PARSE_JSON_CONFIG_SUCCESS != i_rc)
  40761a:	83 bd d4 fe ff ff 00 	cmpl   $0x0,-0x12c(%rbp)
  407621:	75 45                	jne    407668 <gsi_parse_json_config_init_from_config_file+0x15c>
		{
			break;
		}

		// Get the key index in map
		if (GSI_PARSE_JSON_CONFIG_SUCCESS != gsi_parse_json_config_get_next_entry(s_key, &i_param_index))
  407623:	48 8d 95 d0 fe ff ff 	lea    -0x130(%rbp),%rdx
  40762a:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  407631:	48 89 d6             	mov    %rdx,%rsi
  407634:	48 89 c7             	mov    %rax,%rdi
  407637:	e8 ac f7 ff ff       	callq  406de8 <gsi_parse_json_config_get_next_entry>
  40763c:	85 c0                	test   %eax,%eax
  40763e:	74 0c                	je     40764c <gsi_parse_json_config_init_from_config_file+0x140>
		{
			i_rc = GSI_PARSE_JSON_CONFIG_NOT_FOUND;
  407640:	c7 85 d4 fe ff ff 05 	movl   $0x5,-0x12c(%rbp)
  407647:	00 00 00 
			break;
  40764a:	eb 1d                	jmp    407669 <gsi_parse_json_config_init_from_config_file+0x15d>
		}

		// Set value at given index
		gsi_parse_json_config_parse_main_args(i_param_index, s_value);
  40764c:	8b 85 d0 fe ff ff    	mov    -0x130(%rbp),%eax
  407652:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
  407659:	48 89 d6             	mov    %rdx,%rsi
  40765c:	89 c7                	mov    %eax,%edi
  40765e:	e8 02 fa ff ff       	callq  407065 <gsi_parse_json_config_parse_main_args>
	}
  407663:	e9 5a ff ff ff       	jmpq   4075c2 <gsi_parse_json_config_init_from_config_file+0xb6>

		// Read the next line from config file
		i_rc = gsi_parse_json_config_read_line(f_config, s_key, s_value);
		if (GSI_PARSE_JSON_CONFIG_SUCCESS != i_rc)
		{
			break;
  407668:	90                   	nop
		// Set value at given index
		gsi_parse_json_config_parse_main_args(i_param_index, s_value);
	}

	// Close config file
	gsi_parse_json_config_close(f_config);
  407669:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
  407670:	48 89 c7             	mov    %rax,%rdi
  407673:	e8 70 f4 ff ff       	callq  406ae8 <gsi_parse_json_config_close>

	if (GSI_PARSE_JSON_CONFIG_EOF == i_rc)
  407678:	83 bd d4 fe ff ff 04 	cmpl   $0x4,-0x12c(%rbp)
  40767f:	75 0a                	jne    40768b <gsi_parse_json_config_init_from_config_file+0x17f>
	{
		i_rc = GSI_PARSE_JSON_CONFIG_SUCCESS;
  407681:	c7 85 d4 fe ff ff 00 	movl   $0x0,-0x12c(%rbp)
  407688:	00 00 00 
	}

	return i_rc;
  40768b:	8b 85 d4 fe ff ff    	mov    -0x12c(%rbp),%eax
}
  407691:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  407695:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
  40769c:	00 00 
  40769e:	74 05                	je     4076a5 <gsi_parse_json_config_init_from_config_file+0x199>
  4076a0:	e8 8b 9f ff ff       	callq  401630 <__stack_chk_fail@plt>
  4076a5:	48 81 c4 38 01 00 00 	add    $0x138,%rsp
  4076ac:	5b                   	pop    %rbx
  4076ad:	5d                   	pop    %rbp
  4076ae:	c3                   	retq   

00000000004076af <gsi_is_thread_pool_create>:
	 * Parameter:   [in] int i_queue_size - size of the queue
	 * Return: 	    Success - pointer to new thread_pool object
	 * 				Failure - NULL
#############################################################################*/
gsi_thread_pool_t* gsi_is_thread_pool_create(int i_thread_count, int i_queue_size)
{
  4076af:	55                   	push   %rbp
  4076b0:	48 89 e5             	mov    %rsp,%rbp
  4076b3:	48 83 ec 20          	sub    $0x20,%rsp
  4076b7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  4076ba:	89 75 e8             	mov    %esi,-0x18(%rbp)
	gsi_thread_pool_t* p_pool = NULL;
  4076bd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  4076c4:	00 

	// Check input validation
	if ((0 >= i_thread_count) || (GSI_IS_MAX_THREADS < i_thread_count) ||
  4076c5:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  4076c9:	7e 15                	jle    4076e0 <gsi_is_thread_pool_create+0x31>
  4076cb:	83 7d ec 05          	cmpl   $0x5,-0x14(%rbp)
  4076cf:	7f 0f                	jg     4076e0 <gsi_is_thread_pool_create+0x31>
  4076d1:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  4076d5:	7e 09                	jle    4076e0 <gsi_is_thread_pool_create+0x31>
		(0 >= i_queue_size)   || (GSI_IS_MAX_QUEUE_SIZE < i_queue_size))
  4076d7:	81 7d e8 c8 00 00 00 	cmpl   $0xc8,-0x18(%rbp)
  4076de:	7e 14                	jle    4076f4 <gsi_is_thread_pool_create+0x45>
	{
		printf("gsi_is_thread_pool_create: invalid arguments\n");
  4076e0:	bf 18 a0 40 00       	mov    $0x40a018,%edi
  4076e5:	e8 c6 9e ff ff       	callq  4015b0 <puts@plt>
		return NULL;
  4076ea:	b8 00 00 00 00       	mov    $0x0,%eax
  4076ef:	e9 35 02 00 00       	jmpq   407929 <gsi_is_thread_pool_create+0x27a>
	}

	// Allocate new thread pool
	p_pool = (gsi_thread_pool_t*) malloc(sizeof(gsi_thread_pool_t));
  4076f4:	bf 88 00 00 00       	mov    $0x88,%edi
  4076f9:	e8 e2 a0 ff ff       	callq  4017e0 <malloc@plt>
  4076fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (NULL == p_pool)
  407702:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  407707:	75 14                	jne    40771d <gsi_is_thread_pool_create+0x6e>
	{
		printf("gsi_is_thread_pool_create: malloc failed\n");
  407709:	bf 48 a0 40 00       	mov    $0x40a048,%edi
  40770e:	e8 9d 9e ff ff       	callq  4015b0 <puts@plt>
		return NULL;
  407713:	b8 00 00 00 00       	mov    $0x0,%eax
  407718:	e9 0c 02 00 00       	jmpq   407929 <gsi_is_thread_pool_create+0x27a>
	}

	// Update fields
	p_pool->i_thread_count = 0;
  40771d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407721:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%rax)
	p_pool->i_queue_size = i_queue_size;
  407728:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40772c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  40772f:	89 50 6c             	mov    %edx,0x6c(%rax)
	p_pool->i_head = 0;
  407732:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407736:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
	p_pool->i_tail = 0;
  40773d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407741:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%rax)
	p_pool->i_count = 0;
  407748:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40774c:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%rax)
	p_pool->i_shutdown = 0;
  407753:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407757:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	p_pool->i_started = 0;
  40775e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407762:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  407769:	00 00 00 

	// Allocate array of threads
	p_pool->p_threads = (pthread_t*)malloc(sizeof(pthread_t) * i_thread_count);
  40776c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  40776f:	48 98                	cltq   
  407771:	48 c1 e0 03          	shl    $0x3,%rax
  407775:	48 89 c7             	mov    %rax,%rdi
  407778:	e8 63 a0 ff ff       	callq  4017e0 <malloc@plt>
  40777d:	48 89 c2             	mov    %rax,%rdx
  407780:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407784:	48 89 50 58          	mov    %rdx,0x58(%rax)
	if (NULL == p_pool->p_threads)
  407788:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40778c:	48 8b 40 58          	mov    0x58(%rax),%rax
  407790:	48 85 c0             	test   %rax,%rax
  407793:	75 16                	jne    4077ab <gsi_is_thread_pool_create+0xfc>
	{
		free(p_pool);
  407795:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407799:	48 89 c7             	mov    %rax,%rdi
  40779c:	e8 af 9d ff ff       	callq  401550 <free@plt>
		return NULL;
  4077a1:	b8 00 00 00 00       	mov    $0x0,%eax
  4077a6:	e9 7e 01 00 00       	jmpq   407929 <gsi_is_thread_pool_create+0x27a>
	}

	// Allocate queue of tasks
	p_pool->queue = (gsi_thread_pool_task_t*)malloc(sizeof(gsi_thread_pool_task_t) * i_queue_size);
  4077ab:	8b 45 e8             	mov    -0x18(%rbp),%eax
  4077ae:	48 98                	cltq   
  4077b0:	48 c1 e0 04          	shl    $0x4,%rax
  4077b4:	48 89 c7             	mov    %rax,%rdi
  4077b7:	e8 24 a0 ff ff       	callq  4017e0 <malloc@plt>
  4077bc:	48 89 c2             	mov    %rax,%rdx
  4077bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4077c3:	48 89 50 60          	mov    %rdx,0x60(%rax)
	if (NULL == p_pool->queue)
  4077c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4077cb:	48 8b 40 60          	mov    0x60(%rax),%rax
  4077cf:	48 85 c0             	test   %rax,%rax
  4077d2:	75 26                	jne    4077fa <gsi_is_thread_pool_create+0x14b>
	{
		free(p_pool->p_threads);
  4077d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4077d8:	48 8b 40 58          	mov    0x58(%rax),%rax
  4077dc:	48 89 c7             	mov    %rax,%rdi
  4077df:	e8 6c 9d ff ff       	callq  401550 <free@plt>
		free(p_pool);
  4077e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4077e8:	48 89 c7             	mov    %rax,%rdi
  4077eb:	e8 60 9d ff ff       	callq  401550 <free@plt>
		return NULL;
  4077f0:	b8 00 00 00 00       	mov    $0x0,%eax
  4077f5:	e9 2f 01 00 00       	jmpq   407929 <gsi_is_thread_pool_create+0x27a>
	}

	// Init the mutex
	if (0 != pthread_mutex_init(&(p_pool->lock), NULL))
  4077fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4077fe:	be 00 00 00 00       	mov    $0x0,%esi
  407803:	48 89 c7             	mov    %rax,%rdi
  407806:	e8 f5 a0 ff ff       	callq  401900 <pthread_mutex_init@plt>
  40780b:	85 c0                	test   %eax,%eax
  40780d:	74 36                	je     407845 <gsi_is_thread_pool_create+0x196>
	{
		free(p_pool->queue);
  40780f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407813:	48 8b 40 60          	mov    0x60(%rax),%rax
  407817:	48 89 c7             	mov    %rax,%rdi
  40781a:	e8 31 9d ff ff       	callq  401550 <free@plt>
		free(p_pool->p_threads);
  40781f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407823:	48 8b 40 58          	mov    0x58(%rax),%rax
  407827:	48 89 c7             	mov    %rax,%rdi
  40782a:	e8 21 9d ff ff       	callq  401550 <free@plt>
		free(p_pool);
  40782f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407833:	48 89 c7             	mov    %rax,%rdi
  407836:	e8 15 9d ff ff       	callq  401550 <free@plt>
		return NULL;
  40783b:	b8 00 00 00 00       	mov    $0x0,%eax
  407840:	e9 e4 00 00 00       	jmpq   407929 <gsi_is_thread_pool_create+0x27a>
	}

	// Init the condition variable
	if (0 != pthread_cond_init(&(p_pool->notify), NULL))
  407845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407849:	48 83 c0 28          	add    $0x28,%rax
  40784d:	be 00 00 00 00       	mov    $0x0,%esi
  407852:	48 89 c7             	mov    %rax,%rdi
  407855:	e8 66 9f ff ff       	callq  4017c0 <pthread_cond_init@plt>
  40785a:	85 c0                	test   %eax,%eax
  40785c:	74 42                	je     4078a0 <gsi_is_thread_pool_create+0x1f1>
	{
		pthread_mutex_destroy(&(p_pool->lock));
  40785e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407862:	48 89 c7             	mov    %rax,%rdi
  407865:	e8 26 9e ff ff       	callq  401690 <pthread_mutex_destroy@plt>
		free(p_pool->queue);
  40786a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40786e:	48 8b 40 60          	mov    0x60(%rax),%rax
  407872:	48 89 c7             	mov    %rax,%rdi
  407875:	e8 d6 9c ff ff       	callq  401550 <free@plt>
		free(p_pool->p_threads);
  40787a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40787e:	48 8b 40 58          	mov    0x58(%rax),%rax
  407882:	48 89 c7             	mov    %rax,%rdi
  407885:	e8 c6 9c ff ff       	callq  401550 <free@plt>
		free(p_pool);
  40788a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40788e:	48 89 c7             	mov    %rax,%rdi
  407891:	e8 ba 9c ff ff       	callq  401550 <free@plt>
		return NULL;
  407896:	b8 00 00 00 00       	mov    $0x0,%eax
  40789b:	e9 89 00 00 00       	jmpq   407929 <gsi_is_thread_pool_create+0x27a>
	}

	// Start worker threads
	for (int i = 0; i < i_thread_count; ++i)
  4078a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  4078a7:	eb 74                	jmp    40791d <gsi_is_thread_pool_create+0x26e>
	{
		if (0 != pthread_create(&(p_pool->p_threads[i]), NULL, gsi_is_thread_run, p_pool))
  4078a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4078ad:	48 8b 40 58          	mov    0x58(%rax),%rax
  4078b1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  4078b4:	48 63 d2             	movslq %edx,%rdx
  4078b7:	48 c1 e2 03          	shl    $0x3,%rdx
  4078bb:	48 8d 3c 10          	lea    (%rax,%rdx,1),%rdi
  4078bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4078c3:	48 89 c1             	mov    %rax,%rcx
  4078c6:	ba 43 7b 40 00       	mov    $0x407b43,%edx
  4078cb:	be 00 00 00 00       	mov    $0x0,%esi
  4078d0:	e8 8b 9c ff ff       	callq  401560 <pthread_create@plt>
  4078d5:	85 c0                	test   %eax,%eax
  4078d7:	74 18                	je     4078f1 <gsi_is_thread_pool_create+0x242>
		{
			gsi_is_thread_pool_destroy(p_pool, GSI_TP_DESTROY_IMMIDIATE);
  4078d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4078dd:	be 02 00 00 00       	mov    $0x2,%esi
  4078e2:	48 89 c7             	mov    %rax,%rdi
  4078e5:	e8 5e 01 00 00       	callq  407a48 <gsi_is_thread_pool_destroy>
			return NULL;
  4078ea:	b8 00 00 00 00       	mov    $0x0,%eax
  4078ef:	eb 38                	jmp    407929 <gsi_is_thread_pool_create+0x27a>
		}

		// Add 1 to the number of current working threads
		p_pool->i_thread_count++;
  4078f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4078f5:	8b 40 68             	mov    0x68(%rax),%eax
  4078f8:	8d 50 01             	lea    0x1(%rax),%edx
  4078fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4078ff:	89 50 68             	mov    %edx,0x68(%rax)
		p_pool->i_started++;
  407902:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407906:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
  40790c:	8d 50 01             	lea    0x1(%rax),%edx
  40790f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407913:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
		free(p_pool);
		return NULL;
	}

	// Start worker threads
	for (int i = 0; i < i_thread_count; ++i)
  407919:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  40791d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  407920:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  407923:	7c 84                	jl     4078a9 <gsi_is_thread_pool_create+0x1fa>
		// Add 1 to the number of current working threads
		p_pool->i_thread_count++;
		p_pool->i_started++;
	}

	return p_pool;
  407925:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  407929:	c9                   	leaveq 
  40792a:	c3                   	retq   

000000000040792b <gsi_is_thread_pool_add>:
	 * Parameter:   [in] void* args - Argument to be passed to the function.
	 * Return: 	    Success - GSI_TP_RC_SUCCESS
	 * 				Failure - GSI_TP_RC_ERROR *OR* GSI_TP_RC_INVALID
#############################################################################*/
enum gsi_thread_pool_rc gsi_is_thread_pool_add(gsi_thread_pool_t* p_pool, thread_func_t thread_func, void* args)
{
  40792b:	55                   	push   %rbp
  40792c:	48 89 e5             	mov    %rsp,%rbp
  40792f:	48 83 ec 20          	sub    $0x20,%rsp
  407933:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  407937:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40793b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// Check input validation
	if ((NULL == p_pool) || (NULL == thread_func))
  40793f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  407944:	74 07                	je     40794d <gsi_is_thread_pool_add+0x22>
  407946:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  40794b:	75 0a                	jne    407957 <gsi_is_thread_pool_add+0x2c>
	{
		return GSI_TP_RC_INVALID;
  40794d:	b8 02 00 00 00       	mov    $0x2,%eax
  407952:	e9 ef 00 00 00       	jmpq   407a46 <gsi_is_thread_pool_add+0x11b>
	}

	// Try to lock the mutex to own the thread pool
	if (0 != pthread_mutex_lock(&(p_pool->lock)))
  407957:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40795b:	48 89 c7             	mov    %rax,%rdi
  40795e:	e8 bd 9f ff ff       	callq  401920 <pthread_mutex_lock@plt>
  407963:	85 c0                	test   %eax,%eax
  407965:	74 0a                	je     407971 <gsi_is_thread_pool_add+0x46>
	{
		return GSI_TP_RC_ERROR;
  407967:	b8 01 00 00 00       	mov    $0x1,%eax
  40796c:	e9 d5 00 00 00       	jmpq   407a46 <gsi_is_thread_pool_add+0x11b>
	}

	// Check if the queue is full
	if (p_pool->i_count == p_pool->i_queue_size)
  407971:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407975:	8b 50 78             	mov    0x78(%rax),%edx
  407978:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40797c:	8b 40 6c             	mov    0x6c(%rax),%eax
  40797f:	39 c2                	cmp    %eax,%edx
  407981:	75 0a                	jne    40798d <gsi_is_thread_pool_add+0x62>
	{
		return GSI_TP_RC_ERROR;
  407983:	b8 01 00 00 00       	mov    $0x1,%eax
  407988:	e9 b9 00 00 00       	jmpq   407a46 <gsi_is_thread_pool_add+0x11b>
	}

	// Check if we are in shutdown
	if (0 < p_pool->i_shutdown)
  40798d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407991:	8b 40 7c             	mov    0x7c(%rax),%eax
  407994:	85 c0                	test   %eax,%eax
  407996:	7e 0a                	jle    4079a2 <gsi_is_thread_pool_add+0x77>
	{
		return GSI_TP_RC_ERROR;
  407998:	b8 01 00 00 00       	mov    $0x1,%eax
  40799d:	e9 a4 00 00 00       	jmpq   407a46 <gsi_is_thread_pool_add+0x11b>
	}

	// Add task to queue
	p_pool->queue[p_pool->i_tail].thread_func = thread_func;
  4079a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4079a6:	48 8b 50 60          	mov    0x60(%rax),%rdx
  4079aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4079ae:	8b 40 74             	mov    0x74(%rax),%eax
  4079b1:	48 98                	cltq   
  4079b3:	48 c1 e0 04          	shl    $0x4,%rax
  4079b7:	48 01 c2             	add    %rax,%rdx
  4079ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4079be:	48 89 02             	mov    %rax,(%rdx)
	p_pool->queue[p_pool->i_tail].args = args;
  4079c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4079c5:	48 8b 50 60          	mov    0x60(%rax),%rdx
  4079c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4079cd:	8b 40 74             	mov    0x74(%rax),%eax
  4079d0:	48 98                	cltq   
  4079d2:	48 c1 e0 04          	shl    $0x4,%rax
  4079d6:	48 01 c2             	add    %rax,%rdx
  4079d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4079dd:	48 89 42 08          	mov    %rax,0x8(%rdx)

	// Update the tail index
	p_pool->i_tail = (p_pool->i_tail + 1) % p_pool->i_queue_size;
  4079e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4079e5:	8b 40 74             	mov    0x74(%rax),%eax
  4079e8:	8d 50 01             	lea    0x1(%rax),%edx
  4079eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4079ef:	8b 48 6c             	mov    0x6c(%rax),%ecx
  4079f2:	89 d0                	mov    %edx,%eax
  4079f4:	99                   	cltd   
  4079f5:	f7 f9                	idiv   %ecx
  4079f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4079fb:	89 50 74             	mov    %edx,0x74(%rax)

	// Update the number of pending tasks
	p_pool->i_count++;
  4079fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407a02:	8b 40 78             	mov    0x78(%rax),%eax
  407a05:	8d 50 01             	lea    0x1(%rax),%edx
  407a08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407a0c:	89 50 78             	mov    %edx,0x78(%rax)

	// Notify that there is new work in queue
	if (0 != pthread_cond_broadcast(&(p_pool->notify)))
  407a0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407a13:	48 83 c0 28          	add    $0x28,%rax
  407a17:	48 89 c7             	mov    %rax,%rdi
  407a1a:	e8 81 9b ff ff       	callq  4015a0 <pthread_cond_broadcast@plt>
  407a1f:	85 c0                	test   %eax,%eax
  407a21:	74 07                	je     407a2a <gsi_is_thread_pool_add+0xff>
	{
		return GSI_TP_RC_ERROR;
  407a23:	b8 01 00 00 00       	mov    $0x1,%eax
  407a28:	eb 1c                	jmp    407a46 <gsi_is_thread_pool_add+0x11b>
	}

	// Unlock the mutex
	if (0 != pthread_mutex_unlock(&p_pool->lock))
  407a2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407a2e:	48 89 c7             	mov    %rax,%rdi
  407a31:	e8 9a 9d ff ff       	callq  4017d0 <pthread_mutex_unlock@plt>
  407a36:	85 c0                	test   %eax,%eax
  407a38:	74 07                	je     407a41 <gsi_is_thread_pool_add+0x116>
	{
		return GSI_TP_RC_ERROR;
  407a3a:	b8 01 00 00 00       	mov    $0x1,%eax
  407a3f:	eb 05                	jmp    407a46 <gsi_is_thread_pool_add+0x11b>
	}

	return GSI_TP_RC_SUCCESS;
  407a41:	b8 00 00 00 00       	mov    $0x0,%eax
}
  407a46:	c9                   	leaveq 
  407a47:	c3                   	retq   

0000000000407a48 <gsi_is_thread_pool_destroy>:
	 * Parameter:   [in] int i_flags - Flags for shutdown - 1 default, 2 - graceful
	 * Return: 	    Success - GSI_TP_RC_SUCCESS
	 * 				Failure - GSI_TP_RC_ERROR *OR* GSI_TP_RC_INVALID
#############################################################################*/
enum gsi_thread_pool_rc gsi_is_thread_pool_destroy(gsi_thread_pool_t* p_pool, int i_flags)
{
  407a48:	55                   	push   %rbp
  407a49:	48 89 e5             	mov    %rsp,%rbp
  407a4c:	48 83 ec 20          	sub    $0x20,%rsp
  407a50:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  407a54:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// Check input validation
	if (NULL == p_pool)
  407a57:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  407a5c:	75 0a                	jne    407a68 <gsi_is_thread_pool_destroy+0x20>
	{
		return GSI_TP_RC_INVALID;
  407a5e:	b8 02 00 00 00       	mov    $0x2,%eax
  407a63:	e9 d9 00 00 00       	jmpq   407b41 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Try to lock the mutex to own the thread pool
	if (0 != pthread_mutex_lock(&(p_pool->lock)))
  407a68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407a6c:	48 89 c7             	mov    %rax,%rdi
  407a6f:	e8 ac 9e ff ff       	callq  401920 <pthread_mutex_lock@plt>
  407a74:	85 c0                	test   %eax,%eax
  407a76:	74 0a                	je     407a82 <gsi_is_thread_pool_destroy+0x3a>
	{
		return GSI_TP_RC_ERROR;
  407a78:	b8 01 00 00 00       	mov    $0x1,%eax
  407a7d:	e9 bf 00 00 00       	jmpq   407b41 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Check if already in shutdown
	if (0 != p_pool->i_shutdown)
  407a82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407a86:	8b 40 7c             	mov    0x7c(%rax),%eax
  407a89:	85 c0                	test   %eax,%eax
  407a8b:	74 0a                	je     407a97 <gsi_is_thread_pool_destroy+0x4f>
	{
		return GSI_TP_RC_ERROR;
  407a8d:	b8 01 00 00 00       	mov    $0x1,%eax
  407a92:	e9 aa 00 00 00       	jmpq   407b41 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Update shutdown according to i_flags
	if (GSI_TP_DESTROY_GRACEFUL == i_flags)
  407a97:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  407a9b:	75 0d                	jne    407aaa <gsi_is_thread_pool_destroy+0x62>
	{
		p_pool->i_shutdown = GSI_TP_DESTROY_GRACEFUL;
  407a9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407aa1:	c7 40 7c 01 00 00 00 	movl   $0x1,0x7c(%rax)
  407aa8:	eb 0b                	jmp    407ab5 <gsi_is_thread_pool_destroy+0x6d>
	}
	else
	{
		p_pool->i_shutdown = GSI_TP_DESTROY_IMMIDIATE;
  407aaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407aae:	c7 40 7c 02 00 00 00 	movl   $0x2,0x7c(%rax)
	}

	// Wake up all threads
	if (0 != pthread_cond_broadcast(&(p_pool->notify)))
  407ab5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407ab9:	48 83 c0 28          	add    $0x28,%rax
  407abd:	48 89 c7             	mov    %rax,%rdi
  407ac0:	e8 db 9a ff ff       	callq  4015a0 <pthread_cond_broadcast@plt>
  407ac5:	85 c0                	test   %eax,%eax
  407ac7:	74 07                	je     407ad0 <gsi_is_thread_pool_destroy+0x88>
	{
		return GSI_TP_RC_ERROR;
  407ac9:	b8 01 00 00 00       	mov    $0x1,%eax
  407ace:	eb 71                	jmp    407b41 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Unlock the mutex to get threads continue
	if (0 != pthread_mutex_unlock(&(p_pool->lock)))
  407ad0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407ad4:	48 89 c7             	mov    %rax,%rdi
  407ad7:	e8 f4 9c ff ff       	callq  4017d0 <pthread_mutex_unlock@plt>
  407adc:	85 c0                	test   %eax,%eax
  407ade:	74 07                	je     407ae7 <gsi_is_thread_pool_destroy+0x9f>
	{
		return GSI_TP_RC_ERROR;
  407ae0:	b8 01 00 00 00       	mov    $0x1,%eax
  407ae5:	eb 5a                	jmp    407b41 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Join all worker thread
	for (int i = 0; i < p_pool->i_thread_count; ++i)
  407ae7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  407aee:	eb 34                	jmp    407b24 <gsi_is_thread_pool_destroy+0xdc>
	{
		if (0 != pthread_join(p_pool->p_threads[i], NULL))
  407af0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407af4:	48 8b 40 58          	mov    0x58(%rax),%rax
  407af8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  407afb:	48 63 d2             	movslq %edx,%rdx
  407afe:	48 c1 e2 03          	shl    $0x3,%rdx
  407b02:	48 01 d0             	add    %rdx,%rax
  407b05:	48 8b 00             	mov    (%rax),%rax
  407b08:	be 00 00 00 00       	mov    $0x0,%esi
  407b0d:	48 89 c7             	mov    %rax,%rdi
  407b10:	e8 7b 9d ff ff       	callq  401890 <pthread_join@plt>
  407b15:	85 c0                	test   %eax,%eax
  407b17:	74 07                	je     407b20 <gsi_is_thread_pool_destroy+0xd8>
		{
			return GSI_TP_RC_ERROR;
  407b19:	b8 01 00 00 00       	mov    $0x1,%eax
  407b1e:	eb 21                	jmp    407b41 <gsi_is_thread_pool_destroy+0xf9>
	{
		return GSI_TP_RC_ERROR;
	}

	// Join all worker thread
	for (int i = 0; i < p_pool->i_thread_count; ++i)
  407b20:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  407b24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407b28:	8b 40 68             	mov    0x68(%rax),%eax
  407b2b:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  407b2e:	7f c0                	jg     407af0 <gsi_is_thread_pool_destroy+0xa8>
			return GSI_TP_RC_ERROR;
		}
	}

	// Free the thread pool
	gsi_is_thread_pool_free(p_pool);
  407b30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407b34:	48 89 c7             	mov    %rax,%rdi
  407b37:	e8 57 01 00 00       	callq  407c93 <gsi_is_thread_pool_free>

	return GSI_TP_RC_SUCCESS;
  407b3c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  407b41:	c9                   	leaveq 
  407b42:	c3                   	retq   

0000000000407b43 <gsi_is_thread_run>:
	 * Description: That is the main loop of each thread in thread pool
	 * Parameter:   [in] void* args - must be pointer to thread pool object
	 * Return:		NULL
#############################################################################*/
static void* gsi_is_thread_run(void* args)
{
  407b43:	55                   	push   %rbp
  407b44:	48 89 e5             	mov    %rsp,%rbp
  407b47:	48 83 ec 30          	sub    $0x30,%rsp
  407b4b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	gsi_thread_pool_t* p_pool = (gsi_thread_pool_t*)args;
  407b4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  407b53:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	gsi_thread_pool_task_t task;

	// Check input validation
	if (NULL == args)
  407b57:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  407b5c:	75 0a                	jne    407b68 <gsi_is_thread_run+0x25>
	{
		return NULL;
  407b5e:	b8 00 00 00 00       	mov    $0x0,%eax
  407b63:	e9 29 01 00 00       	jmpq   407c91 <gsi_is_thread_run+0x14e>

	// Main loop
	while (1)
	{
		// Lock the mutex
		if (0 != pthread_mutex_lock(&(p_pool->lock)))
  407b68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407b6c:	48 89 c7             	mov    %rax,%rdi
  407b6f:	e8 ac 9d ff ff       	callq  401920 <pthread_mutex_lock@plt>
  407b74:	85 c0                	test   %eax,%eax
  407b76:	0f 85 e9 00 00 00    	jne    407c65 <gsi_is_thread_run+0x122>
			break;
		}

		// Wait on condition variable until we have tasks, check for spurious wakeups.
        // When returning from pthread_cond_wait(), we own the lock.
		while ((p_pool->i_count == 0) && (!p_pool->i_shutdown))
  407b7c:	eb 17                	jmp    407b95 <gsi_is_thread_run+0x52>
		{
			pthread_cond_wait(&(p_pool->notify), &(p_pool->lock));
  407b7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407b82:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  407b86:	48 83 c2 28          	add    $0x28,%rdx
  407b8a:	48 89 c6             	mov    %rax,%rsi
  407b8d:	48 89 d7             	mov    %rdx,%rdi
  407b90:	e8 5b 9a ff ff       	callq  4015f0 <pthread_cond_wait@plt>
			break;
		}

		// Wait on condition variable until we have tasks, check for spurious wakeups.
        // When returning from pthread_cond_wait(), we own the lock.
		while ((p_pool->i_count == 0) && (!p_pool->i_shutdown))
  407b95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407b99:	8b 40 78             	mov    0x78(%rax),%eax
  407b9c:	85 c0                	test   %eax,%eax
  407b9e:	75 0b                	jne    407bab <gsi_is_thread_run+0x68>
  407ba0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407ba4:	8b 40 7c             	mov    0x7c(%rax),%eax
  407ba7:	85 c0                	test   %eax,%eax
  407ba9:	74 d3                	je     407b7e <gsi_is_thread_run+0x3b>
		{
			pthread_cond_wait(&(p_pool->notify), &(p_pool->lock));
		}

		// Check destroy status
		if ((p_pool->i_shutdown == GSI_TP_DESTROY_IMMIDIATE) ||
  407bab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407baf:	8b 40 7c             	mov    0x7c(%rax),%eax
  407bb2:	83 f8 02             	cmp    $0x2,%eax
  407bb5:	0f 84 ae 00 00 00    	je     407c69 <gsi_is_thread_run+0x126>
		   ((p_pool->i_shutdown == GSI_TP_DESTROY_GRACEFUL) && (p_pool->i_count == 0)))
  407bbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407bbf:	8b 40 7c             	mov    0x7c(%rax),%eax
		{
			pthread_cond_wait(&(p_pool->notify), &(p_pool->lock));
		}

		// Check destroy status
		if ((p_pool->i_shutdown == GSI_TP_DESTROY_IMMIDIATE) ||
  407bc2:	83 f8 01             	cmp    $0x1,%eax
  407bc5:	75 0f                	jne    407bd6 <gsi_is_thread_run+0x93>
		   ((p_pool->i_shutdown == GSI_TP_DESTROY_GRACEFUL) && (p_pool->i_count == 0)))
  407bc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407bcb:	8b 40 78             	mov    0x78(%rax),%eax
  407bce:	85 c0                	test   %eax,%eax
  407bd0:	0f 84 93 00 00 00    	je     407c69 <gsi_is_thread_run+0x126>
		{
			break;
		}

		// Get the first task
		task.thread_func = p_pool->queue[p_pool->i_head].thread_func;
  407bd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407bda:	48 8b 50 60          	mov    0x60(%rax),%rdx
  407bde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407be2:	8b 40 70             	mov    0x70(%rax),%eax
  407be5:	48 98                	cltq   
  407be7:	48 c1 e0 04          	shl    $0x4,%rax
  407beb:	48 01 d0             	add    %rdx,%rax
  407bee:	48 8b 00             	mov    (%rax),%rax
  407bf1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		task.args = p_pool->queue[p_pool->i_head].args;
  407bf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407bf9:	48 8b 50 60          	mov    0x60(%rax),%rdx
  407bfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c01:	8b 40 70             	mov    0x70(%rax),%eax
  407c04:	48 98                	cltq   
  407c06:	48 c1 e0 04          	shl    $0x4,%rax
  407c0a:	48 01 d0             	add    %rdx,%rax
  407c0d:	48 8b 40 08          	mov    0x8(%rax),%rax
  407c11:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

		// Update the head index
		p_pool->i_head = (p_pool->i_head + 1) % p_pool->i_queue_size;
  407c15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c19:	8b 40 70             	mov    0x70(%rax),%eax
  407c1c:	8d 50 01             	lea    0x1(%rax),%edx
  407c1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c23:	8b 48 6c             	mov    0x6c(%rax),%ecx
  407c26:	89 d0                	mov    %edx,%eax
  407c28:	99                   	cltd   
  407c29:	f7 f9                	idiv   %ecx
  407c2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c2f:	89 50 70             	mov    %edx,0x70(%rax)

		// Decrease the number of pending tasks
		p_pool->i_count--;
  407c32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c36:	8b 40 78             	mov    0x78(%rax),%eax
  407c39:	8d 50 ff             	lea    -0x1(%rax),%edx
  407c3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c40:	89 50 78             	mov    %edx,0x78(%rax)

		// Unlock the mutex
		if (0 != pthread_mutex_unlock(&(p_pool->lock)))
  407c43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c47:	48 89 c7             	mov    %rax,%rdi
  407c4a:	e8 81 9b ff ff       	callq  4017d0 <pthread_mutex_unlock@plt>
  407c4f:	85 c0                	test   %eax,%eax
  407c51:	75 15                	jne    407c68 <gsi_is_thread_run+0x125>
		{
			break;
		}

		// Go to work
		(*(task.thread_func))(task.args);
  407c53:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  407c57:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  407c5b:	48 89 d7             	mov    %rdx,%rdi
  407c5e:	ff d0                	callq  *%rax
	}
  407c60:	e9 03 ff ff ff       	jmpq   407b68 <gsi_is_thread_run+0x25>
	while (1)
	{
		// Lock the mutex
		if (0 != pthread_mutex_lock(&(p_pool->lock)))
		{
			break;
  407c65:	90                   	nop
  407c66:	eb 01                	jmp    407c69 <gsi_is_thread_run+0x126>
		p_pool->i_count--;

		// Unlock the mutex
		if (0 != pthread_mutex_unlock(&(p_pool->lock)))
		{
			break;
  407c68:	90                   	nop
		// Go to work
		(*(task.thread_func))(task.args);
	}

	// Decrease the number of working threads
	p_pool->i_started--;
  407c69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c6d:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
  407c73:	8d 50 ff             	lea    -0x1(%rax),%edx
  407c76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c7a:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)

	// Unlock the mutex
	pthread_mutex_unlock(&(p_pool->lock));
  407c80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  407c84:	48 89 c7             	mov    %rax,%rdi
  407c87:	e8 44 9b ff ff       	callq  4017d0 <pthread_mutex_unlock@plt>

	return NULL;
  407c8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  407c91:	c9                   	leaveq 
  407c92:	c3                   	retq   

0000000000407c93 <gsi_is_thread_pool_free>:
	 * Parameter:   [in] - gsi_thread_pool_t* p_pool - object to be free
	 * Return:		Success - GSI_TP_RC_SUCCESS
	 * 				Failure - GSI_TP_RC_ERROR *OR* GSI_TP_RC_INVALID
#############################################################################*/
static enum gsi_thread_pool_rc gsi_is_thread_pool_free(gsi_thread_pool_t* p_pool)
{
  407c93:	55                   	push   %rbp
  407c94:	48 89 e5             	mov    %rsp,%rbp
  407c97:	48 83 ec 10          	sub    $0x10,%rsp
  407c9b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Check input validation
	if (NULL == p_pool)
  407c9f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  407ca4:	75 07                	jne    407cad <gsi_is_thread_pool_free+0x1a>
	{
		return GSI_TP_RC_INVALID;
  407ca6:	b8 02 00 00 00       	mov    $0x2,%eax
  407cab:	eb 78                	jmp    407d25 <gsi_is_thread_pool_free+0x92>
	}

	// Check if there are still running threads
	if (0 < p_pool->i_started)
  407cad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407cb1:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
  407cb7:	85 c0                	test   %eax,%eax
  407cb9:	7e 07                	jle    407cc2 <gsi_is_thread_pool_free+0x2f>
	{
		return GSI_TP_RC_ERROR;
  407cbb:	b8 01 00 00 00       	mov    $0x1,%eax
  407cc0:	eb 63                	jmp    407d25 <gsi_is_thread_pool_free+0x92>
	}

	free(p_pool->p_threads);
  407cc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407cc6:	48 8b 40 58          	mov    0x58(%rax),%rax
  407cca:	48 89 c7             	mov    %rax,%rdi
  407ccd:	e8 7e 98 ff ff       	callq  401550 <free@plt>
	free(p_pool->queue);
  407cd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407cd6:	48 8b 40 60          	mov    0x60(%rax),%rax
  407cda:	48 89 c7             	mov    %rax,%rdi
  407cdd:	e8 6e 98 ff ff       	callq  401550 <free@plt>

	if (0 != pthread_mutex_destroy(&(p_pool->lock)))
  407ce2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407ce6:	48 89 c7             	mov    %rax,%rdi
  407ce9:	e8 a2 99 ff ff       	callq  401690 <pthread_mutex_destroy@plt>
  407cee:	85 c0                	test   %eax,%eax
  407cf0:	74 07                	je     407cf9 <gsi_is_thread_pool_free+0x66>
	{
		return GSI_TP_RC_ERROR;
  407cf2:	b8 01 00 00 00       	mov    $0x1,%eax
  407cf7:	eb 2c                	jmp    407d25 <gsi_is_thread_pool_free+0x92>
	}

	if (0 != pthread_cond_destroy(&(p_pool->notify)))
  407cf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407cfd:	48 83 c0 28          	add    $0x28,%rax
  407d01:	48 89 c7             	mov    %rax,%rdi
  407d04:	e8 57 9b ff ff       	callq  401860 <pthread_cond_destroy@plt>
  407d09:	85 c0                	test   %eax,%eax
  407d0b:	74 07                	je     407d14 <gsi_is_thread_pool_free+0x81>
	{
		return GSI_TP_RC_ERROR;
  407d0d:	b8 01 00 00 00       	mov    $0x1,%eax
  407d12:	eb 11                	jmp    407d25 <gsi_is_thread_pool_free+0x92>
	}

	free(p_pool);
  407d14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  407d18:	48 89 c7             	mov    %rax,%rdi
  407d1b:	e8 30 98 ff ff       	callq  401550 <free@plt>

	return GSI_TP_RC_SUCCESS;
  407d20:	b8 00 00 00 00       	mov    $0x0,%eax
}
  407d25:	c9                   	leaveq 
  407d26:	c3                   	retq   
  407d27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  407d2e:	00 00 

0000000000407d30 <__libc_csu_init>:
  407d30:	41 57                	push   %r15
  407d32:	41 56                	push   %r14
  407d34:	41 89 ff             	mov    %edi,%r15d
  407d37:	41 55                	push   %r13
  407d39:	41 54                	push   %r12
  407d3b:	4c 8d 25 ae 30 20 00 	lea    0x2030ae(%rip),%r12        # 60adf0 <__frame_dummy_init_array_entry>
  407d42:	55                   	push   %rbp
  407d43:	48 8d 2d ae 30 20 00 	lea    0x2030ae(%rip),%rbp        # 60adf8 <__init_array_end>
  407d4a:	53                   	push   %rbx
  407d4b:	49 89 f6             	mov    %rsi,%r14
  407d4e:	49 89 d5             	mov    %rdx,%r13
  407d51:	4c 29 e5             	sub    %r12,%rbp
  407d54:	48 83 ec 08          	sub    $0x8,%rsp
  407d58:	48 c1 fd 03          	sar    $0x3,%rbp
  407d5c:	e8 af 97 ff ff       	callq  401510 <_init>
  407d61:	48 85 ed             	test   %rbp,%rbp
  407d64:	74 20                	je     407d86 <__libc_csu_init+0x56>
  407d66:	31 db                	xor    %ebx,%ebx
  407d68:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  407d6f:	00 
  407d70:	4c 89 ea             	mov    %r13,%rdx
  407d73:	4c 89 f6             	mov    %r14,%rsi
  407d76:	44 89 ff             	mov    %r15d,%edi
  407d79:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  407d7d:	48 83 c3 01          	add    $0x1,%rbx
  407d81:	48 39 eb             	cmp    %rbp,%rbx
  407d84:	75 ea                	jne    407d70 <__libc_csu_init+0x40>
  407d86:	48 83 c4 08          	add    $0x8,%rsp
  407d8a:	5b                   	pop    %rbx
  407d8b:	5d                   	pop    %rbp
  407d8c:	41 5c                	pop    %r12
  407d8e:	41 5d                	pop    %r13
  407d90:	41 5e                	pop    %r14
  407d92:	41 5f                	pop    %r15
  407d94:	c3                   	retq   
  407d95:	90                   	nop
  407d96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  407d9d:	00 00 00 

0000000000407da0 <__libc_csu_fini>:
  407da0:	f3 c3                	repz retq 

Disassembly of section .fini:

0000000000407da4 <_fini>:
  407da4:	48 83 ec 08          	sub    $0x8,%rsp
  407da8:	48 83 c4 08          	add    $0x8,%rsp
  407dac:	c3                   	retq   
