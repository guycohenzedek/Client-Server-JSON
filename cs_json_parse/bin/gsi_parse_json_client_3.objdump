
../../../bin/gsi_parse_json_client_3:     file format elf64-x86-64
../../../bin/gsi_parse_json_client_3
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000000401920

Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000400040 paddr 0x0000000000400040 align 2**3
         filesz 0x00000000000001f8 memsz 0x00000000000001f8 flags r-x
  INTERP off    0x0000000000000238 vaddr 0x0000000000400238 paddr 0x0000000000400238 align 2**0
         filesz 0x000000000000001c memsz 0x000000000000001c flags r--
    LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21
         filesz 0x0000000000009424 memsz 0x0000000000009424 flags r-x
    LOAD off    0x0000000000009df0 vaddr 0x0000000000609df0 paddr 0x0000000000609df0 align 2**21
         filesz 0x00000000000004b8 memsz 0x0000000000000648 flags rw-
 DYNAMIC off    0x0000000000009e08 vaddr 0x0000000000609e08 paddr 0x0000000000609e08 align 2**3
         filesz 0x00000000000001f0 memsz 0x00000000000001f0 flags rw-
    NOTE off    0x0000000000000254 vaddr 0x0000000000400254 paddr 0x0000000000400254 align 2**2
         filesz 0x0000000000000044 memsz 0x0000000000000044 flags r--
EH_FRAME off    0x0000000000008974 vaddr 0x0000000000408974 paddr 0x0000000000408974 align 2**2
         filesz 0x00000000000001dc memsz 0x00000000000001dc flags r--
   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
   RELRO off    0x0000000000009df0 vaddr 0x0000000000609df0 paddr 0x0000000000609df0 align 2**0
         filesz 0x0000000000000210 memsz 0x0000000000000210 flags r--

Dynamic Section:
  NEEDED               libjson-c.so.2
  NEEDED               libpthread.so.0
  NEEDED               libc.so.6
  INIT                 0x00000000004014d8
  FINI                 0x0000000000406b04
  INIT_ARRAY           0x0000000000609df0
  INIT_ARRAYSZ         0x0000000000000008
  FINI_ARRAY           0x0000000000609df8
  FINI_ARRAYSZ         0x0000000000000008
  GNU_HASH             0x0000000000400298
  STRTAB               0x00000000004009e0
  SYMTAB               0x00000000004002d8
  STRSZ                0x00000000000003ac
  SYMENT               0x0000000000000018
  DEBUG                0x0000000000000000
  PLTGOT               0x000000000060a000
  PLTRELSZ             0x0000000000000600
  PLTREL               0x0000000000000007
  JMPREL               0x0000000000400ed8
  RELA                 0x0000000000400ea8
  RELASZ               0x0000000000000030
  RELAENT              0x0000000000000018
  VERNEED              0x0000000000400e28
  VERNEEDNUM           0x0000000000000002
  VERSYM               0x0000000000400d8c

Version References:
  required from libpthread.so.0:
    0x09691972 0x00 04 GLIBC_2.3.2
    0x09691a75 0x00 03 GLIBC_2.2.5
  required from libc.so.6:
    0x0d696913 0x00 07 GLIBC_2.3
    0x06969194 0x00 06 GLIBC_2.14
    0x0d696914 0x00 05 GLIBC_2.4
    0x09691a75 0x00 02 GLIBC_2.2.5

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001c  0000000000400238  0000000000400238  00000238  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.ABI-tag 00000020  0000000000400254  0000000000400254  00000254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.gnu.build-id 00000024  0000000000400274  0000000000400274  00000274  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .gnu.hash     0000003c  0000000000400298  0000000000400298  00000298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .dynsym       00000708  00000000004002d8  00000000004002d8  000002d8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dynstr       000003ac  00000000004009e0  00000000004009e0  000009e0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .gnu.version  00000096  0000000000400d8c  0000000000400d8c  00000d8c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .gnu.version_r 00000080  0000000000400e28  0000000000400e28  00000e28  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rela.dyn     00000030  0000000000400ea8  0000000000400ea8  00000ea8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rela.plt     00000600  0000000000400ed8  0000000000400ed8  00000ed8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .init         0000001a  00000000004014d8  00000000004014d8  000014d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .plt          00000410  0000000000401500  0000000000401500  00001500  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .plt.got      00000008  0000000000401910  0000000000401910  00001910  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .text         000051e2  0000000000401920  0000000000401920  00001920  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .fini         00000009  0000000000406b04  0000000000406b04  00006b04  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .rodata       00001e61  0000000000406b10  0000000000406b10  00006b10  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 16 .eh_frame_hdr 000001dc  0000000000408974  0000000000408974  00008974  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 17 .eh_frame     000008d4  0000000000408b50  0000000000408b50  00008b50  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 18 .init_array   00000008  0000000000609df0  0000000000609df0  00009df0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 19 .fini_array   00000008  0000000000609df8  0000000000609df8  00009df8  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 20 .jcr          00000008  0000000000609e00  0000000000609e00  00009e00  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 21 .dynamic      000001f0  0000000000609e08  0000000000609e08  00009e08  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 22 .got          00000008  0000000000609ff8  0000000000609ff8  00009ff8  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 23 .got.plt      00000218  000000000060a000  000000000060a000  0000a000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 24 .data         00000088  000000000060a220  000000000060a220  0000a220  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 25 .bss          00000178  000000000060a2c0  000000000060a2c0  0000a2a8  2**5
                  ALLOC
 26 .comment      00000035  0000000000000000  0000000000000000  0000a2a8  2**0
                  CONTENTS, READONLY
 27 .debug_aranges 00000120  0000000000000000  0000000000000000  0000a2dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_info   00002e3b  0000000000000000  0000000000000000  0000a3fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_abbrev 0000093b  0000000000000000  0000000000000000  0000d238  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .debug_line   00002144  0000000000000000  0000000000000000  0000db73  2**0
                  CONTENTS, READONLY, DEBUGGING
 31 .debug_str    0001108d  0000000000000000  0000000000000000  0000fcb7  2**0
                  CONTENTS, READONLY, DEBUGGING
 32 .debug_macro  00005923  0000000000000000  0000000000000000  00020d44  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
0000000000400238 l    d  .interp	0000000000000000              .interp
0000000000400254 l    d  .note.ABI-tag	0000000000000000              .note.ABI-tag
0000000000400274 l    d  .note.gnu.build-id	0000000000000000              .note.gnu.build-id
0000000000400298 l    d  .gnu.hash	0000000000000000              .gnu.hash
00000000004002d8 l    d  .dynsym	0000000000000000              .dynsym
00000000004009e0 l    d  .dynstr	0000000000000000              .dynstr
0000000000400d8c l    d  .gnu.version	0000000000000000              .gnu.version
0000000000400e28 l    d  .gnu.version_r	0000000000000000              .gnu.version_r
0000000000400ea8 l    d  .rela.dyn	0000000000000000              .rela.dyn
0000000000400ed8 l    d  .rela.plt	0000000000000000              .rela.plt
00000000004014d8 l    d  .init	0000000000000000              .init
0000000000401500 l    d  .plt	0000000000000000              .plt
0000000000401910 l    d  .plt.got	0000000000000000              .plt.got
0000000000401920 l    d  .text	0000000000000000              .text
0000000000406b04 l    d  .fini	0000000000000000              .fini
0000000000406b10 l    d  .rodata	0000000000000000              .rodata
0000000000408974 l    d  .eh_frame_hdr	0000000000000000              .eh_frame_hdr
0000000000408b50 l    d  .eh_frame	0000000000000000              .eh_frame
0000000000609df0 l    d  .init_array	0000000000000000              .init_array
0000000000609df8 l    d  .fini_array	0000000000000000              .fini_array
0000000000609e00 l    d  .jcr	0000000000000000              .jcr
0000000000609e08 l    d  .dynamic	0000000000000000              .dynamic
0000000000609ff8 l    d  .got	0000000000000000              .got
000000000060a000 l    d  .got.plt	0000000000000000              .got.plt
000000000060a220 l    d  .data	0000000000000000              .data
000000000060a2c0 l    d  .bss	0000000000000000              .bss
0000000000000000 l    d  .comment	0000000000000000              .comment
0000000000000000 l    d  .debug_aranges	0000000000000000              .debug_aranges
0000000000000000 l    d  .debug_info	0000000000000000              .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000              .debug_abbrev
0000000000000000 l    d  .debug_line	0000000000000000              .debug_line
0000000000000000 l    d  .debug_str	0000000000000000              .debug_str
0000000000000000 l    d  .debug_macro	0000000000000000              .debug_macro
0000000000000000 l    df *ABS*	0000000000000000              crtstuff.c
0000000000609e00 l     O .jcr	0000000000000000              __JCR_LIST__
0000000000401950 l     F .text	0000000000000000              deregister_tm_clones
0000000000401990 l     F .text	0000000000000000              register_tm_clones
00000000004019d0 l     F .text	0000000000000000              __do_global_dtors_aux
000000000060a2c8 l     O .bss	0000000000000001              completed.7594
0000000000609df8 l     O .fini_array	0000000000000000              __do_global_dtors_aux_fini_array_entry
00000000004019f0 l     F .text	0000000000000000              frame_dummy
0000000000609df0 l     O .init_array	0000000000000000              __frame_dummy_init_array_entry
0000000000000000 l    df *ABS*	0000000000000000              gsi_parse_json_client_3.c
0000000000401ca9 l     F .text	0000000000000294              gsi_client_connect_client_to_server
0000000000000000 l    df *ABS*	0000000000000000              gsi_build_parse_data.c
000000000040316e l     F .text	0000000000000264              gsi_build_parse_json_obj_to_string
00000000004039e6 l     F .text	00000000000000d9              gsi_build_parse_strdup
00000000004033d2 l     F .text	00000000000000c2              gsi_build_parse_string_to_json_object
0000000000403494 l     F .text	0000000000000126              gsi_build_parse_json_object_to_json_msg
0000000000402924 l     F .text	0000000000000191              gsi_build_parse_build_msg
0000000000402ab5 l     F .text	00000000000000ef              gsi_build_parse_get_msg_type
0000000000402ba4 l     F .text	00000000000001d2              gsi_build_parse_get_msg_op_code
0000000000402f19 l     F .text	0000000000000255              gsi_build_parse_set_op_code_args
0000000000402d76 l     F .text	0000000000000093              gsi_build_parse_get_msg_index
0000000000402e09 l     F .text	0000000000000065              gsi_build_parse_get_msg_len
0000000000402e6e l     F .text	00000000000000ab              gsi_build_parse_get_msg_content
00000000004038b5 l     F .text	0000000000000131              gsi_build_parse_get_file_name
0000000000403abf l     F .text	000000000000004b              gsi_build_parse_op_code_to_string
00000000004035ba l     F .text	00000000000002fb              gsi_build_parse_handle_op_code
0000000000000000 l    df *ABS*	0000000000000000              gsi_is_network_tcp.c
0000000000404b3a l     F .text	0000000000000130              set_address_parameters
0000000000404c6a l     F .text	0000000000000599              read_check_heartbeat
0000000000000000 l    df *ABS*	0000000000000000              gsi_is_logger.c
00000000004056de l     F .text	00000000000000a4              thread_write_log
000000000060a2e0 l     O .bss	0000000000000014              s_time_stamp.3555
0000000000000000 l    df *ABS*	0000000000000000              gsi_parse_json_config.c
000000000060a240 l     O .data	0000000000000020              g_config_cmd_opts
000000000060a260 l     O .data	0000000000000048              g_config_params_keys
00000000004061c7 l     F .text	00000000000000a5              gsi_parse_json_config_init_default_params
000000000040626c l     F .text	00000000000001a3              gsi_parse_json_config_init_from_config_file
0000000000405dc5 l     F .text	0000000000000402              gsi_parse_json_config_parse_main_args
0000000000000000 l    df *ABS*	0000000000000000              gsi_thread_pool.c
00000000004068a3 l     F .text	0000000000000150              gsi_is_thread_run
00000000004069f3 l     F .text	0000000000000094              gsi_is_thread_pool_free
0000000000000000 l    df *ABS*	0000000000000000              crtstuff.c
0000000000409420 l     O .eh_frame	0000000000000000              __FRAME_END__
0000000000609e00 l     O .jcr	0000000000000000              __JCR_END__
0000000000000000 l    df *ABS*	0000000000000000              
0000000000609df8 l       .init_array	0000000000000000              __init_array_end
0000000000609e08 l     O .dynamic	0000000000000000              _DYNAMIC
0000000000609df0 l       .init_array	0000000000000000              __init_array_start
0000000000408974 l       .eh_frame_hdr	0000000000000000              __GNU_EH_FRAME_HDR
000000000060a000 l     O .got.plt	0000000000000000              _GLOBAL_OFFSET_TABLE_
0000000000406b00 g     F .text	0000000000000002              __libc_csu_fini
0000000000000000       F *UND*	0000000000000000              json_tokener_parse
0000000000000000       F *UND*	0000000000000000              free@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_create@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              localtime@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              strncmp@@GLIBC_2.2.5
0000000000000000  w      *UND*	0000000000000000              _ITM_deregisterTMCloneTable
000000000060a220  w      .data	0000000000000000              data_start
000000000040640f g     F .text	000000000000027c              gsi_is_thread_pool_create
0000000000000000       F *UND*	0000000000000000              strcpy@@GLIBC_2.2.5
0000000000401f3d g     F .text	00000000000000bf              gsi_is_open_msg_file
0000000000000000       F *UND*	0000000000000000              pthread_cond_broadcast@@GLIBC_2.3.2
00000000004027b1 g     F .text	0000000000000173              gsi_is_get_next_msg
0000000000000000       F *UND*	0000000000000000              puts@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              setsockopt@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_new_string
0000000000000000       F *UND*	0000000000000000              write@@GLIBC_2.2.5
00000000004049ca g     F .text	0000000000000170              gsi_is_network_tcp_server_cleanup
0000000000402281 g     F .text	00000000000002df              gsi_is_send_json_msg
000000000060a2a8 g       .data	0000000000000000              _edata
0000000000000000       F *UND*	0000000000000000              pthread_cond_wait@@GLIBC_2.3.2
0000000000000000       F *UND*	0000000000000000              fclose@@GLIBC_2.2.5
0000000000406b04 g     F .fini	0000000000000000              _fini
0000000000401ffc g     F .text	00000000000000ac              gsi_is_close_msg_file
0000000000000000       F *UND*	0000000000000000              json_object_get_string
0000000000000000       F *UND*	0000000000000000              strlen@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              __stack_chk_fail@@GLIBC_2.4
0000000000000000       F *UND*	0000000000000000              json_object_new_object
0000000000000000       F *UND*	0000000000000000              getopt_long@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              htons@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              strchr@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              printf@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_mutex_destroy@@GLIBC_2.2.5
0000000000405782 g     F .text	00000000000000c6              gsi_parse_json_config_open
0000000000000000       F *UND*	0000000000000000              fputs@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              memset@@GLIBC_2.2.5
0000000000405b48 g     F .text	0000000000000103              gsi_parse_json_config_get_next_entry
0000000000403c98 g     F .text	0000000000000165              gsi_is_network_tcp_connect
0000000000000000       F *UND*	0000000000000000              close@@GLIBC_2.2.5
000000000040668b g     F .text	000000000000011d              gsi_is_thread_pool_add
00000000004020a8 g     F .text	00000000000000ae              gsi_build_parse_reset_object
0000000000000000       F *UND*	0000000000000000              read@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              __libc_start_main@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_to_json_string_ext
0000000000000000       F *UND*	0000000000000000              fgets@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_get_int
00000000004047c8 g     F .text	0000000000000202              gsi_is_network_tcp_server_read
0000000000000000       F *UND*	0000000000000000              calloc@@GLIBC_2.2.5
000000000060a220 g       .data	0000000000000000              __data_start
0000000000000000       F *UND*	0000000000000000              strcmp@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_new_int
000000000060a2c0 g     O .bss	0000000000000008              optarg@@GLIBC_2.2.5
0000000000404553 g     F .text	0000000000000275              gsi_is_network_tcp_server_poll
0000000000000000       F *UND*	0000000000000000              fprintf@@GLIBC_2.2.5
0000000000402560 g     F .text	0000000000000251              gsi_is_recv_json_msg
0000000000000000       F *UND*	0000000000000000              feof@@GLIBC_2.2.5
0000000000000000  w      *UND*	0000000000000000              __gmon_start__
0000000000000000       F *UND*	0000000000000000              strtol@@GLIBC_2.2.5
000000000060a228 g     O .data	0000000000000000              .hidden __dso_handle
0000000000000000       F *UND*	0000000000000000              memcpy@@GLIBC_2.14
0000000000405420 g     F .text	00000000000001bd              gsi_is_write_to_log
0000000000406b10 g     O .rodata	0000000000000004              _IO_stdin_used
000000000060a2d8 g     O .bss	0000000000000008              g_p_log_file
0000000000000000       F *UND*	0000000000000000              inet_pton@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              time@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_object_add
0000000000000000       F *UND*	0000000000000000              pthread_cond_init@@GLIBC_2.3.2
000000000040403b g     F .text	00000000000001de              gsi_is_network_tcp_client_init
0000000000000000       F *UND*	0000000000000000              pthread_mutex_unlock@@GLIBC_2.2.5
0000000000406a90 g     F .text	0000000000000065              __libc_csu_init
000000000060a300 g     O .bss	00000000000000a0              g_config_server_params
0000000000000000       F *UND*	0000000000000000              malloc@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              fflush@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              listen@@GLIBC_2.2.5
000000000060a438 g       .bss	0000000000000000              _end
0000000000402156 g     F .text	000000000000012b              gsi_is_send_all_json_msg
00000000004055dd g     F .text	000000000000005f              gsi_is_close_log
0000000000401920 g     F .text	000000000000002a              _start
000000000060a2d0 g     O .bss	0000000000000008              g_p_thread_pool
000000000060a3a0 g     O .bss	0000000000000094              g_config_client_params
000000000060a2a8 g       .bss	0000000000000000              __bss_start
0000000000401a16 g     F .text	0000000000000293              main
0000000000000000       F *UND*	0000000000000000              poll@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              bind@@GLIBC_2.2.5
0000000000405848 g     F .text	00000000000000ac              gsi_parse_json_config_close
0000000000000000       F *UND*	0000000000000000              vsprintf@@GLIBC_2.2.5
00000000004058f4 g     F .text	0000000000000254              gsi_parse_json_config_read_line
0000000000000000       F *UND*	0000000000000000              pthread_self@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_cond_destroy@@GLIBC_2.3.2
0000000000000000       F *UND*	0000000000000000              fopen@@GLIBC_2.2.5
0000000000403dfd g     F .text	000000000000023e              gsi_is_network_tcp_send
0000000000000000       F *UND*	0000000000000000              pthread_join@@GLIBC_2.2.5
0000000000000000  w      *UND*	0000000000000000              _Jv_RegisterClasses
00000000004053c4 g     F .text	000000000000005c              gsi_is_title_to_log
0000000000404219 g     F .text	000000000000033a              gsi_is_network_tcp_server_init
0000000000405203 g     F .text	00000000000001b4              gsi_is_create_log_file
0000000000000000       F *UND*	0000000000000000              accept@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              atoi@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              json_object_object_get
0000000000403b0a g     F .text	0000000000000074              gsi_is_network_tcp_reset
0000000000000000       F *UND*	0000000000000000              sprintf@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              exit@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              connect@@GLIBC_2.2.5
000000000060a2a8 g     O .data	0000000000000000              .hidden __TMC_END__
0000000000000000  w      *UND*	0000000000000000              _ITM_registerTMCloneTable
00000000004067a8 g     F .text	00000000000000fb              gsi_is_thread_pool_destroy
00000000004053b7 g     F .text	000000000000000d              gsi_get_saved_file
000000000040563c g     F .text	00000000000000a2              gsi_is_gen_timestamp
0000000000000000       F *UND*	0000000000000000              sleep@@GLIBC_2.2.5
0000000000000000       F *UND*	0000000000000000              pthread_mutex_init@@GLIBC_2.2.5
00000000004014d8 g     F .init	0000000000000000              _init
0000000000000000       F *UND*	0000000000000000              json_object_put
0000000000000000       F *UND*	0000000000000000              pthread_mutex_lock@@GLIBC_2.2.5
0000000000405c4b g     F .text	000000000000017a              gsi_parse_json_config_get_config
0000000000403b7e g     F .text	000000000000011a              gsi_is_network_tcp_set_sockaddr
0000000000000000       F *UND*	0000000000000000              __ctype_b_loc@@GLIBC_2.3
0000000000000000       F *UND*	0000000000000000              socket@@GLIBC_2.2.5



Disassembly of section .init:

00000000004014d8 <_init>:
  4014d8:	48 83 ec 08          	sub    $0x8,%rsp
  4014dc:	48 8b 05 15 8b 20 00 	mov    0x208b15(%rip),%rax        # 609ff8 <_DYNAMIC+0x1f0>
  4014e3:	48 85 c0             	test   %rax,%rax
  4014e6:	74 05                	je     4014ed <_init+0x15>
  4014e8:	e8 23 04 00 00       	callq  401910 <socket@plt+0x10>
  4014ed:	48 83 c4 08          	add    $0x8,%rsp
  4014f1:	c3                   	retq   

Disassembly of section .plt:

0000000000401500 <json_tokener_parse@plt-0x10>:
  401500:	ff 35 02 8b 20 00    	pushq  0x208b02(%rip)        # 60a008 <_GLOBAL_OFFSET_TABLE_+0x8>
  401506:	ff 25 04 8b 20 00    	jmpq   *0x208b04(%rip)        # 60a010 <_GLOBAL_OFFSET_TABLE_+0x10>
  40150c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401510 <json_tokener_parse@plt>:
  401510:	ff 25 02 8b 20 00    	jmpq   *0x208b02(%rip)        # 60a018 <_GLOBAL_OFFSET_TABLE_+0x18>
  401516:	68 00 00 00 00       	pushq  $0x0
  40151b:	e9 e0 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401520 <free@plt>:
  401520:	ff 25 fa 8a 20 00    	jmpq   *0x208afa(%rip)        # 60a020 <_GLOBAL_OFFSET_TABLE_+0x20>
  401526:	68 01 00 00 00       	pushq  $0x1
  40152b:	e9 d0 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401530 <pthread_create@plt>:
  401530:	ff 25 f2 8a 20 00    	jmpq   *0x208af2(%rip)        # 60a028 <_GLOBAL_OFFSET_TABLE_+0x28>
  401536:	68 02 00 00 00       	pushq  $0x2
  40153b:	e9 c0 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401540 <localtime@plt>:
  401540:	ff 25 ea 8a 20 00    	jmpq   *0x208aea(%rip)        # 60a030 <_GLOBAL_OFFSET_TABLE_+0x30>
  401546:	68 03 00 00 00       	pushq  $0x3
  40154b:	e9 b0 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401550 <strncmp@plt>:
  401550:	ff 25 e2 8a 20 00    	jmpq   *0x208ae2(%rip)        # 60a038 <_GLOBAL_OFFSET_TABLE_+0x38>
  401556:	68 04 00 00 00       	pushq  $0x4
  40155b:	e9 a0 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401560 <strcpy@plt>:
  401560:	ff 25 da 8a 20 00    	jmpq   *0x208ada(%rip)        # 60a040 <_GLOBAL_OFFSET_TABLE_+0x40>
  401566:	68 05 00 00 00       	pushq  $0x5
  40156b:	e9 90 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401570 <pthread_cond_broadcast@plt>:
  401570:	ff 25 d2 8a 20 00    	jmpq   *0x208ad2(%rip)        # 60a048 <_GLOBAL_OFFSET_TABLE_+0x48>
  401576:	68 06 00 00 00       	pushq  $0x6
  40157b:	e9 80 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401580 <puts@plt>:
  401580:	ff 25 ca 8a 20 00    	jmpq   *0x208aca(%rip)        # 60a050 <_GLOBAL_OFFSET_TABLE_+0x50>
  401586:	68 07 00 00 00       	pushq  $0x7
  40158b:	e9 70 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401590 <setsockopt@plt>:
  401590:	ff 25 c2 8a 20 00    	jmpq   *0x208ac2(%rip)        # 60a058 <_GLOBAL_OFFSET_TABLE_+0x58>
  401596:	68 08 00 00 00       	pushq  $0x8
  40159b:	e9 60 ff ff ff       	jmpq   401500 <_init+0x28>

00000000004015a0 <json_object_new_string@plt>:
  4015a0:	ff 25 ba 8a 20 00    	jmpq   *0x208aba(%rip)        # 60a060 <_GLOBAL_OFFSET_TABLE_+0x60>
  4015a6:	68 09 00 00 00       	pushq  $0x9
  4015ab:	e9 50 ff ff ff       	jmpq   401500 <_init+0x28>

00000000004015b0 <write@plt>:
  4015b0:	ff 25 b2 8a 20 00    	jmpq   *0x208ab2(%rip)        # 60a068 <_GLOBAL_OFFSET_TABLE_+0x68>
  4015b6:	68 0a 00 00 00       	pushq  $0xa
  4015bb:	e9 40 ff ff ff       	jmpq   401500 <_init+0x28>

00000000004015c0 <pthread_cond_wait@plt>:
  4015c0:	ff 25 aa 8a 20 00    	jmpq   *0x208aaa(%rip)        # 60a070 <_GLOBAL_OFFSET_TABLE_+0x70>
  4015c6:	68 0b 00 00 00       	pushq  $0xb
  4015cb:	e9 30 ff ff ff       	jmpq   401500 <_init+0x28>

00000000004015d0 <fclose@plt>:
  4015d0:	ff 25 a2 8a 20 00    	jmpq   *0x208aa2(%rip)        # 60a078 <_GLOBAL_OFFSET_TABLE_+0x78>
  4015d6:	68 0c 00 00 00       	pushq  $0xc
  4015db:	e9 20 ff ff ff       	jmpq   401500 <_init+0x28>

00000000004015e0 <json_object_get_string@plt>:
  4015e0:	ff 25 9a 8a 20 00    	jmpq   *0x208a9a(%rip)        # 60a080 <_GLOBAL_OFFSET_TABLE_+0x80>
  4015e6:	68 0d 00 00 00       	pushq  $0xd
  4015eb:	e9 10 ff ff ff       	jmpq   401500 <_init+0x28>

00000000004015f0 <strlen@plt>:
  4015f0:	ff 25 92 8a 20 00    	jmpq   *0x208a92(%rip)        # 60a088 <_GLOBAL_OFFSET_TABLE_+0x88>
  4015f6:	68 0e 00 00 00       	pushq  $0xe
  4015fb:	e9 00 ff ff ff       	jmpq   401500 <_init+0x28>

0000000000401600 <__stack_chk_fail@plt>:
  401600:	ff 25 8a 8a 20 00    	jmpq   *0x208a8a(%rip)        # 60a090 <_GLOBAL_OFFSET_TABLE_+0x90>
  401606:	68 0f 00 00 00       	pushq  $0xf
  40160b:	e9 f0 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401610 <json_object_new_object@plt>:
  401610:	ff 25 82 8a 20 00    	jmpq   *0x208a82(%rip)        # 60a098 <_GLOBAL_OFFSET_TABLE_+0x98>
  401616:	68 10 00 00 00       	pushq  $0x10
  40161b:	e9 e0 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401620 <getopt_long@plt>:
  401620:	ff 25 7a 8a 20 00    	jmpq   *0x208a7a(%rip)        # 60a0a0 <_GLOBAL_OFFSET_TABLE_+0xa0>
  401626:	68 11 00 00 00       	pushq  $0x11
  40162b:	e9 d0 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401630 <htons@plt>:
  401630:	ff 25 72 8a 20 00    	jmpq   *0x208a72(%rip)        # 60a0a8 <_GLOBAL_OFFSET_TABLE_+0xa8>
  401636:	68 12 00 00 00       	pushq  $0x12
  40163b:	e9 c0 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401640 <strchr@plt>:
  401640:	ff 25 6a 8a 20 00    	jmpq   *0x208a6a(%rip)        # 60a0b0 <_GLOBAL_OFFSET_TABLE_+0xb0>
  401646:	68 13 00 00 00       	pushq  $0x13
  40164b:	e9 b0 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401650 <printf@plt>:
  401650:	ff 25 62 8a 20 00    	jmpq   *0x208a62(%rip)        # 60a0b8 <_GLOBAL_OFFSET_TABLE_+0xb8>
  401656:	68 14 00 00 00       	pushq  $0x14
  40165b:	e9 a0 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401660 <pthread_mutex_destroy@plt>:
  401660:	ff 25 5a 8a 20 00    	jmpq   *0x208a5a(%rip)        # 60a0c0 <_GLOBAL_OFFSET_TABLE_+0xc0>
  401666:	68 15 00 00 00       	pushq  $0x15
  40166b:	e9 90 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401670 <fputs@plt>:
  401670:	ff 25 52 8a 20 00    	jmpq   *0x208a52(%rip)        # 60a0c8 <_GLOBAL_OFFSET_TABLE_+0xc8>
  401676:	68 16 00 00 00       	pushq  $0x16
  40167b:	e9 80 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401680 <memset@plt>:
  401680:	ff 25 4a 8a 20 00    	jmpq   *0x208a4a(%rip)        # 60a0d0 <_GLOBAL_OFFSET_TABLE_+0xd0>
  401686:	68 17 00 00 00       	pushq  $0x17
  40168b:	e9 70 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401690 <close@plt>:
  401690:	ff 25 42 8a 20 00    	jmpq   *0x208a42(%rip)        # 60a0d8 <_GLOBAL_OFFSET_TABLE_+0xd8>
  401696:	68 18 00 00 00       	pushq  $0x18
  40169b:	e9 60 fe ff ff       	jmpq   401500 <_init+0x28>

00000000004016a0 <read@plt>:
  4016a0:	ff 25 3a 8a 20 00    	jmpq   *0x208a3a(%rip)        # 60a0e0 <_GLOBAL_OFFSET_TABLE_+0xe0>
  4016a6:	68 19 00 00 00       	pushq  $0x19
  4016ab:	e9 50 fe ff ff       	jmpq   401500 <_init+0x28>

00000000004016b0 <__libc_start_main@plt>:
  4016b0:	ff 25 32 8a 20 00    	jmpq   *0x208a32(%rip)        # 60a0e8 <_GLOBAL_OFFSET_TABLE_+0xe8>
  4016b6:	68 1a 00 00 00       	pushq  $0x1a
  4016bb:	e9 40 fe ff ff       	jmpq   401500 <_init+0x28>

00000000004016c0 <json_object_to_json_string_ext@plt>:
  4016c0:	ff 25 2a 8a 20 00    	jmpq   *0x208a2a(%rip)        # 60a0f0 <_GLOBAL_OFFSET_TABLE_+0xf0>
  4016c6:	68 1b 00 00 00       	pushq  $0x1b
  4016cb:	e9 30 fe ff ff       	jmpq   401500 <_init+0x28>

00000000004016d0 <fgets@plt>:
  4016d0:	ff 25 22 8a 20 00    	jmpq   *0x208a22(%rip)        # 60a0f8 <_GLOBAL_OFFSET_TABLE_+0xf8>
  4016d6:	68 1c 00 00 00       	pushq  $0x1c
  4016db:	e9 20 fe ff ff       	jmpq   401500 <_init+0x28>

00000000004016e0 <json_object_get_int@plt>:
  4016e0:	ff 25 1a 8a 20 00    	jmpq   *0x208a1a(%rip)        # 60a100 <_GLOBAL_OFFSET_TABLE_+0x100>
  4016e6:	68 1d 00 00 00       	pushq  $0x1d
  4016eb:	e9 10 fe ff ff       	jmpq   401500 <_init+0x28>

00000000004016f0 <calloc@plt>:
  4016f0:	ff 25 12 8a 20 00    	jmpq   *0x208a12(%rip)        # 60a108 <_GLOBAL_OFFSET_TABLE_+0x108>
  4016f6:	68 1e 00 00 00       	pushq  $0x1e
  4016fb:	e9 00 fe ff ff       	jmpq   401500 <_init+0x28>

0000000000401700 <strcmp@plt>:
  401700:	ff 25 0a 8a 20 00    	jmpq   *0x208a0a(%rip)        # 60a110 <_GLOBAL_OFFSET_TABLE_+0x110>
  401706:	68 1f 00 00 00       	pushq  $0x1f
  40170b:	e9 f0 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401710 <json_object_new_int@plt>:
  401710:	ff 25 02 8a 20 00    	jmpq   *0x208a02(%rip)        # 60a118 <_GLOBAL_OFFSET_TABLE_+0x118>
  401716:	68 20 00 00 00       	pushq  $0x20
  40171b:	e9 e0 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401720 <fprintf@plt>:
  401720:	ff 25 fa 89 20 00    	jmpq   *0x2089fa(%rip)        # 60a120 <_GLOBAL_OFFSET_TABLE_+0x120>
  401726:	68 21 00 00 00       	pushq  $0x21
  40172b:	e9 d0 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401730 <feof@plt>:
  401730:	ff 25 f2 89 20 00    	jmpq   *0x2089f2(%rip)        # 60a128 <_GLOBAL_OFFSET_TABLE_+0x128>
  401736:	68 22 00 00 00       	pushq  $0x22
  40173b:	e9 c0 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401740 <strtol@plt>:
  401740:	ff 25 ea 89 20 00    	jmpq   *0x2089ea(%rip)        # 60a130 <_GLOBAL_OFFSET_TABLE_+0x130>
  401746:	68 23 00 00 00       	pushq  $0x23
  40174b:	e9 b0 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401750 <memcpy@plt>:
  401750:	ff 25 e2 89 20 00    	jmpq   *0x2089e2(%rip)        # 60a138 <_GLOBAL_OFFSET_TABLE_+0x138>
  401756:	68 24 00 00 00       	pushq  $0x24
  40175b:	e9 a0 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401760 <inet_pton@plt>:
  401760:	ff 25 da 89 20 00    	jmpq   *0x2089da(%rip)        # 60a140 <_GLOBAL_OFFSET_TABLE_+0x140>
  401766:	68 25 00 00 00       	pushq  $0x25
  40176b:	e9 90 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401770 <time@plt>:
  401770:	ff 25 d2 89 20 00    	jmpq   *0x2089d2(%rip)        # 60a148 <_GLOBAL_OFFSET_TABLE_+0x148>
  401776:	68 26 00 00 00       	pushq  $0x26
  40177b:	e9 80 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401780 <json_object_object_add@plt>:
  401780:	ff 25 ca 89 20 00    	jmpq   *0x2089ca(%rip)        # 60a150 <_GLOBAL_OFFSET_TABLE_+0x150>
  401786:	68 27 00 00 00       	pushq  $0x27
  40178b:	e9 70 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401790 <pthread_cond_init@plt>:
  401790:	ff 25 c2 89 20 00    	jmpq   *0x2089c2(%rip)        # 60a158 <_GLOBAL_OFFSET_TABLE_+0x158>
  401796:	68 28 00 00 00       	pushq  $0x28
  40179b:	e9 60 fd ff ff       	jmpq   401500 <_init+0x28>

00000000004017a0 <pthread_mutex_unlock@plt>:
  4017a0:	ff 25 ba 89 20 00    	jmpq   *0x2089ba(%rip)        # 60a160 <_GLOBAL_OFFSET_TABLE_+0x160>
  4017a6:	68 29 00 00 00       	pushq  $0x29
  4017ab:	e9 50 fd ff ff       	jmpq   401500 <_init+0x28>

00000000004017b0 <malloc@plt>:
  4017b0:	ff 25 b2 89 20 00    	jmpq   *0x2089b2(%rip)        # 60a168 <_GLOBAL_OFFSET_TABLE_+0x168>
  4017b6:	68 2a 00 00 00       	pushq  $0x2a
  4017bb:	e9 40 fd ff ff       	jmpq   401500 <_init+0x28>

00000000004017c0 <fflush@plt>:
  4017c0:	ff 25 aa 89 20 00    	jmpq   *0x2089aa(%rip)        # 60a170 <_GLOBAL_OFFSET_TABLE_+0x170>
  4017c6:	68 2b 00 00 00       	pushq  $0x2b
  4017cb:	e9 30 fd ff ff       	jmpq   401500 <_init+0x28>

00000000004017d0 <listen@plt>:
  4017d0:	ff 25 a2 89 20 00    	jmpq   *0x2089a2(%rip)        # 60a178 <_GLOBAL_OFFSET_TABLE_+0x178>
  4017d6:	68 2c 00 00 00       	pushq  $0x2c
  4017db:	e9 20 fd ff ff       	jmpq   401500 <_init+0x28>

00000000004017e0 <poll@plt>:
  4017e0:	ff 25 9a 89 20 00    	jmpq   *0x20899a(%rip)        # 60a180 <_GLOBAL_OFFSET_TABLE_+0x180>
  4017e6:	68 2d 00 00 00       	pushq  $0x2d
  4017eb:	e9 10 fd ff ff       	jmpq   401500 <_init+0x28>

00000000004017f0 <bind@plt>:
  4017f0:	ff 25 92 89 20 00    	jmpq   *0x208992(%rip)        # 60a188 <_GLOBAL_OFFSET_TABLE_+0x188>
  4017f6:	68 2e 00 00 00       	pushq  $0x2e
  4017fb:	e9 00 fd ff ff       	jmpq   401500 <_init+0x28>

0000000000401800 <vsprintf@plt>:
  401800:	ff 25 8a 89 20 00    	jmpq   *0x20898a(%rip)        # 60a190 <_GLOBAL_OFFSET_TABLE_+0x190>
  401806:	68 2f 00 00 00       	pushq  $0x2f
  40180b:	e9 f0 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401810 <pthread_self@plt>:
  401810:	ff 25 82 89 20 00    	jmpq   *0x208982(%rip)        # 60a198 <_GLOBAL_OFFSET_TABLE_+0x198>
  401816:	68 30 00 00 00       	pushq  $0x30
  40181b:	e9 e0 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401820 <pthread_cond_destroy@plt>:
  401820:	ff 25 7a 89 20 00    	jmpq   *0x20897a(%rip)        # 60a1a0 <_GLOBAL_OFFSET_TABLE_+0x1a0>
  401826:	68 31 00 00 00       	pushq  $0x31
  40182b:	e9 d0 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401830 <fopen@plt>:
  401830:	ff 25 72 89 20 00    	jmpq   *0x208972(%rip)        # 60a1a8 <_GLOBAL_OFFSET_TABLE_+0x1a8>
  401836:	68 32 00 00 00       	pushq  $0x32
  40183b:	e9 c0 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401840 <pthread_join@plt>:
  401840:	ff 25 6a 89 20 00    	jmpq   *0x20896a(%rip)        # 60a1b0 <_GLOBAL_OFFSET_TABLE_+0x1b0>
  401846:	68 33 00 00 00       	pushq  $0x33
  40184b:	e9 b0 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401850 <accept@plt>:
  401850:	ff 25 62 89 20 00    	jmpq   *0x208962(%rip)        # 60a1b8 <_GLOBAL_OFFSET_TABLE_+0x1b8>
  401856:	68 34 00 00 00       	pushq  $0x34
  40185b:	e9 a0 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401860 <atoi@plt>:
  401860:	ff 25 5a 89 20 00    	jmpq   *0x20895a(%rip)        # 60a1c0 <_GLOBAL_OFFSET_TABLE_+0x1c0>
  401866:	68 35 00 00 00       	pushq  $0x35
  40186b:	e9 90 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401870 <json_object_object_get@plt>:
  401870:	ff 25 52 89 20 00    	jmpq   *0x208952(%rip)        # 60a1c8 <_GLOBAL_OFFSET_TABLE_+0x1c8>
  401876:	68 36 00 00 00       	pushq  $0x36
  40187b:	e9 80 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401880 <sprintf@plt>:
  401880:	ff 25 4a 89 20 00    	jmpq   *0x20894a(%rip)        # 60a1d0 <_GLOBAL_OFFSET_TABLE_+0x1d0>
  401886:	68 37 00 00 00       	pushq  $0x37
  40188b:	e9 70 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401890 <exit@plt>:
  401890:	ff 25 42 89 20 00    	jmpq   *0x208942(%rip)        # 60a1d8 <_GLOBAL_OFFSET_TABLE_+0x1d8>
  401896:	68 38 00 00 00       	pushq  $0x38
  40189b:	e9 60 fc ff ff       	jmpq   401500 <_init+0x28>

00000000004018a0 <connect@plt>:
  4018a0:	ff 25 3a 89 20 00    	jmpq   *0x20893a(%rip)        # 60a1e0 <_GLOBAL_OFFSET_TABLE_+0x1e0>
  4018a6:	68 39 00 00 00       	pushq  $0x39
  4018ab:	e9 50 fc ff ff       	jmpq   401500 <_init+0x28>

00000000004018b0 <sleep@plt>:
  4018b0:	ff 25 32 89 20 00    	jmpq   *0x208932(%rip)        # 60a1e8 <_GLOBAL_OFFSET_TABLE_+0x1e8>
  4018b6:	68 3a 00 00 00       	pushq  $0x3a
  4018bb:	e9 40 fc ff ff       	jmpq   401500 <_init+0x28>

00000000004018c0 <pthread_mutex_init@plt>:
  4018c0:	ff 25 2a 89 20 00    	jmpq   *0x20892a(%rip)        # 60a1f0 <_GLOBAL_OFFSET_TABLE_+0x1f0>
  4018c6:	68 3b 00 00 00       	pushq  $0x3b
  4018cb:	e9 30 fc ff ff       	jmpq   401500 <_init+0x28>

00000000004018d0 <json_object_put@plt>:
  4018d0:	ff 25 22 89 20 00    	jmpq   *0x208922(%rip)        # 60a1f8 <_GLOBAL_OFFSET_TABLE_+0x1f8>
  4018d6:	68 3c 00 00 00       	pushq  $0x3c
  4018db:	e9 20 fc ff ff       	jmpq   401500 <_init+0x28>

00000000004018e0 <pthread_mutex_lock@plt>:
  4018e0:	ff 25 1a 89 20 00    	jmpq   *0x20891a(%rip)        # 60a200 <_GLOBAL_OFFSET_TABLE_+0x200>
  4018e6:	68 3d 00 00 00       	pushq  $0x3d
  4018eb:	e9 10 fc ff ff       	jmpq   401500 <_init+0x28>

00000000004018f0 <__ctype_b_loc@plt>:
  4018f0:	ff 25 12 89 20 00    	jmpq   *0x208912(%rip)        # 60a208 <_GLOBAL_OFFSET_TABLE_+0x208>
  4018f6:	68 3e 00 00 00       	pushq  $0x3e
  4018fb:	e9 00 fc ff ff       	jmpq   401500 <_init+0x28>

0000000000401900 <socket@plt>:
  401900:	ff 25 0a 89 20 00    	jmpq   *0x20890a(%rip)        # 60a210 <_GLOBAL_OFFSET_TABLE_+0x210>
  401906:	68 3f 00 00 00       	pushq  $0x3f
  40190b:	e9 f0 fb ff ff       	jmpq   401500 <_init+0x28>

Disassembly of section .plt.got:

0000000000401910 <.plt.got>:
  401910:	ff 25 e2 86 20 00    	jmpq   *0x2086e2(%rip)        # 609ff8 <_DYNAMIC+0x1f0>
  401916:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

0000000000401920 <_start>:
  401920:	31 ed                	xor    %ebp,%ebp
  401922:	49 89 d1             	mov    %rdx,%r9
  401925:	5e                   	pop    %rsi
  401926:	48 89 e2             	mov    %rsp,%rdx
  401929:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  40192d:	50                   	push   %rax
  40192e:	54                   	push   %rsp
  40192f:	49 c7 c0 00 6b 40 00 	mov    $0x406b00,%r8
  401936:	48 c7 c1 90 6a 40 00 	mov    $0x406a90,%rcx
  40193d:	48 c7 c7 16 1a 40 00 	mov    $0x401a16,%rdi
  401944:	e8 67 fd ff ff       	callq  4016b0 <__libc_start_main@plt>
  401949:	f4                   	hlt    
  40194a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000401950 <deregister_tm_clones>:
  401950:	b8 af a2 60 00       	mov    $0x60a2af,%eax
  401955:	55                   	push   %rbp
  401956:	48 2d a8 a2 60 00    	sub    $0x60a2a8,%rax
  40195c:	48 83 f8 0e          	cmp    $0xe,%rax
  401960:	48 89 e5             	mov    %rsp,%rbp
  401963:	76 1b                	jbe    401980 <deregister_tm_clones+0x30>
  401965:	b8 00 00 00 00       	mov    $0x0,%eax
  40196a:	48 85 c0             	test   %rax,%rax
  40196d:	74 11                	je     401980 <deregister_tm_clones+0x30>
  40196f:	5d                   	pop    %rbp
  401970:	bf a8 a2 60 00       	mov    $0x60a2a8,%edi
  401975:	ff e0                	jmpq   *%rax
  401977:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40197e:	00 00 
  401980:	5d                   	pop    %rbp
  401981:	c3                   	retq   
  401982:	0f 1f 40 00          	nopl   0x0(%rax)
  401986:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40198d:	00 00 00 

0000000000401990 <register_tm_clones>:
  401990:	be a8 a2 60 00       	mov    $0x60a2a8,%esi
  401995:	55                   	push   %rbp
  401996:	48 81 ee a8 a2 60 00 	sub    $0x60a2a8,%rsi
  40199d:	48 c1 fe 03          	sar    $0x3,%rsi
  4019a1:	48 89 e5             	mov    %rsp,%rbp
  4019a4:	48 89 f0             	mov    %rsi,%rax
  4019a7:	48 c1 e8 3f          	shr    $0x3f,%rax
  4019ab:	48 01 c6             	add    %rax,%rsi
  4019ae:	48 d1 fe             	sar    %rsi
  4019b1:	74 15                	je     4019c8 <register_tm_clones+0x38>
  4019b3:	b8 00 00 00 00       	mov    $0x0,%eax
  4019b8:	48 85 c0             	test   %rax,%rax
  4019bb:	74 0b                	je     4019c8 <register_tm_clones+0x38>
  4019bd:	5d                   	pop    %rbp
  4019be:	bf a8 a2 60 00       	mov    $0x60a2a8,%edi
  4019c3:	ff e0                	jmpq   *%rax
  4019c5:	0f 1f 00             	nopl   (%rax)
  4019c8:	5d                   	pop    %rbp
  4019c9:	c3                   	retq   
  4019ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004019d0 <__do_global_dtors_aux>:
  4019d0:	80 3d f1 88 20 00 00 	cmpb   $0x0,0x2088f1(%rip)        # 60a2c8 <completed.7594>
  4019d7:	75 11                	jne    4019ea <__do_global_dtors_aux+0x1a>
  4019d9:	55                   	push   %rbp
  4019da:	48 89 e5             	mov    %rsp,%rbp
  4019dd:	e8 6e ff ff ff       	callq  401950 <deregister_tm_clones>
  4019e2:	5d                   	pop    %rbp
  4019e3:	c6 05 de 88 20 00 01 	movb   $0x1,0x2088de(%rip)        # 60a2c8 <completed.7594>
  4019ea:	f3 c3                	repz retq 
  4019ec:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004019f0 <frame_dummy>:
  4019f0:	bf 00 9e 60 00       	mov    $0x609e00,%edi
  4019f5:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  4019f9:	75 05                	jne    401a00 <frame_dummy+0x10>
  4019fb:	eb 93                	jmp    401990 <register_tm_clones>
  4019fd:	0f 1f 00             	nopl   (%rax)
  401a00:	b8 00 00 00 00       	mov    $0x0,%eax
  401a05:	48 85 c0             	test   %rax,%rax
  401a08:	74 f1                	je     4019fb <frame_dummy+0xb>
  401a0a:	55                   	push   %rbp
  401a0b:	48 89 e5             	mov    %rsp,%rbp
  401a0e:	ff d0                	callq  *%rax
  401a10:	5d                   	pop    %rbp
  401a11:	e9 7a ff ff ff       	jmpq   401990 <register_tm_clones>

0000000000401a16 <main>:
 	 * Parameter:   char** argv - [1] config file name
 	 * Return: 	    Success - 0
 	 * 				Failure - GSI_IS_FAIL
#############################################################################*/
int main(int argc, char **argv)
{
  401a16:	55                   	push   %rbp
  401a17:	48 89 e5             	mov    %rsp,%rbp
  401a1a:	53                   	push   %rbx
  401a1b:	48 81 ec 88 01 00 00 	sub    $0x188,%rsp
  401a22:	89 bd 7c fe ff ff    	mov    %edi,-0x184(%rbp)
  401a28:	48 89 b5 70 fe ff ff 	mov    %rsi,-0x190(%rbp)
  401a2f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401a36:	00 00 
  401a38:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  401a3c:	31 c0                	xor    %eax,%eax
	struct gsi_net_tcp client;
	char s_file_name[GSI_IS_LOG_MAX_FILE_NAME];
	FILE* f_messages = NULL;
  401a3e:	48 c7 85 80 fe ff ff 	movq   $0x0,-0x180(%rbp)
  401a45:	00 00 00 00 
	FILE* f_log = NULL;
  401a49:	48 c7 85 88 fe ff ff 	movq   $0x0,-0x178(%rbp)
  401a50:	00 00 00 00 

	if (2 != argc)
  401a54:	83 bd 7c fe ff ff 02 	cmpl   $0x2,-0x184(%rbp)
  401a5b:	74 14                	je     401a71 <main+0x5b>
	{
		printf("usage error: <a.out> --config=<config_file>\n");
  401a5d:	bf 18 6b 40 00       	mov    $0x406b18,%edi
  401a62:	e8 19 fb ff ff       	callq  401580 <puts@plt>
		return GSI_IS_FAIL;
  401a67:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401a6c:	e9 1a 02 00 00       	jmpq   401c8b <main+0x275>
	}

	// Create log file
	memset(s_file_name, 0, sizeof(s_file_name));
  401a71:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  401a78:	ba 00 01 00 00       	mov    $0x100,%edx
  401a7d:	be 00 00 00 00       	mov    $0x0,%esi
  401a82:	48 89 c7             	mov    %rax,%rdi
  401a85:	e8 f6 fb ff ff       	callq  401680 <memset@plt>
	sprintf(s_file_name, "gsi-log-client-3");
  401a8a:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  401a91:	48 b9 67 73 69 2d 6c 	movabs $0x2d676f6c2d697367,%rcx
  401a98:	6f 67 2d 
  401a9b:	48 89 08             	mov    %rcx,(%rax)
  401a9e:	48 b9 63 6c 69 65 6e 	movabs $0x332d746e65696c63,%rcx
  401aa5:	74 2d 33 
  401aa8:	48 89 48 08          	mov    %rcx,0x8(%rax)
  401aac:	c6 40 10 00          	movb   $0x0,0x10(%rax)

	f_log = gsi_is_create_log_file(s_file_name, NULL);
  401ab0:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  401ab7:	be 00 00 00 00       	mov    $0x0,%esi
  401abc:	48 89 c7             	mov    %rax,%rdi
  401abf:	e8 3f 37 00 00       	callq  405203 <gsi_is_create_log_file>
  401ac4:	48 89 85 88 fe ff ff 	mov    %rax,-0x178(%rbp)
	if (NULL == f_log)
  401acb:	48 83 bd 88 fe ff ff 	cmpq   $0x0,-0x178(%rbp)
  401ad2:	00 
  401ad3:	75 0a                	jne    401adf <main+0xc9>
	{
		return GSI_IS_FAIL;
  401ad5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401ada:	e9 ac 01 00 00       	jmpq   401c8b <main+0x275>
	}

	// Set configuration parameters for client program read it from config file given by argv
	if (GSI_PARSE_JSON_CONFIG_SUCCESS != gsi_parse_json_config_get_config(argc, argv))
  401adf:	48 8b 95 70 fe ff ff 	mov    -0x190(%rbp),%rdx
  401ae6:	8b 85 7c fe ff ff    	mov    -0x184(%rbp),%eax
  401aec:	48 89 d6             	mov    %rdx,%rsi
  401aef:	89 c7                	mov    %eax,%edi
  401af1:	e8 55 41 00 00       	callq  405c4b <gsi_parse_json_config_get_config>
  401af6:	85 c0                	test   %eax,%eax
  401af8:	74 14                	je     401b0e <main+0xf8>
	{
		printf("cannot load configuration parameters\n");
  401afa:	bf 48 6b 40 00       	mov    $0x406b48,%edi
  401aff:	e8 7c fa ff ff       	callq  401580 <puts@plt>
		return GSI_IS_FAIL;
  401b04:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401b09:	e9 7d 01 00 00       	jmpq   401c8b <main+0x275>
	}

	// Connect client to server
	if (GSI_NET_RC_SUCCESS != gsi_client_connect_client_to_server(&client, g_config_client_params.ui_port))
  401b0e:	8b 15 8c 88 20 00    	mov    0x20888c(%rip),%edx        # 60a3a0 <g_config_client_params>
  401b14:	48 8d 85 90 fe ff ff 	lea    -0x170(%rbp),%rax
  401b1b:	89 d6                	mov    %edx,%esi
  401b1d:	48 89 c7             	mov    %rax,%rdi
  401b20:	e8 84 01 00 00       	callq  401ca9 <gsi_client_connect_client_to_server>
  401b25:	85 c0                	test   %eax,%eax
  401b27:	74 41                	je     401b6a <main+0x154>
	{
		LOG_ERROR("client connect failed");
  401b29:	b8 00 00 00 00       	mov    $0x0,%eax
  401b2e:	e8 09 3b 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401b33:	48 89 c3             	mov    %rax,%rbx
  401b36:	b8 00 00 00 00       	mov    $0x0,%eax
  401b3b:	e8 77 38 00 00       	callq  4053b7 <gsi_get_saved_file>
  401b40:	41 b8 50 00 00 00    	mov    $0x50,%r8d
  401b46:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401b4b:	48 89 da             	mov    %rbx,%rdx
  401b4e:	be 98 6b 40 00       	mov    $0x406b98,%esi
  401b53:	48 89 c7             	mov    %rax,%rdi
  401b56:	b8 00 00 00 00       	mov    $0x0,%eax
  401b5b:	e8 c0 38 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_IS_FAIL;
  401b60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  401b65:	e9 21 01 00 00       	jmpq   401c8b <main+0x275>
	}

	// Open the Messages file to read messages from it.
	f_messages = gsi_is_open_msg_file(g_config_client_params.s_messages_file);
  401b6a:	bf b4 a3 60 00       	mov    $0x60a3b4,%edi
  401b6f:	e8 c9 03 00 00       	callq  401f3d <gsi_is_open_msg_file>
  401b74:	48 89 85 80 fe ff ff 	mov    %rax,-0x180(%rbp)
	if (NULL == f_messages)
  401b7b:	48 83 bd 80 fe ff ff 	cmpq   $0x0,-0x180(%rbp)
  401b82:	00 
  401b83:	75 41                	jne    401bc6 <main+0x1b0>
	{
		LOG_ERROR("couldn't open messages file");
  401b85:	b8 00 00 00 00       	mov    $0x0,%eax
  401b8a:	e8 ad 3a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401b8f:	48 89 c3             	mov    %rax,%rbx
  401b92:	b8 00 00 00 00       	mov    $0x0,%eax
  401b97:	e8 1b 38 00 00       	callq  4053b7 <gsi_get_saved_file>
  401b9c:	41 b8 58 00 00 00    	mov    $0x58,%r8d
  401ba2:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401ba7:	48 89 da             	mov    %rbx,%rdx
  401baa:	be d0 6b 40 00       	mov    $0x406bd0,%esi
  401baf:	48 89 c7             	mov    %rax,%rdi
  401bb2:	b8 00 00 00 00       	mov    $0x0,%eax
  401bb7:	e8 64 38 00 00       	callq  405420 <gsi_is_write_to_log>
		exit(0);
  401bbc:	bf 00 00 00 00       	mov    $0x0,%edi
  401bc1:	e8 ca fc ff ff       	callq  401890 <exit@plt>
	}

	// Send messages
	if (GSI_JSON_SUCCESS != gsi_is_send_all_json_msg(f_messages, &client))
  401bc6:	48 8d 95 90 fe ff ff 	lea    -0x170(%rbp),%rdx
  401bcd:	48 8b 85 80 fe ff ff 	mov    -0x180(%rbp),%rax
  401bd4:	48 89 d6             	mov    %rdx,%rsi
  401bd7:	48 89 c7             	mov    %rax,%rdi
  401bda:	e8 77 05 00 00       	callq  402156 <gsi_is_send_all_json_msg>
  401bdf:	85 c0                	test   %eax,%eax
  401be1:	74 37                	je     401c1a <main+0x204>
	{
		LOG_ERROR("send messages to server failed");
  401be3:	b8 00 00 00 00       	mov    $0x0,%eax
  401be8:	e8 4f 3a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401bed:	48 89 c3             	mov    %rax,%rbx
  401bf0:	b8 00 00 00 00       	mov    $0x0,%eax
  401bf5:	e8 bd 37 00 00       	callq  4053b7 <gsi_get_saved_file>
  401bfa:	41 b8 5f 00 00 00    	mov    $0x5f,%r8d
  401c00:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401c05:	48 89 da             	mov    %rbx,%rdx
  401c08:	be 10 6c 40 00       	mov    $0x406c10,%esi
  401c0d:	48 89 c7             	mov    %rax,%rdi
  401c10:	b8 00 00 00 00       	mov    $0x0,%eax
  401c15:	e8 06 38 00 00       	callq  405420 <gsi_is_write_to_log>
	}

	// Close messages file
	if (GSI_JSON_SUCCESS != gsi_is_close_msg_file(f_messages))
  401c1a:	48 8b 85 80 fe ff ff 	mov    -0x180(%rbp),%rax
  401c21:	48 89 c7             	mov    %rax,%rdi
  401c24:	e8 d3 03 00 00       	callq  401ffc <gsi_is_close_msg_file>
  401c29:	85 c0                	test   %eax,%eax
  401c2b:	74 37                	je     401c64 <main+0x24e>
	{
		LOG_ERROR("couldn't close messages file")
  401c2d:	b8 00 00 00 00       	mov    $0x0,%eax
  401c32:	e8 05 3a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401c37:	48 89 c3             	mov    %rax,%rbx
  401c3a:	b8 00 00 00 00       	mov    $0x0,%eax
  401c3f:	e8 73 37 00 00       	callq  4053b7 <gsi_get_saved_file>
  401c44:	41 b8 65 00 00 00    	mov    $0x65,%r8d
  401c4a:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401c4f:	48 89 da             	mov    %rbx,%rdx
  401c52:	be 50 6c 40 00       	mov    $0x406c50,%esi
  401c57:	48 89 c7             	mov    %rax,%rdi
  401c5a:	b8 00 00 00 00       	mov    $0x0,%eax
  401c5f:	e8 bc 37 00 00       	callq  405420 <gsi_is_write_to_log>
	}

	// Close log file to free resources
	if (GSI_LOG_RC_SUCCESS != gsi_is_close_log(f_log))
  401c64:	48 8b 85 88 fe ff ff 	mov    -0x178(%rbp),%rax
  401c6b:	48 89 c7             	mov    %rax,%rdi
  401c6e:	e8 6a 39 00 00       	callq  4055dd <gsi_is_close_log>
  401c73:	85 c0                	test   %eax,%eax
  401c75:	74 0f                	je     401c86 <main+0x270>
	{
		printf("couldn't close log file");
  401c77:	bf 8e 6c 40 00       	mov    $0x406c8e,%edi
  401c7c:	b8 00 00 00 00       	mov    $0x0,%eax
  401c81:	e8 ca f9 ff ff       	callq  401650 <printf@plt>
	}

	return 0;
  401c86:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401c8b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  401c8f:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  401c96:	00 00 
  401c98:	74 05                	je     401c9f <main+0x289>
  401c9a:	e8 61 f9 ff ff       	callq  401600 <__stack_chk_fail@plt>
  401c9f:	48 81 c4 88 01 00 00 	add    $0x188,%rsp
  401ca6:	5b                   	pop    %rbx
  401ca7:	5d                   	pop    %rbp
  401ca8:	c3                   	retq   

0000000000401ca9 <gsi_client_connect_client_to_server>:
	 * Parameter:   [in] unsigned int ui_port - port for connection
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR *OR* GSI_NET_RC_CONNECTERR
#############################################################################*/
static enum gsi_is_network_return_code gsi_client_connect_client_to_server(struct gsi_net_tcp* p_client, unsigned int ui_port)
{
  401ca9:	55                   	push   %rbp
  401caa:	48 89 e5             	mov    %rsp,%rbp
  401cad:	41 54                	push   %r12
  401caf:	53                   	push   %rbx
  401cb0:	48 83 ec 40          	sub    $0x40,%rsp
  401cb4:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  401cb8:	89 75 b4             	mov    %esi,-0x4c(%rbp)
  401cbb:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401cc2:	00 00 
  401cc4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  401cc8:	31 c0                	xor    %eax,%eax
	int i_rc = 0;
  401cca:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
	int i_retry = 0;
  401cd1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
	char s_buffer[GSI_IS_ADDRESS_LENGTH];

	// Check input validation
	if (NULL == p_client)
  401cd8:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  401cdd:	75 41                	jne    401d20 <gsi_client_connect_client_to_server+0x77>
	{
		LOG_ERROR("invalid arguments");
  401cdf:	b8 00 00 00 00       	mov    $0x0,%eax
  401ce4:	e8 53 39 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401ce9:	48 89 c3             	mov    %rax,%rbx
  401cec:	b8 00 00 00 00       	mov    $0x0,%eax
  401cf1:	e8 c1 36 00 00       	callq  4053b7 <gsi_get_saved_file>
  401cf6:	41 b8 86 00 00 00    	mov    $0x86,%r8d
  401cfc:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401d01:	48 89 da             	mov    %rbx,%rdx
  401d04:	be a8 6c 40 00       	mov    $0x406ca8,%esi
  401d09:	48 89 c7             	mov    %rax,%rdi
  401d0c:	b8 00 00 00 00       	mov    $0x0,%eax
  401d11:	e8 0a 37 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  401d16:	b8 01 00 00 00       	mov    $0x1,%eax
  401d1b:	e9 00 02 00 00       	jmpq   401f20 <gsi_client_connect_client_to_server+0x277>
	}

	// Reset server fields
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_reset(p_client))
  401d20:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  401d24:	48 89 c7             	mov    %rax,%rdi
  401d27:	e8 de 1d 00 00       	callq  403b0a <gsi_is_network_tcp_reset>
  401d2c:	85 c0                	test   %eax,%eax
  401d2e:	74 41                	je     401d71 <gsi_client_connect_client_to_server+0xc8>
	{
		LOG_ERROR("reset client fields failed");
  401d30:	b8 00 00 00 00       	mov    $0x0,%eax
  401d35:	e8 02 39 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401d3a:	48 89 c3             	mov    %rax,%rbx
  401d3d:	b8 00 00 00 00       	mov    $0x0,%eax
  401d42:	e8 70 36 00 00       	callq  4053b7 <gsi_get_saved_file>
  401d47:	41 b8 8d 00 00 00    	mov    $0x8d,%r8d
  401d4d:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401d52:	48 89 da             	mov    %rbx,%rdx
  401d55:	be e0 6c 40 00       	mov    $0x406ce0,%esi
  401d5a:	48 89 c7             	mov    %rax,%rdi
  401d5d:	b8 00 00 00 00       	mov    $0x0,%eax
  401d62:	e8 b9 36 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  401d67:	b8 01 00 00 00       	mov    $0x1,%eax
  401d6c:	e9 af 01 00 00       	jmpq   401f20 <gsi_client_connect_client_to_server+0x277>
	}

	do
	{
		// Reset buffer
		memset(s_buffer, 0, sizeof(s_buffer));
  401d71:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  401d75:	ba 17 00 00 00       	mov    $0x17,%edx
  401d7a:	be 00 00 00 00       	mov    $0x0,%esi
  401d7f:	48 89 c7             	mov    %rax,%rdi
  401d82:	e8 f9 f8 ff ff       	callq  401680 <memset@plt>

		// Create string <IP>:<Port> connect to local host
		sprintf(s_buffer, "127.0.0.1:%d", ui_port);
  401d87:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  401d8a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  401d8e:	be 1c 6d 40 00       	mov    $0x406d1c,%esi
  401d93:	48 89 c7             	mov    %rax,%rdi
  401d96:	b8 00 00 00 00       	mov    $0x0,%eax
  401d9b:	e8 e0 fa ff ff       	callq  401880 <sprintf@plt>

		// Init client and connect to server
		i_rc = gsi_is_network_tcp_client_init(p_client, s_buffer);
  401da0:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  401da4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  401da8:	48 89 d6             	mov    %rdx,%rsi
  401dab:	48 89 c7             	mov    %rax,%rdi
  401dae:	e8 88 22 00 00       	callq  40403b <gsi_is_network_tcp_client_init>
  401db3:	89 45 cc             	mov    %eax,-0x34(%rbp)
		if (GSI_NET_RC_SUCCESS == i_rc)
  401db6:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  401dba:	0f 84 88 00 00 00    	je     401e48 <gsi_client_connect_client_to_server+0x19f>
		{
			break;
		}

		LOG_ERROR("client init failed");
  401dc0:	b8 00 00 00 00       	mov    $0x0,%eax
  401dc5:	e8 72 38 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401dca:	48 89 c3             	mov    %rax,%rbx
  401dcd:	b8 00 00 00 00       	mov    $0x0,%eax
  401dd2:	e8 e0 35 00 00       	callq  4053b7 <gsi_get_saved_file>
  401dd7:	41 b8 a0 00 00 00    	mov    $0xa0,%r8d
  401ddd:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401de2:	48 89 da             	mov    %rbx,%rdx
  401de5:	be 30 6d 40 00       	mov    $0x406d30,%esi
  401dea:	48 89 c7             	mov    %rax,%rdi
  401ded:	b8 00 00 00 00       	mov    $0x0,%eax
  401df2:	e8 29 36 00 00       	callq  405420 <gsi_is_write_to_log>
		LOG_ERROR("Reconnect...");
  401df7:	b8 00 00 00 00       	mov    $0x0,%eax
  401dfc:	e8 3b 38 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401e01:	48 89 c3             	mov    %rax,%rbx
  401e04:	b8 00 00 00 00       	mov    $0x0,%eax
  401e09:	e8 a9 35 00 00       	callq  4053b7 <gsi_get_saved_file>
  401e0e:	41 b8 a1 00 00 00    	mov    $0xa1,%r8d
  401e14:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401e19:	48 89 da             	mov    %rbx,%rdx
  401e1c:	be 68 6d 40 00       	mov    $0x406d68,%esi
  401e21:	48 89 c7             	mov    %rax,%rdi
  401e24:	b8 00 00 00 00       	mov    $0x0,%eax
  401e29:	e8 f2 35 00 00       	callq  405420 <gsi_is_write_to_log>

		++i_retry;
  401e2e:	83 45 c8 01          	addl   $0x1,-0x38(%rbp)

		sleep(1);
  401e32:	bf 01 00 00 00       	mov    $0x1,%edi
  401e37:	e8 74 fa ff ff       	callq  4018b0 <sleep@plt>
	}
	while (i_retry < GSI_IS_RECONNECT_TRY);
  401e3c:	83 7d c8 02          	cmpl   $0x2,-0x38(%rbp)
  401e40:	0f 8e 2b ff ff ff    	jle    401d71 <gsi_client_connect_client_to_server+0xc8>
  401e46:	eb 01                	jmp    401e49 <gsi_client_connect_client_to_server+0x1a0>

		// Init client and connect to server
		i_rc = gsi_is_network_tcp_client_init(p_client, s_buffer);
		if (GSI_NET_RC_SUCCESS == i_rc)
		{
			break;
  401e48:	90                   	nop
		sleep(1);
	}
	while (i_retry < GSI_IS_RECONNECT_TRY);

	// No respond - exit program
	if ((GSI_NET_RC_CONNECTERR == i_rc) && (i_retry == GSI_IS_RECONNECT_TRY))
  401e49:	83 7d cc 04          	cmpl   $0x4,-0x34(%rbp)
  401e4d:	75 47                	jne    401e96 <gsi_client_connect_client_to_server+0x1ed>
  401e4f:	83 7d c8 03          	cmpl   $0x3,-0x38(%rbp)
  401e53:	75 41                	jne    401e96 <gsi_client_connect_client_to_server+0x1ed>
	{
		LOG_ERROR("server is not responding...client leave");
  401e55:	b8 00 00 00 00       	mov    $0x0,%eax
  401e5a:	e8 dd 37 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401e5f:	48 89 c3             	mov    %rax,%rbx
  401e62:	b8 00 00 00 00       	mov    $0x0,%eax
  401e67:	e8 4b 35 00 00       	callq  4053b7 <gsi_get_saved_file>
  401e6c:	41 b8 ac 00 00 00    	mov    $0xac,%r8d
  401e72:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401e77:	48 89 da             	mov    %rbx,%rdx
  401e7a:	be 98 6d 40 00       	mov    $0x406d98,%esi
  401e7f:	48 89 c7             	mov    %rax,%rdi
  401e82:	b8 00 00 00 00       	mov    $0x0,%eax
  401e87:	e8 94 35 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_CONNECTERR;
  401e8c:	b8 04 00 00 00       	mov    $0x4,%eax
  401e91:	e9 8a 00 00 00       	jmpq   401f20 <gsi_client_connect_client_to_server+0x277>
	}

	// General error - exit program
	if (GSI_NET_RC_ERROR == i_rc)
  401e96:	83 7d cc 01          	cmpl   $0x1,-0x34(%rbp)
  401e9a:	75 3e                	jne    401eda <gsi_client_connect_client_to_server+0x231>
	{
		LOG_ERROR("error has been occurred");
  401e9c:	b8 00 00 00 00       	mov    $0x0,%eax
  401ea1:	e8 96 37 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401ea6:	48 89 c3             	mov    %rax,%rbx
  401ea9:	b8 00 00 00 00       	mov    $0x0,%eax
  401eae:	e8 04 35 00 00       	callq  4053b7 <gsi_get_saved_file>
  401eb3:	41 b8 b3 00 00 00    	mov    $0xb3,%r8d
  401eb9:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401ebe:	48 89 da             	mov    %rbx,%rdx
  401ec1:	be e8 6d 40 00       	mov    $0x406de8,%esi
  401ec6:	48 89 c7             	mov    %rax,%rdi
  401ec9:	b8 00 00 00 00       	mov    $0x0,%eax
  401ece:	e8 4d 35 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  401ed3:	b8 01 00 00 00       	mov    $0x1,%eax
  401ed8:	eb 46                	jmp    401f20 <gsi_client_connect_client_to_server+0x277>
	}

	LOG_INFO("client connect successfully to port %d", p_client->ui_port);
  401eda:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  401ede:	8b 58 28             	mov    0x28(%rax),%ebx
  401ee1:	b8 00 00 00 00       	mov    $0x0,%eax
  401ee6:	e8 51 37 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401eeb:	49 89 c4             	mov    %rax,%r12
  401eee:	b8 00 00 00 00       	mov    $0x0,%eax
  401ef3:	e8 bf 34 00 00       	callq  4053b7 <gsi_get_saved_file>
  401ef8:	41 89 d9             	mov    %ebx,%r9d
  401efb:	41 b8 b7 00 00 00    	mov    $0xb7,%r8d
  401f01:	b9 70 6b 40 00       	mov    $0x406b70,%ecx
  401f06:	4c 89 e2             	mov    %r12,%rdx
  401f09:	be 28 6e 40 00       	mov    $0x406e28,%esi
  401f0e:	48 89 c7             	mov    %rax,%rdi
  401f11:	b8 00 00 00 00       	mov    $0x0,%eax
  401f16:	e8 05 35 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  401f1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401f20:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  401f24:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  401f2b:	00 00 
  401f2d:	74 05                	je     401f34 <gsi_client_connect_client_to_server+0x28b>
  401f2f:	e8 cc f6 ff ff       	callq  401600 <__stack_chk_fail@plt>
  401f34:	48 83 c4 40          	add    $0x40,%rsp
  401f38:	5b                   	pop    %rbx
  401f39:	41 5c                	pop    %r12
  401f3b:	5d                   	pop    %rbp
  401f3c:	c3                   	retq   

0000000000401f3d <gsi_is_open_msg_file>:
	 * Parameter:   [in] const char* s_file_name - file's name to open in READ mode
	 * Return:		Success - FILE* - handler to opened file
	 * 				Failure - NULL
#############################################################################*/
FILE* gsi_is_open_msg_file(const char* s_file_name)
{
  401f3d:	55                   	push   %rbp
  401f3e:	48 89 e5             	mov    %rsp,%rbp
  401f41:	53                   	push   %rbx
  401f42:	48 83 ec 28          	sub    $0x28,%rsp
  401f46:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	FILE* f_msg_file = NULL;
  401f4a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  401f51:	00 

	// Check input validation
	if (NULL == s_file_name)
  401f52:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  401f57:	75 3e                	jne    401f97 <gsi_is_open_msg_file+0x5a>
	{
		LOG_ERROR("invalid argument!");
  401f59:	b8 00 00 00 00       	mov    $0x0,%eax
  401f5e:	e8 d9 36 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401f63:	48 89 c3             	mov    %rax,%rbx
  401f66:	b8 00 00 00 00       	mov    $0x0,%eax
  401f6b:	e8 47 34 00 00       	callq  4053b7 <gsi_get_saved_file>
  401f70:	41 b8 37 00 00 00    	mov    $0x37,%r8d
  401f76:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  401f7b:	48 89 da             	mov    %rbx,%rdx
  401f7e:	be 90 6e 40 00       	mov    $0x406e90,%esi
  401f83:	48 89 c7             	mov    %rax,%rdi
  401f86:	b8 00 00 00 00       	mov    $0x0,%eax
  401f8b:	e8 90 34 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  401f90:	b8 00 00 00 00       	mov    $0x0,%eax
  401f95:	eb 5e                	jmp    401ff5 <gsi_is_open_msg_file+0xb8>
	}

	// Open messages file
	f_msg_file = fopen(s_file_name, "r");
  401f97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401f9b:	be c3 6e 40 00       	mov    $0x406ec3,%esi
  401fa0:	48 89 c7             	mov    %rax,%rdi
  401fa3:	e8 88 f8 ff ff       	callq  401830 <fopen@plt>
  401fa8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == f_msg_file)
  401fac:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  401fb1:	75 3e                	jne    401ff1 <gsi_is_open_msg_file+0xb4>
	{
		LOG_ERROR("couldn't open file: %s", s_file_name);
  401fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  401fb8:	e8 7f 36 00 00       	callq  40563c <gsi_is_gen_timestamp>
  401fbd:	48 89 c3             	mov    %rax,%rbx
  401fc0:	b8 00 00 00 00       	mov    $0x0,%eax
  401fc5:	e8 ed 33 00 00       	callq  4053b7 <gsi_get_saved_file>
  401fca:	48 89 c7             	mov    %rax,%rdi
  401fcd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401fd1:	49 89 c1             	mov    %rax,%r9
  401fd4:	41 b8 3f 00 00 00    	mov    $0x3f,%r8d
  401fda:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  401fdf:	48 89 da             	mov    %rbx,%rdx
  401fe2:	be c8 6e 40 00       	mov    $0x406ec8,%esi
  401fe7:	b8 00 00 00 00       	mov    $0x0,%eax
  401fec:	e8 2f 34 00 00       	callq  405420 <gsi_is_write_to_log>
	}

	return f_msg_file;
  401ff1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  401ff5:	48 83 c4 28          	add    $0x28,%rsp
  401ff9:	5b                   	pop    %rbx
  401ffa:	5d                   	pop    %rbp
  401ffb:	c3                   	retq   

0000000000401ffc <gsi_is_close_msg_file>:
	 * Parameter:   [in] FILE* f_msg_file - handler to opened file
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_CLOSE_ERR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_is_close_msg_file(FILE* f_msg_file)
{
  401ffc:	55                   	push   %rbp
  401ffd:	48 89 e5             	mov    %rsp,%rbp
  402000:	53                   	push   %rbx
  402001:	48 83 ec 18          	sub    $0x18,%rsp
  402005:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == f_msg_file)
  402009:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  40200e:	75 3e                	jne    40204e <gsi_is_close_msg_file+0x52>
	{
		LOG_ERROR("invalid argument!");
  402010:	b8 00 00 00 00       	mov    $0x0,%eax
  402015:	e8 22 36 00 00       	callq  40563c <gsi_is_gen_timestamp>
  40201a:	48 89 c3             	mov    %rax,%rbx
  40201d:	b8 00 00 00 00       	mov    $0x0,%eax
  402022:	e8 90 33 00 00       	callq  4053b7 <gsi_get_saved_file>
  402027:	41 b8 51 00 00 00    	mov    $0x51,%r8d
  40202d:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402032:	48 89 da             	mov    %rbx,%rdx
  402035:	be 90 6e 40 00       	mov    $0x406e90,%esi
  40203a:	48 89 c7             	mov    %rax,%rdi
  40203d:	b8 00 00 00 00       	mov    $0x0,%eax
  402042:	e8 d9 33 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  402047:	b8 01 00 00 00       	mov    $0x1,%eax
  40204c:	eb 53                	jmp    4020a1 <gsi_is_close_msg_file+0xa5>
	}

	// Close file
	if (0 != fclose(f_msg_file))
  40204e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402052:	48 89 c7             	mov    %rax,%rdi
  402055:	e8 76 f5 ff ff       	callq  4015d0 <fclose@plt>
  40205a:	85 c0                	test   %eax,%eax
  40205c:	74 3e                	je     40209c <gsi_is_close_msg_file+0xa0>
	{
		LOG_ERROR("couldn't close messages file");
  40205e:	b8 00 00 00 00       	mov    $0x0,%eax
  402063:	e8 d4 35 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402068:	48 89 c3             	mov    %rax,%rbx
  40206b:	b8 00 00 00 00       	mov    $0x0,%eax
  402070:	e8 42 33 00 00       	callq  4053b7 <gsi_get_saved_file>
  402075:	41 b8 58 00 00 00    	mov    $0x58,%r8d
  40207b:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402080:	48 89 da             	mov    %rbx,%rdx
  402083:	be 00 6f 40 00       	mov    $0x406f00,%esi
  402088:	48 89 c7             	mov    %rax,%rdi
  40208b:	b8 00 00 00 00       	mov    $0x0,%eax
  402090:	e8 8b 33 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_CLOSE_ERR;
  402095:	b8 03 00 00 00       	mov    $0x3,%eax
  40209a:	eb 05                	jmp    4020a1 <gsi_is_close_msg_file+0xa5>
	}

	return GSI_JSON_SUCCESS;
  40209c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4020a1:	48 83 c4 18          	add    $0x18,%rsp
  4020a5:	5b                   	pop    %rbx
  4020a6:	5d                   	pop    %rbp
  4020a7:	c3                   	retq   

00000000004020a8 <gsi_build_parse_reset_object>:
	 * Parameter:   [in-out] struct gsi_json_msg* p_json_msg - pointer to reset
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_build_parse_reset_object(struct gsi_json_msg* p_json_msg)
{
  4020a8:	55                   	push   %rbp
  4020a9:	48 89 e5             	mov    %rsp,%rbp
  4020ac:	53                   	push   %rbx
  4020ad:	48 83 ec 18          	sub    $0x18,%rsp
  4020b1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == p_json_msg)
  4020b5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4020ba:	75 3e                	jne    4020fa <gsi_build_parse_reset_object+0x52>
	{
		LOG_ERROR("invalid argument!");
  4020bc:	b8 00 00 00 00       	mov    $0x0,%eax
  4020c1:	e8 76 35 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4020c6:	48 89 c3             	mov    %rax,%rbx
  4020c9:	b8 00 00 00 00       	mov    $0x0,%eax
  4020ce:	e8 e4 32 00 00       	callq  4053b7 <gsi_get_saved_file>
  4020d3:	41 b8 6b 00 00 00    	mov    $0x6b,%r8d
  4020d9:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4020de:	48 89 da             	mov    %rbx,%rdx
  4020e1:	be 90 6e 40 00       	mov    $0x406e90,%esi
  4020e6:	48 89 c7             	mov    %rax,%rdi
  4020e9:	b8 00 00 00 00       	mov    $0x0,%eax
  4020ee:	e8 2d 33 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  4020f3:	b8 01 00 00 00       	mov    $0x1,%eax
  4020f8:	eb 55                	jmp    40214f <gsi_build_parse_reset_object+0xa7>
	}

	// Check if need to free s_file_name
	if (NULL != p_json_msg->s_file_name)
  4020fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4020fe:	48 8b 40 18          	mov    0x18(%rax),%rax
  402102:	48 85 c0             	test   %rax,%rax
  402105:	74 10                	je     402117 <gsi_build_parse_reset_object+0x6f>
	{
		free(p_json_msg->s_file_name);
  402107:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40210b:	48 8b 40 18          	mov    0x18(%rax),%rax
  40210f:	48 89 c7             	mov    %rax,%rdi
  402112:	e8 09 f4 ff ff       	callq  401520 <free@plt>
	}

	// Check if need to free s_data
	if (NULL != p_json_msg->s_data)
  402117:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40211b:	48 8b 40 20          	mov    0x20(%rax),%rax
  40211f:	48 85 c0             	test   %rax,%rax
  402122:	74 10                	je     402134 <gsi_build_parse_reset_object+0x8c>
	{
		free(p_json_msg->s_data);
  402124:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402128:	48 8b 40 20          	mov    0x20(%rax),%rax
  40212c:	48 89 c7             	mov    %rax,%rdi
  40212f:	e8 ec f3 ff ff       	callq  401520 <free@plt>
	}

	// Reset fields
	memset(p_json_msg, 0, sizeof(struct gsi_json_msg));
  402134:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402138:	ba 28 00 00 00       	mov    $0x28,%edx
  40213d:	be 00 00 00 00       	mov    $0x0,%esi
  402142:	48 89 c7             	mov    %rax,%rdi
  402145:	e8 36 f5 ff ff       	callq  401680 <memset@plt>

	return GSI_JSON_SUCCESS;
  40214a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40214f:	48 83 c4 18          	add    $0x18,%rsp
  402153:	5b                   	pop    %rbx
  402154:	5d                   	pop    %rbp
  402155:	c3                   	retq   

0000000000402156 <gsi_is_send_all_json_msg>:
	 * Parameter:   [in] struct gsi_net_tcp* p_client - client that wants to send the messages
	 * Return :		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_is_send_all_json_msg(FILE* f_msg_file, struct gsi_net_tcp* p_client)
{
  402156:	55                   	push   %rbp
  402157:	48 89 e5             	mov    %rsp,%rbp
  40215a:	53                   	push   %rbx
  40215b:	48 83 ec 58          	sub    $0x58,%rsp
  40215f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  402163:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  402167:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40216e:	00 00 
  402170:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402174:	31 c0                	xor    %eax,%eax
	struct gsi_json_msg json_msg;
	int i_rc = GSI_JSON_SUCCESS;
  402176:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)

	// Check input validation
	if ((NULL == f_msg_file) || (NULL == p_client))
  40217d:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  402182:	74 07                	je     40218b <gsi_is_send_all_json_msg+0x35>
  402184:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  402189:	75 41                	jne    4021cc <gsi_is_send_all_json_msg+0x76>
	{
		LOG_ERROR("invalid arguments!");
  40218b:	b8 00 00 00 00       	mov    $0x0,%eax
  402190:	e8 a7 34 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402195:	48 89 c3             	mov    %rax,%rbx
  402198:	b8 00 00 00 00       	mov    $0x0,%eax
  40219d:	e8 15 32 00 00       	callq  4053b7 <gsi_get_saved_file>
  4021a2:	41 b8 91 00 00 00    	mov    $0x91,%r8d
  4021a8:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4021ad:	48 89 da             	mov    %rbx,%rdx
  4021b0:	be 40 6f 40 00       	mov    $0x406f40,%esi
  4021b5:	48 89 c7             	mov    %rax,%rdi
  4021b8:	b8 00 00 00 00       	mov    $0x0,%eax
  4021bd:	e8 5e 32 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  4021c2:	b8 01 00 00 00       	mov    $0x1,%eax
  4021c7:	e9 9a 00 00 00       	jmpq   402266 <gsi_is_send_all_json_msg+0x110>
	}

	// Reset fields
	memset(&json_msg, 0, sizeof(json_msg));
  4021cc:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  4021d0:	ba 28 00 00 00       	mov    $0x28,%edx
  4021d5:	be 00 00 00 00       	mov    $0x0,%esi
  4021da:	48 89 c7             	mov    %rax,%rdi
  4021dd:	e8 9e f4 ff ff       	callq  401680 <memset@plt>

	// Main loop to send all messages
	while (1)
	{
		// Get next message from file
		i_rc = gsi_is_get_next_msg(f_msg_file, &json_msg);
  4021e2:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  4021e6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4021ea:	48 89 d6             	mov    %rdx,%rsi
  4021ed:	48 89 c7             	mov    %rax,%rdi
  4021f0:	e8 bc 05 00 00       	callq  4027b1 <gsi_is_get_next_msg>
  4021f5:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (GSI_JSON_READ_ERROR == i_rc)
  4021f8:	83 7d bc 04          	cmpl   $0x4,-0x44(%rbp)
  4021fc:	75 09                	jne    402207 <gsi_is_send_all_json_msg+0xb1>
		{
			i_rc = GSI_JSON_SUCCESS;
  4021fe:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
			break;
  402205:	eb 45                	jmp    40224c <gsi_is_send_all_json_msg+0xf6>
		}
		else if ((GSI_JSON_ERROR == i_rc) || (GSI_JSON_INVALID_ERR == i_rc))
  402207:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%rbp)
  40220b:	74 3f                	je     40224c <gsi_is_send_all_json_msg+0xf6>
  40220d:	83 7d bc 01          	cmpl   $0x1,-0x44(%rbp)
  402211:	74 39                	je     40224c <gsi_is_send_all_json_msg+0xf6>
		{
			break;
		}

		if (GSI_COMMENT == json_msg.i_msg_type)
  402213:	8b 45 c0             	mov    -0x40(%rbp),%eax
  402216:	83 f8 03             	cmp    $0x3,%eax
  402219:	74 2e                	je     402249 <gsi_is_send_all_json_msg+0xf3>
		{
			continue;
		}

		// Send message
		if (GSI_JSON_SUCCESS != gsi_is_send_json_msg(p_client, &json_msg))
  40221b:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  40221f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  402223:	48 89 d6             	mov    %rdx,%rsi
  402226:	48 89 c7             	mov    %rax,%rdi
  402229:	e8 53 00 00 00       	callq  402281 <gsi_is_send_json_msg>
  40222e:	85 c0                	test   %eax,%eax
  402230:	74 09                	je     40223b <gsi_is_send_all_json_msg+0xe5>
		{
			i_rc = GSI_JSON_ERROR;
  402232:	c7 45 bc ff ff ff ff 	movl   $0xffffffff,-0x44(%rbp)
			break;
  402239:	eb 11                	jmp    40224c <gsi_is_send_all_json_msg+0xf6>
		}

		// Reset the json-msg object
		gsi_build_parse_reset_object(&json_msg);
  40223b:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  40223f:	48 89 c7             	mov    %rax,%rdi
  402242:	e8 61 fe ff ff       	callq  4020a8 <gsi_build_parse_reset_object>
  402247:	eb 99                	jmp    4021e2 <gsi_is_send_all_json_msg+0x8c>
			break;
		}

		if (GSI_COMMENT == json_msg.i_msg_type)
		{
			continue;
  402249:	90                   	nop
			break;
		}

		// Reset the json-msg object
		gsi_build_parse_reset_object(&json_msg);
	}
  40224a:	eb 96                	jmp    4021e2 <gsi_is_send_all_json_msg+0x8c>

	// Reset the json-msg object
	if (GSI_JSON_SUCCESS != gsi_build_parse_reset_object(&json_msg))
  40224c:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  402250:	48 89 c7             	mov    %rax,%rdi
  402253:	e8 50 fe ff ff       	callq  4020a8 <gsi_build_parse_reset_object>
  402258:	85 c0                	test   %eax,%eax
  40225a:	74 07                	je     402263 <gsi_is_send_all_json_msg+0x10d>
	{
		return GSI_JSON_ERROR;
  40225c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402261:	eb 03                	jmp    402266 <gsi_is_send_all_json_msg+0x110>
	}

	return i_rc;
  402263:	8b 45 bc             	mov    -0x44(%rbp),%eax
}
  402266:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  40226a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  402271:	00 00 
  402273:	74 05                	je     40227a <gsi_is_send_all_json_msg+0x124>
  402275:	e8 86 f3 ff ff       	callq  401600 <__stack_chk_fail@plt>
  40227a:	48 83 c4 58          	add    $0x58,%rsp
  40227e:	5b                   	pop    %rbx
  40227f:	5d                   	pop    %rbp
  402280:	c3                   	retq   

0000000000402281 <gsi_is_send_json_msg>:
	 * Parameter:   [in] struct gsi_json_msg* p_json_msg - pointer to message structure
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_is_send_json_msg(struct gsi_net_tcp* p_client, struct gsi_json_msg* p_json_msg)
{
  402281:	55                   	push   %rbp
  402282:	48 89 e5             	mov    %rsp,%rbp
  402285:	41 54                	push   %r12
  402287:	53                   	push   %rbx
  402288:	48 83 ec 40          	sub    $0x40,%rsp
  40228c:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  402290:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  402294:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40229b:	00 00 
  40229d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  4022a1:	31 c0                	xor    %eax,%eax
	struct gsi_cs_tcp_message msg;
	struct json_object *p_json = NULL;
  4022a3:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  4022aa:	00 
	char* s_full_object = NULL;
  4022ab:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  4022b2:	00 

	// Check input validation
	if ((NULL == p_client) || (NULL == p_json_msg))
  4022b3:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  4022b8:	74 07                	je     4022c1 <gsi_is_send_json_msg+0x40>
  4022ba:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  4022bf:	75 41                	jne    402302 <gsi_is_send_json_msg+0x81>
	{
		LOG_ERROR("invalid arguments!");
  4022c1:	b8 00 00 00 00       	mov    $0x0,%eax
  4022c6:	e8 71 33 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4022cb:	48 89 c3             	mov    %rax,%rbx
  4022ce:	b8 00 00 00 00       	mov    $0x0,%eax
  4022d3:	e8 df 30 00 00       	callq  4053b7 <gsi_get_saved_file>
  4022d8:	41 b8 d1 00 00 00    	mov    $0xd1,%r8d
  4022de:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4022e3:	48 89 da             	mov    %rbx,%rdx
  4022e6:	be 40 6f 40 00       	mov    $0x406f40,%esi
  4022eb:	48 89 c7             	mov    %rax,%rdi
  4022ee:	b8 00 00 00 00       	mov    $0x0,%eax
  4022f3:	e8 28 31 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  4022f8:	b8 01 00 00 00       	mov    $0x1,%eax
  4022fd:	e9 41 02 00 00       	jmpq   402543 <gsi_is_send_json_msg+0x2c2>
	}

	// Reset message fields
	memset(&msg, 0, sizeof(msg));
  402302:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  402306:	ba 18 00 00 00       	mov    $0x18,%edx
  40230b:	be 00 00 00 00       	mov    $0x0,%esi
  402310:	48 89 c7             	mov    %rax,%rdi
  402313:	e8 68 f3 ff ff       	callq  401680 <memset@plt>

	// Set fields
	msg.e_type_msg = p_json_msg->i_msg_type;
  402318:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  40231c:	8b 00                	mov    (%rax),%eax
  40231e:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	msg.ui_port = p_client->ui_port;
  402321:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  402325:	8b 40 28             	mov    0x28(%rax),%eax
  402328:	89 45 d0             	mov    %eax,-0x30(%rbp)
	p_json_msg->ui_port = p_client->ui_port;
  40232b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40232f:	8b 50 28             	mov    0x28(%rax),%edx
  402332:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  402336:	89 50 08             	mov    %edx,0x8(%rax)

	// Create new json object
	p_json = json_object_new_object();
  402339:	e8 d2 f2 ff ff       	callq  401610 <json_object_new_object@plt>
  40233e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	if (NULL == p_json)
  402342:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  402347:	75 41                	jne    40238a <gsi_is_send_json_msg+0x109>
	{
		LOG_ERROR("allocate new json object failed");
  402349:	b8 00 00 00 00       	mov    $0x0,%eax
  40234e:	e8 e9 32 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402353:	48 89 c3             	mov    %rax,%rbx
  402356:	b8 00 00 00 00       	mov    $0x0,%eax
  40235b:	e8 57 30 00 00       	callq  4053b7 <gsi_get_saved_file>
  402360:	41 b8 e1 00 00 00    	mov    $0xe1,%r8d
  402366:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  40236b:	48 89 da             	mov    %rbx,%rdx
  40236e:	be 78 6f 40 00       	mov    $0x406f78,%esi
  402373:	48 89 c7             	mov    %rax,%rdi
  402376:	b8 00 00 00 00       	mov    $0x0,%eax
  40237b:	e8 a0 30 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  402380:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402385:	e9 b9 01 00 00       	jmpq   402543 <gsi_is_send_json_msg+0x2c2>
	}

	// Stringify the json-msg to string. using JSON-C library functions
	// create object for each member field in structure and its value
	s_full_object = gsi_build_parse_json_obj_to_string(p_json, p_json_msg);
  40238a:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  40238e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  402392:	48 89 d6             	mov    %rdx,%rsi
  402395:	48 89 c7             	mov    %rax,%rdi
  402398:	e8 d1 0d 00 00       	callq  40316e <gsi_build_parse_json_obj_to_string>
  40239d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	if (NULL == s_full_object)
  4023a1:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  4023a6:	75 4d                	jne    4023f5 <gsi_is_send_json_msg+0x174>
	{
		LOG_ERROR("json object to string failed");
  4023a8:	b8 00 00 00 00       	mov    $0x0,%eax
  4023ad:	e8 8a 32 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4023b2:	48 89 c3             	mov    %rax,%rbx
  4023b5:	b8 00 00 00 00       	mov    $0x0,%eax
  4023ba:	e8 f8 2f 00 00       	callq  4053b7 <gsi_get_saved_file>
  4023bf:	41 b8 ea 00 00 00    	mov    $0xea,%r8d
  4023c5:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4023ca:	48 89 da             	mov    %rbx,%rdx
  4023cd:	be c0 6f 40 00       	mov    $0x406fc0,%esi
  4023d2:	48 89 c7             	mov    %rax,%rdi
  4023d5:	b8 00 00 00 00       	mov    $0x0,%eax
  4023da:	e8 41 30 00 00       	callq  405420 <gsi_is_write_to_log>
		json_object_put(p_json);
  4023df:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  4023e3:	48 89 c7             	mov    %rax,%rdi
  4023e6:	e8 e5 f4 ff ff       	callq  4018d0 <json_object_put@plt>
		return GSI_JSON_ERROR;
  4023eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4023f0:	e9 4e 01 00 00       	jmpq   402543 <gsi_is_send_json_msg+0x2c2>
	}

	LOG_DEBUG("\nJSON:\n%s\n", s_full_object);
  4023f5:	b8 00 00 00 00       	mov    $0x0,%eax
  4023fa:	e8 3d 32 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4023ff:	48 89 c3             	mov    %rax,%rbx
  402402:	b8 00 00 00 00       	mov    $0x0,%eax
  402407:	e8 ab 2f 00 00       	callq  4053b7 <gsi_get_saved_file>
  40240c:	48 89 c7             	mov    %rax,%rdi
  40240f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402413:	49 89 c1             	mov    %rax,%r9
  402416:	41 b8 ef 00 00 00    	mov    $0xef,%r8d
  40241c:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402421:	48 89 da             	mov    %rbx,%rdx
  402424:	be 00 70 40 00       	mov    $0x407000,%esi
  402429:	b8 00 00 00 00       	mov    $0x0,%eax
  40242e:	e8 ed 2f 00 00       	callq  405420 <gsi_is_write_to_log>

	// Get full length
	msg.ui_len = strlen(s_full_object) + 1;
  402433:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402437:	48 89 c7             	mov    %rax,%rdi
  40243a:	e8 b1 f1 ff ff       	callq  4015f0 <strlen@plt>
  40243f:	83 c0 01             	add    $0x1,%eax
  402442:	89 45 d8             	mov    %eax,-0x28(%rbp)

	// Duplicate the new message
	msg.s_message = gsi_build_parse_strdup(s_full_object);
  402445:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402449:	48 89 c7             	mov    %rax,%rdi
  40244c:	e8 95 15 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  402451:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (NULL == msg.s_message)
  402455:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402459:	48 85 c0             	test   %rax,%rax
  40245c:	75 4d                	jne    4024ab <gsi_is_send_json_msg+0x22a>
	{
		LOG_ERROR("memory allocation for s_message failed");
  40245e:	b8 00 00 00 00       	mov    $0x0,%eax
  402463:	e8 d4 31 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402468:	48 89 c3             	mov    %rax,%rbx
  40246b:	b8 00 00 00 00       	mov    $0x0,%eax
  402470:	e8 42 2f 00 00       	callq  4053b7 <gsi_get_saved_file>
  402475:	41 b8 f8 00 00 00    	mov    $0xf8,%r8d
  40247b:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402480:	48 89 da             	mov    %rbx,%rdx
  402483:	be 30 70 40 00       	mov    $0x407030,%esi
  402488:	48 89 c7             	mov    %rax,%rdi
  40248b:	b8 00 00 00 00       	mov    $0x0,%eax
  402490:	e8 8b 2f 00 00       	callq  405420 <gsi_is_write_to_log>
		json_object_put(p_json);
  402495:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  402499:	48 89 c7             	mov    %rax,%rdi
  40249c:	e8 2f f4 ff ff       	callq  4018d0 <json_object_put@plt>
		return GSI_JSON_ERROR;
  4024a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4024a6:	e9 98 00 00 00       	jmpq   402543 <gsi_is_send_json_msg+0x2c2>
	}

	// Free the json object
	json_object_put(p_json);
  4024ab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  4024af:	48 89 c7             	mov    %rax,%rdi
  4024b2:	e8 19 f4 ff ff       	callq  4018d0 <json_object_put@plt>

	// Send message to server
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_send(p_client, (char *)&msg))
  4024b7:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  4024bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4024bf:	48 89 d6             	mov    %rdx,%rsi
  4024c2:	48 89 c7             	mov    %rax,%rdi
  4024c5:	e8 33 19 00 00       	callq  403dfd <gsi_is_network_tcp_send>
  4024ca:	85 c0                	test   %eax,%eax
  4024cc:	74 5c                	je     40252a <gsi_is_send_json_msg+0x2a9>
	{
		LOG_ERROR("send message failed on port %d", p_client->ui_port);
  4024ce:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4024d2:	8b 58 28             	mov    0x28(%rax),%ebx
  4024d5:	b8 00 00 00 00       	mov    $0x0,%eax
  4024da:	e8 5d 31 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4024df:	49 89 c4             	mov    %rax,%r12
  4024e2:	b8 00 00 00 00       	mov    $0x0,%eax
  4024e7:	e8 cb 2e 00 00       	callq  4053b7 <gsi_get_saved_file>
  4024ec:	41 89 d9             	mov    %ebx,%r9d
  4024ef:	41 b8 03 01 00 00    	mov    $0x103,%r8d
  4024f5:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4024fa:	4c 89 e2             	mov    %r12,%rdx
  4024fd:	be 78 70 40 00       	mov    $0x407078,%esi
  402502:	48 89 c7             	mov    %rax,%rdi
  402505:	b8 00 00 00 00       	mov    $0x0,%eax
  40250a:	e8 11 2f 00 00       	callq  405420 <gsi_is_write_to_log>

		// Free the message memory
		free(msg.s_message);
  40250f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402513:	48 89 c7             	mov    %rax,%rdi
  402516:	e8 05 f0 ff ff       	callq  401520 <free@plt>
		msg.s_message = NULL;
  40251b:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  402522:	00 

		return GSI_NET_RC_ERROR;
  402523:	b8 01 00 00 00       	mov    $0x1,%eax
  402528:	eb 19                	jmp    402543 <gsi_is_send_json_msg+0x2c2>
	}

	// Free the message memory
	free(msg.s_message);
  40252a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40252e:	48 89 c7             	mov    %rax,%rdi
  402531:	e8 ea ef ff ff       	callq  401520 <free@plt>
	msg.s_message = NULL;
  402536:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  40253d:	00 

	return GSI_JSON_SUCCESS;
  40253e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402543:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  402547:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  40254e:	00 00 
  402550:	74 05                	je     402557 <gsi_is_send_json_msg+0x2d6>
  402552:	e8 a9 f0 ff ff       	callq  401600 <__stack_chk_fail@plt>
  402557:	48 83 c4 40          	add    $0x40,%rsp
  40255b:	5b                   	pop    %rbx
  40255c:	41 5c                	pop    %r12
  40255e:	5d                   	pop    %rbp
  40255f:	c3                   	retq   

0000000000402560 <gsi_is_recv_json_msg>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to message structure
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
enum gsi_is_json_rc gsi_is_recv_json_msg(struct gsi_net_tcp* p_server, struct gsi_json_msg* p_json_msg)
{
  402560:	55                   	push   %rbp
  402561:	48 89 e5             	mov    %rsp,%rbp
  402564:	41 54                	push   %r12
  402566:	53                   	push   %rbx
  402567:	48 83 ec 40          	sub    $0x40,%rsp
  40256b:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  40256f:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  402573:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40257a:	00 00 
  40257c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402580:	31 c0                	xor    %eax,%eax
	struct gsi_cs_tcp_message msg;
	struct json_object *p_json = NULL;
  402582:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  402589:	00 

	// Check input validation
	if ((NULL == p_server) || (NULL == p_json_msg))
  40258a:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  40258f:	74 07                	je     402598 <gsi_is_recv_json_msg+0x38>
  402591:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  402596:	75 41                	jne    4025d9 <gsi_is_recv_json_msg+0x79>
	{
		LOG_ERROR("invalid arguments!");
  402598:	b8 00 00 00 00       	mov    $0x0,%eax
  40259d:	e8 9a 30 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4025a2:	48 89 c3             	mov    %rax,%rbx
  4025a5:	b8 00 00 00 00       	mov    $0x0,%eax
  4025aa:	e8 08 2e 00 00       	callq  4053b7 <gsi_get_saved_file>
  4025af:	41 b8 23 01 00 00    	mov    $0x123,%r8d
  4025b5:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4025ba:	48 89 da             	mov    %rbx,%rdx
  4025bd:	be 40 6f 40 00       	mov    $0x406f40,%esi
  4025c2:	48 89 c7             	mov    %rax,%rdi
  4025c5:	b8 00 00 00 00       	mov    $0x0,%eax
  4025ca:	e8 51 2e 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  4025cf:	b8 01 00 00 00       	mov    $0x1,%eax
  4025d4:	e9 bb 01 00 00       	jmpq   402794 <gsi_is_recv_json_msg+0x234>
	}

	// Read new message
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_server_read(p_server, (char *)&msg))
  4025d9:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  4025dd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4025e1:	48 89 d6             	mov    %rdx,%rsi
  4025e4:	48 89 c7             	mov    %rax,%rdi
  4025e7:	e8 dc 21 00 00       	callq  4047c8 <gsi_is_network_tcp_server_read>
  4025ec:	85 c0                	test   %eax,%eax
  4025ee:	74 68                	je     402658 <gsi_is_recv_json_msg+0xf8>
	{
		LOG_ERROR("server read on port %d failed", p_server->ui_port);
  4025f0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4025f4:	8b 58 28             	mov    0x28(%rax),%ebx
  4025f7:	b8 00 00 00 00       	mov    $0x0,%eax
  4025fc:	e8 3b 30 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402601:	49 89 c4             	mov    %rax,%r12
  402604:	b8 00 00 00 00       	mov    $0x0,%eax
  402609:	e8 a9 2d 00 00       	callq  4053b7 <gsi_get_saved_file>
  40260e:	41 89 d9             	mov    %ebx,%r9d
  402611:	41 b8 2a 01 00 00    	mov    $0x12a,%r8d
  402617:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  40261c:	4c 89 e2             	mov    %r12,%rdx
  40261f:	be b8 70 40 00       	mov    $0x4070b8,%esi
  402624:	48 89 c7             	mov    %rax,%rdi
  402627:	b8 00 00 00 00       	mov    $0x0,%eax
  40262c:	e8 ef 2d 00 00       	callq  405420 <gsi_is_write_to_log>

		// Check if need to free s_message
		if (NULL != msg.s_message)
  402631:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402635:	48 85 c0             	test   %rax,%rax
  402638:	74 14                	je     40264e <gsi_is_recv_json_msg+0xee>
		{
			free(msg.s_message);
  40263a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40263e:	48 89 c7             	mov    %rax,%rdi
  402641:	e8 da ee ff ff       	callq  401520 <free@plt>
			msg.s_message = NULL;
  402646:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  40264d:	00 
		}

		return GSI_JSON_ERROR;
  40264e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402653:	e9 3c 01 00 00       	jmpq   402794 <gsi_is_recv_json_msg+0x234>
	}

	LOG_DEBUG("\nGot JSON:\n%s\n", msg.s_message);
  402658:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  40265c:	b8 00 00 00 00       	mov    $0x0,%eax
  402661:	e8 d6 2f 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402666:	49 89 c4             	mov    %rax,%r12
  402669:	b8 00 00 00 00       	mov    $0x0,%eax
  40266e:	e8 44 2d 00 00       	callq  4053b7 <gsi_get_saved_file>
  402673:	49 89 d9             	mov    %rbx,%r9
  402676:	41 b8 36 01 00 00    	mov    $0x136,%r8d
  40267c:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402681:	4c 89 e2             	mov    %r12,%rdx
  402684:	be f8 70 40 00       	mov    $0x4070f8,%esi
  402689:	48 89 c7             	mov    %rax,%rdi
  40268c:	b8 00 00 00 00       	mov    $0x0,%eax
  402691:	e8 8a 2d 00 00       	callq  405420 <gsi_is_write_to_log>

	// Convert string to json object using JSON-C library functions
	if (GSI_JSON_SUCCESS != gsi_build_parse_string_to_json_object(msg.s_message, &p_json))
  402696:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40269a:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  40269e:	48 89 d6             	mov    %rdx,%rsi
  4026a1:	48 89 c7             	mov    %rax,%rdi
  4026a4:	e8 29 0d 00 00       	callq  4033d2 <gsi_build_parse_string_to_json_object>
  4026a9:	85 c0                	test   %eax,%eax
  4026ab:	74 61                	je     40270e <gsi_is_recv_json_msg+0x1ae>
	{
		LOG_ERROR("convert string to json object failed");
  4026ad:	b8 00 00 00 00       	mov    $0x0,%eax
  4026b2:	e8 85 2f 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4026b7:	48 89 c3             	mov    %rax,%rbx
  4026ba:	b8 00 00 00 00       	mov    $0x0,%eax
  4026bf:	e8 f3 2c 00 00       	callq  4053b7 <gsi_get_saved_file>
  4026c4:	41 b8 3b 01 00 00    	mov    $0x13b,%r8d
  4026ca:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4026cf:	48 89 da             	mov    %rbx,%rdx
  4026d2:	be 28 71 40 00       	mov    $0x407128,%esi
  4026d7:	48 89 c7             	mov    %rax,%rdi
  4026da:	b8 00 00 00 00       	mov    $0x0,%eax
  4026df:	e8 3c 2d 00 00       	callq  405420 <gsi_is_write_to_log>

		free(msg.s_message);
  4026e4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4026e8:	48 89 c7             	mov    %rax,%rdi
  4026eb:	e8 30 ee ff ff       	callq  401520 <free@plt>
		msg.s_message = NULL;
  4026f0:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  4026f7:	00 

		json_object_put(p_json);
  4026f8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4026fc:	48 89 c7             	mov    %rax,%rdi
  4026ff:	e8 cc f1 ff ff       	callq  4018d0 <json_object_put@plt>

		return GSI_JSON_ERROR;
  402704:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402709:	e9 86 00 00 00       	jmpq   402794 <gsi_is_recv_json_msg+0x234>
	}

	// Free s_message, finish his job
	free(msg.s_message);
  40270e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402712:	48 89 c7             	mov    %rax,%rdi
  402715:	e8 06 ee ff ff       	callq  401520 <free@plt>
	msg.s_message = NULL;
  40271a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  402721:	00 

	// Convert json object to json-msg object using JSON-C library functions
	if (GSI_JSON_SUCCESS != gsi_build_parse_json_object_to_json_msg(p_json, p_json_msg))
  402722:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402726:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  40272a:	48 89 d6             	mov    %rdx,%rsi
  40272d:	48 89 c7             	mov    %rax,%rdi
  402730:	e8 5f 0d 00 00       	callq  403494 <gsi_build_parse_json_object_to_json_msg>
  402735:	85 c0                	test   %eax,%eax
  402737:	74 4a                	je     402783 <gsi_is_recv_json_msg+0x223>
	{
		LOG_ERROR("convert json object to json-msg failed");
  402739:	b8 00 00 00 00       	mov    $0x0,%eax
  40273e:	e8 f9 2e 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402743:	48 89 c3             	mov    %rax,%rbx
  402746:	b8 00 00 00 00       	mov    $0x0,%eax
  40274b:	e8 67 2c 00 00       	callq  4053b7 <gsi_get_saved_file>
  402750:	41 b8 4c 01 00 00    	mov    $0x14c,%r8d
  402756:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  40275b:	48 89 da             	mov    %rbx,%rdx
  40275e:	be 70 71 40 00       	mov    $0x407170,%esi
  402763:	48 89 c7             	mov    %rax,%rdi
  402766:	b8 00 00 00 00       	mov    $0x0,%eax
  40276b:	e8 b0 2c 00 00       	callq  405420 <gsi_is_write_to_log>

		json_object_put(p_json);
  402770:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402774:	48 89 c7             	mov    %rax,%rdi
  402777:	e8 54 f1 ff ff       	callq  4018d0 <json_object_put@plt>

		return GSI_JSON_ERROR;
  40277c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402781:	eb 11                	jmp    402794 <gsi_is_recv_json_msg+0x234>
	}

	// Free the json object
	json_object_put(p_json);
  402783:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402787:	48 89 c7             	mov    %rax,%rdi
  40278a:	e8 41 f1 ff ff       	callq  4018d0 <json_object_put@plt>

	return GSI_JSON_SUCCESS;
  40278f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402794:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  402798:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  40279f:	00 00 
  4027a1:	74 05                	je     4027a8 <gsi_is_recv_json_msg+0x248>
  4027a3:	e8 58 ee ff ff       	callq  401600 <__stack_chk_fail@plt>
  4027a8:	48 83 c4 40          	add    $0x40,%rsp
  4027ac:	5b                   	pop    %rbx
  4027ad:	41 5c                	pop    %r12
  4027af:	5d                   	pop    %rbp
  4027b0:	c3                   	retq   

00000000004027b1 <gsi_is_get_next_msg>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to message structure
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR *OR* GSI_JSON_READ_ERROR
#############################################################################*/
enum gsi_is_json_rc gsi_is_get_next_msg(FILE* f_msg_file, struct gsi_json_msg* p_json_msg)
{
  4027b1:	55                   	push   %rbp
  4027b2:	48 89 e5             	mov    %rsp,%rbp
  4027b5:	53                   	push   %rbx
  4027b6:	48 81 ec 28 04 00 00 	sub    $0x428,%rsp
  4027bd:	48 89 bd d8 fb ff ff 	mov    %rdi,-0x428(%rbp)
  4027c4:	48 89 b5 d0 fb ff ff 	mov    %rsi,-0x430(%rbp)
  4027cb:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  4027d2:	00 00 
  4027d4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  4027d8:	31 c0                	xor    %eax,%eax
	char s_msg_buffer[GSI_IS_BUFFER_SIZE];

	// Check input validation
	if ((NULL == f_msg_file) || (NULL == p_json_msg))
  4027da:	48 83 bd d8 fb ff ff 	cmpq   $0x0,-0x428(%rbp)
  4027e1:	00 
  4027e2:	74 0a                	je     4027ee <gsi_is_get_next_msg+0x3d>
  4027e4:	48 83 bd d0 fb ff ff 	cmpq   $0x0,-0x430(%rbp)
  4027eb:	00 
  4027ec:	75 41                	jne    40282f <gsi_is_get_next_msg+0x7e>
	{
		LOG_ERROR("invalid arguments!");
  4027ee:	b8 00 00 00 00       	mov    $0x0,%eax
  4027f3:	e8 44 2e 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4027f8:	48 89 c3             	mov    %rax,%rbx
  4027fb:	b8 00 00 00 00       	mov    $0x0,%eax
  402800:	e8 b2 2b 00 00       	callq  4053b7 <gsi_get_saved_file>
  402805:	41 b8 68 01 00 00    	mov    $0x168,%r8d
  40280b:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402810:	48 89 da             	mov    %rbx,%rdx
  402813:	be 40 6f 40 00       	mov    $0x406f40,%esi
  402818:	48 89 c7             	mov    %rax,%rdi
  40281b:	b8 00 00 00 00       	mov    $0x0,%eax
  402820:	e8 fb 2b 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  402825:	b8 01 00 00 00       	mov    $0x1,%eax
  40282a:	e9 d7 00 00 00       	jmpq   402906 <gsi_is_get_next_msg+0x155>
	}

	// Reset buffer
	memset(s_msg_buffer, 0, sizeof(s_msg_buffer));
  40282f:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  402836:	ba 00 04 00 00       	mov    $0x400,%edx
  40283b:	be 00 00 00 00       	mov    $0x0,%esi
  402840:	48 89 c7             	mov    %rax,%rdi
  402843:	e8 38 ee ff ff       	callq  401680 <memset@plt>

	// Get next message from Messages file
	if (NULL == fgets(s_msg_buffer, sizeof(s_msg_buffer), f_msg_file))
  402848:	48 8b 95 d8 fb ff ff 	mov    -0x428(%rbp),%rdx
  40284f:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  402856:	be 00 04 00 00       	mov    $0x400,%esi
  40285b:	48 89 c7             	mov    %rax,%rdi
  40285e:	e8 6d ee ff ff       	callq  4016d0 <fgets@plt>
  402863:	48 85 c0             	test   %rax,%rax
  402866:	75 3e                	jne    4028a6 <gsi_is_get_next_msg+0xf5>
	{
		LOG_ERROR("couldn't read from messages file");
  402868:	b8 00 00 00 00       	mov    $0x0,%eax
  40286d:	e8 ca 2d 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402872:	48 89 c3             	mov    %rax,%rbx
  402875:	b8 00 00 00 00       	mov    $0x0,%eax
  40287a:	e8 38 2b 00 00       	callq  4053b7 <gsi_get_saved_file>
  40287f:	41 b8 72 01 00 00    	mov    $0x172,%r8d
  402885:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  40288a:	48 89 da             	mov    %rbx,%rdx
  40288d:	be b8 71 40 00       	mov    $0x4071b8,%esi
  402892:	48 89 c7             	mov    %rax,%rdi
  402895:	b8 00 00 00 00       	mov    $0x0,%eax
  40289a:	e8 81 2b 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_READ_ERROR;
  40289f:	b8 04 00 00 00       	mov    $0x4,%eax
  4028a4:	eb 60                	jmp    402906 <gsi_is_get_next_msg+0x155>
	}

	// Build message according to the current line that read from file
	if (0 != gsi_build_parse_build_msg(s_msg_buffer, p_json_msg))
  4028a6:	48 8b 95 d0 fb ff ff 	mov    -0x430(%rbp),%rdx
  4028ad:	48 8d 85 e0 fb ff ff 	lea    -0x420(%rbp),%rax
  4028b4:	48 89 d6             	mov    %rdx,%rsi
  4028b7:	48 89 c7             	mov    %rax,%rdi
  4028ba:	e8 65 00 00 00       	callq  402924 <gsi_build_parse_build_msg>
  4028bf:	85 c0                	test   %eax,%eax
  4028c1:	74 3e                	je     402901 <gsi_is_get_next_msg+0x150>
	{
		LOG_ERROR("couldn't build message");
  4028c3:	b8 00 00 00 00       	mov    $0x0,%eax
  4028c8:	e8 6f 2d 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4028cd:	48 89 c3             	mov    %rax,%rbx
  4028d0:	b8 00 00 00 00       	mov    $0x0,%eax
  4028d5:	e8 dd 2a 00 00       	callq  4053b7 <gsi_get_saved_file>
  4028da:	41 b8 79 01 00 00    	mov    $0x179,%r8d
  4028e0:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4028e5:	48 89 da             	mov    %rbx,%rdx
  4028e8:	be 00 72 40 00       	mov    $0x407200,%esi
  4028ed:	48 89 c7             	mov    %rax,%rdi
  4028f0:	b8 00 00 00 00       	mov    $0x0,%eax
  4028f5:	e8 26 2b 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  4028fa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4028ff:	eb 05                	jmp    402906 <gsi_is_get_next_msg+0x155>
	}

	return GSI_JSON_SUCCESS;
  402901:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402906:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  40290a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  402911:	00 00 
  402913:	74 05                	je     40291a <gsi_is_get_next_msg+0x169>
  402915:	e8 e6 ec ff ff       	callq  401600 <__stack_chk_fail@plt>
  40291a:	48 81 c4 28 04 00 00 	add    $0x428,%rsp
  402921:	5b                   	pop    %rbx
  402922:	5d                   	pop    %rbp
  402923:	c3                   	retq   

0000000000402924 <gsi_build_parse_build_msg>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to json-msg object
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR *OR* GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_build_msg(char* s_line, struct gsi_json_msg* p_json_msg)
{
  402924:	55                   	push   %rbp
  402925:	48 89 e5             	mov    %rsp,%rbp
  402928:	53                   	push   %rbx
  402929:	48 83 ec 18          	sub    $0x18,%rsp
  40292d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402931:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((NULL == s_line) || (NULL == p_json_msg))
  402935:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402939:	48 85 c0             	test   %rax,%rax
  40293c:	74 07                	je     402945 <gsi_build_parse_build_msg+0x21>
  40293e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  402943:	75 41                	jne    402986 <gsi_build_parse_build_msg+0x62>
	{
		LOG_ERROR("invalid arguments!");
  402945:	b8 00 00 00 00       	mov    $0x0,%eax
  40294a:	e8 ed 2c 00 00       	callq  40563c <gsi_is_gen_timestamp>
  40294f:	48 89 c3             	mov    %rax,%rbx
  402952:	b8 00 00 00 00       	mov    $0x0,%eax
  402957:	e8 5b 2a 00 00       	callq  4053b7 <gsi_get_saved_file>
  40295c:	41 b8 90 01 00 00    	mov    $0x190,%r8d
  402962:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402967:	48 89 da             	mov    %rbx,%rdx
  40296a:	be 40 6f 40 00       	mov    $0x406f40,%esi
  40296f:	48 89 c7             	mov    %rax,%rdi
  402972:	b8 00 00 00 00       	mov    $0x0,%eax
  402977:	e8 a4 2a 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  40297c:	b8 01 00 00 00       	mov    $0x1,%eax
  402981:	e9 28 01 00 00       	jmpq   402aae <gsi_build_parse_build_msg+0x18a>
	}

	// Set message type
	p_json_msg->i_msg_type = gsi_build_parse_get_msg_type(&s_line);
  402986:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  40298a:	48 89 c7             	mov    %rax,%rdi
  40298d:	e8 23 01 00 00       	callq  402ab5 <gsi_build_parse_get_msg_type>
  402992:	89 c2                	mov    %eax,%edx
  402994:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402998:	89 10                	mov    %edx,(%rax)
	if (GSI_JSON_ERROR == p_json_msg->i_msg_type)
  40299a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40299e:	8b 00                	mov    (%rax),%eax
  4029a0:	83 f8 ff             	cmp    $0xffffffff,%eax
  4029a3:	75 41                	jne    4029e6 <gsi_build_parse_build_msg+0xc2>
	{
		LOG_ERROR("get message type failed");
  4029a5:	b8 00 00 00 00       	mov    $0x0,%eax
  4029aa:	e8 8d 2c 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4029af:	48 89 c3             	mov    %rax,%rbx
  4029b2:	b8 00 00 00 00       	mov    $0x0,%eax
  4029b7:	e8 fb 29 00 00       	callq  4053b7 <gsi_get_saved_file>
  4029bc:	41 b8 98 01 00 00    	mov    $0x198,%r8d
  4029c2:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4029c7:	48 89 da             	mov    %rbx,%rdx
  4029ca:	be 38 72 40 00       	mov    $0x407238,%esi
  4029cf:	48 89 c7             	mov    %rax,%rdi
  4029d2:	b8 00 00 00 00       	mov    $0x0,%eax
  4029d7:	e8 44 2a 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  4029dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4029e1:	e9 c8 00 00 00       	jmpq   402aae <gsi_build_parse_build_msg+0x18a>
	}

	// Only if Regular message sent
	if (GSI_REGULAR_MSG == p_json_msg->i_msg_type)
  4029e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4029ea:	8b 00                	mov    (%rax),%eax
  4029ec:	83 f8 01             	cmp    $0x1,%eax
  4029ef:	0f 85 b4 00 00 00    	jne    402aa9 <gsi_build_parse_build_msg+0x185>
	{
		// Set operation code
		p_json_msg->i_op_code = gsi_build_parse_get_msg_op_code(&s_line);
  4029f5:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  4029f9:	48 89 c7             	mov    %rax,%rdi
  4029fc:	e8 a3 01 00 00       	callq  402ba4 <gsi_build_parse_get_msg_op_code>
  402a01:	89 c2                	mov    %eax,%edx
  402a03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402a07:	89 50 04             	mov    %edx,0x4(%rax)
		if (GSI_JSON_ERROR == p_json_msg->i_op_code)
  402a0a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402a0e:	8b 40 04             	mov    0x4(%rax),%eax
  402a11:	83 f8 ff             	cmp    $0xffffffff,%eax
  402a14:	75 3e                	jne    402a54 <gsi_build_parse_build_msg+0x130>
		{
			LOG_ERROR("get message op-code failed");
  402a16:	b8 00 00 00 00       	mov    $0x0,%eax
  402a1b:	e8 1c 2c 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402a20:	48 89 c3             	mov    %rax,%rbx
  402a23:	b8 00 00 00 00       	mov    $0x0,%eax
  402a28:	e8 8a 29 00 00       	callq  4053b7 <gsi_get_saved_file>
  402a2d:	41 b8 a3 01 00 00    	mov    $0x1a3,%r8d
  402a33:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402a38:	48 89 da             	mov    %rbx,%rdx
  402a3b:	be 78 72 40 00       	mov    $0x407278,%esi
  402a40:	48 89 c7             	mov    %rax,%rdi
  402a43:	b8 00 00 00 00       	mov    $0x0,%eax
  402a48:	e8 d3 29 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_JSON_ERROR;
  402a4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402a52:	eb 5a                	jmp    402aae <gsi_build_parse_build_msg+0x18a>
		}

		// Set operation code arguments
		if (GSI_JSON_SUCCESS != gsi_build_parse_set_op_code_args(&s_line, p_json_msg))
  402a54:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402a58:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  402a5c:	48 89 d6             	mov    %rdx,%rsi
  402a5f:	48 89 c7             	mov    %rax,%rdi
  402a62:	e8 b2 04 00 00       	callq  402f19 <gsi_build_parse_set_op_code_args>
  402a67:	85 c0                	test   %eax,%eax
  402a69:	74 3e                	je     402aa9 <gsi_build_parse_build_msg+0x185>
		{
			LOG_ERROR("set op-code-arguments failed");
  402a6b:	b8 00 00 00 00       	mov    $0x0,%eax
  402a70:	e8 c7 2b 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402a75:	48 89 c3             	mov    %rax,%rbx
  402a78:	b8 00 00 00 00       	mov    $0x0,%eax
  402a7d:	e8 35 29 00 00       	callq  4053b7 <gsi_get_saved_file>
  402a82:	41 b8 aa 01 00 00    	mov    $0x1aa,%r8d
  402a88:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402a8d:	48 89 da             	mov    %rbx,%rdx
  402a90:	be b8 72 40 00       	mov    $0x4072b8,%esi
  402a95:	48 89 c7             	mov    %rax,%rdi
  402a98:	b8 00 00 00 00       	mov    $0x0,%eax
  402a9d:	e8 7e 29 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_JSON_ERROR;
  402aa2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402aa7:	eb 05                	jmp    402aae <gsi_build_parse_build_msg+0x18a>
		}
	}

	return GSI_JSON_SUCCESS;
  402aa9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402aae:	48 83 c4 18          	add    $0x18,%rsp
  402ab2:	5b                   	pop    %rbx
  402ab3:	5d                   	pop    %rbp
  402ab4:	c3                   	retq   

0000000000402ab5 <gsi_build_parse_get_msg_type>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - Number that describe the type of the message
	 * 				Failure - GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_get_msg_type(char** s_line)
{
  402ab5:	55                   	push   %rbp
  402ab6:	48 89 e5             	mov    %rsp,%rbp
  402ab9:	53                   	push   %rbx
  402aba:	48 83 ec 28          	sub    $0x28,%rsp
  402abe:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int i_type = 0;
  402ac2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	// Check input validation
	if (NULL == s_line)
  402ac9:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  402ace:	75 41                	jne    402b11 <gsi_build_parse_get_msg_type+0x5c>
	{
		LOG_ERROR("invalid argument!");
  402ad0:	b8 00 00 00 00       	mov    $0x0,%eax
  402ad5:	e8 62 2b 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402ada:	48 89 c3             	mov    %rax,%rbx
  402add:	b8 00 00 00 00       	mov    $0x0,%eax
  402ae2:	e8 d0 28 00 00       	callq  4053b7 <gsi_get_saved_file>
  402ae7:	41 b8 c0 01 00 00    	mov    $0x1c0,%r8d
  402aed:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402af2:	48 89 da             	mov    %rbx,%rdx
  402af5:	be 90 6e 40 00       	mov    $0x406e90,%esi
  402afa:	48 89 c7             	mov    %rax,%rdi
  402afd:	b8 00 00 00 00       	mov    $0x0,%eax
  402b02:	e8 19 29 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  402b07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402b0c:	e9 8c 00 00 00       	jmpq   402b9d <gsi_build_parse_get_msg_type+0xe8>
	}

	// Look at the first character in the current line: 'H'/'M'/'#'
	switch(**s_line)
  402b11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b15:	48 8b 00             	mov    (%rax),%rax
  402b18:	0f b6 00             	movzbl (%rax),%eax
  402b1b:	0f be c0             	movsbl %al,%eax
  402b1e:	83 f8 48             	cmp    $0x48,%eax
  402b21:	74 0c                	je     402b2f <gsi_build_parse_get_msg_type+0x7a>
  402b23:	83 f8 4d             	cmp    $0x4d,%eax
  402b26:	74 10                	je     402b38 <gsi_build_parse_get_msg_type+0x83>
  402b28:	83 f8 23             	cmp    $0x23,%eax
  402b2b:	74 14                	je     402b41 <gsi_build_parse_get_msg_type+0x8c>
  402b2d:	eb 1b                	jmp    402b4a <gsi_build_parse_get_msg_type+0x95>
	{
	case GSI_IS_HEART_BEAT:
		i_type = GSI_HEARTBEAT_MSG;
  402b2f:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%rbp)
		break;
  402b36:	eb 50                	jmp    402b88 <gsi_build_parse_get_msg_type+0xd3>
	case GSI_IS_MESSAGE:
		i_type = GSI_REGULAR_MSG;
  402b38:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
		break;
  402b3f:	eb 47                	jmp    402b88 <gsi_build_parse_get_msg_type+0xd3>
	case GSI_IS_COMMENT:
		i_type = GSI_COMMENT;
  402b41:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%rbp)
		break;
  402b48:	eb 3e                	jmp    402b88 <gsi_build_parse_get_msg_type+0xd3>
	default:
		LOG_ERROR("classified message failed");
  402b4a:	b8 00 00 00 00       	mov    $0x0,%eax
  402b4f:	e8 e8 2a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402b54:	48 89 c3             	mov    %rax,%rbx
  402b57:	b8 00 00 00 00       	mov    $0x0,%eax
  402b5c:	e8 56 28 00 00       	callq  4053b7 <gsi_get_saved_file>
  402b61:	41 b8 d1 01 00 00    	mov    $0x1d1,%r8d
  402b67:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402b6c:	48 89 da             	mov    %rbx,%rdx
  402b6f:	be f8 72 40 00       	mov    $0x4072f8,%esi
  402b74:	48 89 c7             	mov    %rax,%rdi
  402b77:	b8 00 00 00 00       	mov    $0x0,%eax
  402b7c:	e8 9f 28 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  402b81:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402b86:	eb 15                	jmp    402b9d <gsi_build_parse_get_msg_type+0xe8>
	}

	// Move forward the line pointer
	++(*s_line);
  402b88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b8c:	48 8b 00             	mov    (%rax),%rax
  402b8f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  402b93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b97:	48 89 10             	mov    %rdx,(%rax)

	return i_type;
  402b9a:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  402b9d:	48 83 c4 28          	add    $0x28,%rsp
  402ba1:	5b                   	pop    %rbx
  402ba2:	5d                   	pop    %rbp
  402ba3:	c3                   	retq   

0000000000402ba4 <gsi_build_parse_get_msg_op_code>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - Number that describe the operation-code
	 * 				Failure - GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_get_msg_op_code(char** s_line)
{
  402ba4:	55                   	push   %rbp
  402ba5:	48 89 e5             	mov    %rsp,%rbp
  402ba8:	53                   	push   %rbx
  402ba9:	48 83 ec 28          	sub    $0x28,%rsp
  402bad:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int i_op_code = 0;
  402bb1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	// Check input validation
	if (NULL == s_line)
  402bb8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  402bbd:	75 41                	jne    402c00 <gsi_build_parse_get_msg_op_code+0x5c>
	{
		LOG_ERROR("invalid argument!");
  402bbf:	b8 00 00 00 00       	mov    $0x0,%eax
  402bc4:	e8 73 2a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402bc9:	48 89 c3             	mov    %rax,%rbx
  402bcc:	b8 00 00 00 00       	mov    $0x0,%eax
  402bd1:	e8 e1 27 00 00       	callq  4053b7 <gsi_get_saved_file>
  402bd6:	41 b8 e9 01 00 00    	mov    $0x1e9,%r8d
  402bdc:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402be1:	48 89 da             	mov    %rbx,%rdx
  402be4:	be 90 6e 40 00       	mov    $0x406e90,%esi
  402be9:	48 89 c7             	mov    %rax,%rdi
  402bec:	b8 00 00 00 00       	mov    $0x0,%eax
  402bf1:	e8 2a 28 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  402bf6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402bfb:	e9 6f 01 00 00       	jmpq   402d6f <gsi_build_parse_get_msg_op_code+0x1cb>
	}

	// Skip the ':' at the beginning of the s_line
	++(*s_line);
  402c00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402c04:	48 8b 00             	mov    (%rax),%rax
  402c07:	48 8d 50 01          	lea    0x1(%rax),%rdx
  402c0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402c0f:	48 89 10             	mov    %rdx,(%rax)

	// Decode operation-code from s_line
	if (0 == strncmp(*s_line, GSI_IS_READ_FILE_BY_ID, strlen(GSI_IS_READ_FILE_BY_ID)))
  402c12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402c16:	48 8b 00             	mov    (%rax),%rax
  402c19:	ba 04 00 00 00       	mov    $0x4,%edx
  402c1e:	be 33 73 40 00       	mov    $0x407333,%esi
  402c23:	48 89 c7             	mov    %rax,%rdi
  402c26:	e8 25 e9 ff ff       	callq  401550 <strncmp@plt>
  402c2b:	85 c0                	test   %eax,%eax
  402c2d:	75 0c                	jne    402c3b <gsi_build_parse_get_msg_op_code+0x97>
	{
		i_op_code = GSI_READ_FILE_BY_ID;
  402c2f:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%rbp)
  402c36:	e9 05 01 00 00       	jmpq   402d40 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_READ_STR, strlen(GSI_IS_READ_STR)))
  402c3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402c3f:	48 8b 00             	mov    (%rax),%rax
  402c42:	ba 02 00 00 00       	mov    $0x2,%edx
  402c47:	be 38 73 40 00       	mov    $0x407338,%esi
  402c4c:	48 89 c7             	mov    %rax,%rdi
  402c4f:	e8 fc e8 ff ff       	callq  401550 <strncmp@plt>
  402c54:	85 c0                	test   %eax,%eax
  402c56:	75 0c                	jne    402c64 <gsi_build_parse_get_msg_op_code+0xc0>
	{
		i_op_code = GSI_READ_STR;
  402c58:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  402c5f:	e9 dc 00 00 00       	jmpq   402d40 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_WRITE_STR, strlen(GSI_IS_WRITE_STR)))
  402c64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402c68:	48 8b 00             	mov    (%rax),%rax
  402c6b:	ba 02 00 00 00       	mov    $0x2,%edx
  402c70:	be 3b 73 40 00       	mov    $0x40733b,%esi
  402c75:	48 89 c7             	mov    %rax,%rdi
  402c78:	e8 d3 e8 ff ff       	callq  401550 <strncmp@plt>
  402c7d:	85 c0                	test   %eax,%eax
  402c7f:	75 0c                	jne    402c8d <gsi_build_parse_get_msg_op_code+0xe9>
	{
		i_op_code = GSI_WRITE_STR;
  402c81:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  402c88:	e9 b3 00 00 00       	jmpq   402d40 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_READ_FILE, strlen(GSI_IS_READ_FILE)))
  402c8d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402c91:	48 8b 00             	mov    (%rax),%rax
  402c94:	ba 02 00 00 00       	mov    $0x2,%edx
  402c99:	be 3e 73 40 00       	mov    $0x40733e,%esi
  402c9e:	48 89 c7             	mov    %rax,%rdi
  402ca1:	e8 aa e8 ff ff       	callq  401550 <strncmp@plt>
  402ca6:	85 c0                	test   %eax,%eax
  402ca8:	75 0c                	jne    402cb6 <gsi_build_parse_get_msg_op_code+0x112>
	{
		i_op_code = GSI_READ_FILE;
  402caa:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%rbp)
  402cb1:	e9 8a 00 00 00       	jmpq   402d40 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_WRITE_FILE, strlen(GSI_IS_WRITE_FILE)))
  402cb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402cba:	48 8b 00             	mov    (%rax),%rax
  402cbd:	ba 02 00 00 00       	mov    $0x2,%edx
  402cc2:	be 41 73 40 00       	mov    $0x407341,%esi
  402cc7:	48 89 c7             	mov    %rax,%rdi
  402cca:	e8 81 e8 ff ff       	callq  401550 <strncmp@plt>
  402ccf:	85 c0                	test   %eax,%eax
  402cd1:	75 09                	jne    402cdc <gsi_build_parse_get_msg_op_code+0x138>
	{
		i_op_code = GSI_WRITE_FILE;
  402cd3:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%rbp)
  402cda:	eb 64                	jmp    402d40 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else if (0 == strncmp(*s_line, GSI_IS_PRINT_LOG, strlen(GSI_IS_PRINT_LOG)))
  402cdc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402ce0:	48 8b 00             	mov    (%rax),%rax
  402ce3:	ba 02 00 00 00       	mov    $0x2,%edx
  402ce8:	be 44 73 40 00       	mov    $0x407344,%esi
  402ced:	48 89 c7             	mov    %rax,%rdi
  402cf0:	e8 5b e8 ff ff       	callq  401550 <strncmp@plt>
  402cf5:	85 c0                	test   %eax,%eax
  402cf7:	75 09                	jne    402d02 <gsi_build_parse_get_msg_op_code+0x15e>
	{
		i_op_code = GSI_PRINT_LOG;
  402cf9:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%rbp)
  402d00:	eb 3e                	jmp    402d40 <gsi_build_parse_get_msg_op_code+0x19c>
	}
	else
	{
		LOG_ERROR("invalid op code");
  402d02:	b8 00 00 00 00       	mov    $0x0,%eax
  402d07:	e8 30 29 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402d0c:	48 89 c3             	mov    %rax,%rbx
  402d0f:	b8 00 00 00 00       	mov    $0x0,%eax
  402d14:	e8 9e 26 00 00       	callq  4053b7 <gsi_get_saved_file>
  402d19:	41 b8 0b 02 00 00    	mov    $0x20b,%r8d
  402d1f:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402d24:	48 89 da             	mov    %rbx,%rdx
  402d27:	be 48 73 40 00       	mov    $0x407348,%esi
  402d2c:	48 89 c7             	mov    %rax,%rdi
  402d2f:	b8 00 00 00 00       	mov    $0x0,%eax
  402d34:	e8 e7 26 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  402d39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402d3e:	eb 2f                	jmp    402d6f <gsi_build_parse_get_msg_op_code+0x1cb>
	}

	// Move forward the line pointer
	if (GSI_READ_FILE_BY_ID == i_op_code)
  402d40:	83 7d ec 05          	cmpl   $0x5,-0x14(%rbp)
  402d44:	75 14                	jne    402d5a <gsi_build_parse_get_msg_op_code+0x1b6>
	{
		*s_line += strlen(GSI_IS_READ_FILE_BY_ID);
  402d46:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402d4a:	48 8b 00             	mov    (%rax),%rax
  402d4d:	48 8d 50 04          	lea    0x4(%rax),%rdx
  402d51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402d55:	48 89 10             	mov    %rdx,(%rax)
  402d58:	eb 12                	jmp    402d6c <gsi_build_parse_get_msg_op_code+0x1c8>
	}
	else
	{
		*s_line += strlen(GSI_IS_PRINT_LOG);
  402d5a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402d5e:	48 8b 00             	mov    (%rax),%rax
  402d61:	48 8d 50 02          	lea    0x2(%rax),%rdx
  402d65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402d69:	48 89 10             	mov    %rdx,(%rax)
	}

	return i_op_code;
  402d6c:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  402d6f:	48 83 c4 28          	add    $0x28,%rsp
  402d73:	5b                   	pop    %rbx
  402d74:	5d                   	pop    %rbp
  402d75:	c3                   	retq   

0000000000402d76 <gsi_build_parse_get_msg_index>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - Number that describe the index
	 * 				Failure - GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_get_msg_index(char** s_line)
{
  402d76:	55                   	push   %rbp
  402d77:	48 89 e5             	mov    %rsp,%rbp
  402d7a:	53                   	push   %rbx
  402d7b:	48 83 ec 28          	sub    $0x28,%rsp
  402d7f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int i_index = 0;
  402d83:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	// Check input validation
	if (NULL == s_line)
  402d8a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  402d8f:	75 3e                	jne    402dcf <gsi_build_parse_get_msg_index+0x59>
	{
		LOG_ERROR("invalid argument!");
  402d91:	b8 00 00 00 00       	mov    $0x0,%eax
  402d96:	e8 a1 28 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402d9b:	48 89 c3             	mov    %rax,%rbx
  402d9e:	b8 00 00 00 00       	mov    $0x0,%eax
  402da3:	e8 0f 26 00 00       	callq  4053b7 <gsi_get_saved_file>
  402da8:	41 b8 2a 02 00 00    	mov    $0x22a,%r8d
  402dae:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402db3:	48 89 da             	mov    %rbx,%rdx
  402db6:	be 90 6e 40 00       	mov    $0x406e90,%esi
  402dbb:	48 89 c7             	mov    %rax,%rdi
  402dbe:	b8 00 00 00 00       	mov    $0x0,%eax
  402dc3:	e8 58 26 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  402dc8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402dcd:	eb 33                	jmp    402e02 <gsi_build_parse_get_msg_index+0x8c>
	}

	// Skip the ':' at the beginning of the s_line
	++(*s_line);
  402dcf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402dd3:	48 8b 00             	mov    (%rax),%rax
  402dd6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  402dda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402dde:	48 89 10             	mov    %rdx,(%rax)

	// Extract the index from the s_line, stops at ' '
	i_index = strtol(*s_line, s_line, 10);
  402de1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402de5:	48 8b 00             	mov    (%rax),%rax
  402de8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  402dec:	ba 0a 00 00 00       	mov    $0xa,%edx
  402df1:	48 89 ce             	mov    %rcx,%rsi
  402df4:	48 89 c7             	mov    %rax,%rdi
  402df7:	e8 44 e9 ff ff       	callq  401740 <strtol@plt>
  402dfc:	89 45 ec             	mov    %eax,-0x14(%rbp)

	return i_index;
  402dff:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  402e02:	48 83 c4 28          	add    $0x28,%rsp
  402e06:	5b                   	pop    %rbx
  402e07:	5d                   	pop    %rbp
  402e08:	c3                   	retq   

0000000000402e09 <gsi_build_parse_get_msg_len>:
	 * Parameter:   [in] char* s_msg - message
	 * Return:		Success - message's length
	 * 				Failure - GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_get_msg_len(char* s_msg)
{
  402e09:	55                   	push   %rbp
  402e0a:	48 89 e5             	mov    %rsp,%rbp
  402e0d:	53                   	push   %rbx
  402e0e:	48 83 ec 18          	sub    $0x18,%rsp
  402e12:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == s_msg)
  402e16:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  402e1b:	75 3e                	jne    402e5b <gsi_build_parse_get_msg_len+0x52>
	{
		LOG_ERROR("invalid argument!");
  402e1d:	b8 00 00 00 00       	mov    $0x0,%eax
  402e22:	e8 15 28 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402e27:	48 89 c3             	mov    %rax,%rbx
  402e2a:	b8 00 00 00 00       	mov    $0x0,%eax
  402e2f:	e8 83 25 00 00       	callq  4053b7 <gsi_get_saved_file>
  402e34:	41 b8 43 02 00 00    	mov    $0x243,%r8d
  402e3a:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402e3f:	48 89 da             	mov    %rbx,%rdx
  402e42:	be 90 6e 40 00       	mov    $0x406e90,%esi
  402e47:	48 89 c7             	mov    %rax,%rdi
  402e4a:	b8 00 00 00 00       	mov    $0x0,%eax
  402e4f:	e8 cc 25 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  402e54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402e59:	eb 0c                	jmp    402e67 <gsi_build_parse_get_msg_len+0x5e>
	}

	return strlen(s_msg);
  402e5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402e5f:	48 89 c7             	mov    %rax,%rdi
  402e62:	e8 89 e7 ff ff       	callq  4015f0 <strlen@plt>
}
  402e67:	48 83 c4 18          	add    $0x18,%rsp
  402e6b:	5b                   	pop    %rbx
  402e6c:	5d                   	pop    %rbp
  402e6d:	c3                   	retq   

0000000000402e6e <gsi_build_parse_get_msg_content>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - pointer to data
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_get_msg_content(char** s_line)
{
  402e6e:	55                   	push   %rbp
  402e6f:	48 89 e5             	mov    %rsp,%rbp
  402e72:	53                   	push   %rbx
  402e73:	48 83 ec 18          	sub    $0x18,%rsp
  402e77:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == s_line)
  402e7b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  402e80:	75 50                	jne    402ed2 <gsi_build_parse_get_msg_content+0x64>
	{
		LOG_ERROR("invalid argument!");
  402e82:	b8 00 00 00 00       	mov    $0x0,%eax
  402e87:	e8 b0 27 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402e8c:	48 89 c3             	mov    %rax,%rbx
  402e8f:	b8 00 00 00 00       	mov    $0x0,%eax
  402e94:	e8 1e 25 00 00       	callq  4053b7 <gsi_get_saved_file>
  402e99:	41 b8 56 02 00 00    	mov    $0x256,%r8d
  402e9f:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402ea4:	48 89 da             	mov    %rbx,%rdx
  402ea7:	be 90 6e 40 00       	mov    $0x406e90,%esi
  402eac:	48 89 c7             	mov    %rax,%rdi
  402eaf:	b8 00 00 00 00       	mov    $0x0,%eax
  402eb4:	e8 67 25 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  402eb9:	b8 00 00 00 00       	mov    $0x0,%eax
  402ebe:	eb 52                	jmp    402f12 <gsi_build_parse_get_msg_content+0xa4>
	}

	// Skip the white spaces at the beginning of the s_line
	while (('\0' != **s_line) && (isspace(**s_line)))
	{
		++(*s_line);
  402ec0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402ec4:	48 8b 00             	mov    (%rax),%rax
  402ec7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  402ecb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402ecf:	48 89 10             	mov    %rdx,(%rax)
		LOG_ERROR("invalid argument!");
		return NULL;
	}

	// Skip the white spaces at the beginning of the s_line
	while (('\0' != **s_line) && (isspace(**s_line)))
  402ed2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402ed6:	48 8b 00             	mov    (%rax),%rax
  402ed9:	0f b6 00             	movzbl (%rax),%eax
  402edc:	84 c0                	test   %al,%al
  402ede:	74 2b                	je     402f0b <gsi_build_parse_get_msg_content+0x9d>
  402ee0:	e8 0b ea ff ff       	callq  4018f0 <__ctype_b_loc@plt>
  402ee5:	48 8b 10             	mov    (%rax),%rdx
  402ee8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402eec:	48 8b 00             	mov    (%rax),%rax
  402eef:	0f b6 00             	movzbl (%rax),%eax
  402ef2:	48 0f be c0          	movsbq %al,%rax
  402ef6:	48 01 c0             	add    %rax,%rax
  402ef9:	48 01 d0             	add    %rdx,%rax
  402efc:	0f b7 00             	movzwl (%rax),%eax
  402eff:	0f b7 c0             	movzwl %ax,%eax
  402f02:	25 00 20 00 00       	and    $0x2000,%eax
  402f07:	85 c0                	test   %eax,%eax
  402f09:	75 b5                	jne    402ec0 <gsi_build_parse_get_msg_content+0x52>
	{
		++(*s_line);
	}

	return *s_line;
  402f0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402f0f:	48 8b 00             	mov    (%rax),%rax
}
  402f12:	48 83 c4 18          	add    $0x18,%rsp
  402f16:	5b                   	pop    %rbx
  402f17:	5d                   	pop    %rbp
  402f18:	c3                   	retq   

0000000000402f19 <gsi_build_parse_set_op_code_args>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to json-msg object
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_ERROR *OR* GSI_JSON_INVALID_ERR
#############################################################################*/
static int gsi_build_parse_set_op_code_args(char** s_line, struct gsi_json_msg* p_json_msg)
{
  402f19:	55                   	push   %rbp
  402f1a:	48 89 e5             	mov    %rsp,%rbp
  402f1d:	53                   	push   %rbx
  402f1e:	48 83 ec 18          	sub    $0x18,%rsp
  402f22:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402f26:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((NULL == s_line) || (NULL == p_json_msg))
  402f2a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  402f2f:	74 07                	je     402f38 <gsi_build_parse_set_op_code_args+0x1f>
  402f31:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  402f36:	75 41                	jne    402f79 <gsi_build_parse_set_op_code_args+0x60>
	{
		LOG_ERROR("invalid arguments!");
  402f38:	b8 00 00 00 00       	mov    $0x0,%eax
  402f3d:	e8 fa 26 00 00       	callq  40563c <gsi_is_gen_timestamp>
  402f42:	48 89 c3             	mov    %rax,%rbx
  402f45:	b8 00 00 00 00       	mov    $0x0,%eax
  402f4a:	e8 68 24 00 00       	callq  4053b7 <gsi_get_saved_file>
  402f4f:	41 b8 71 02 00 00    	mov    $0x271,%r8d
  402f55:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  402f5a:	48 89 da             	mov    %rbx,%rdx
  402f5d:	be 40 6f 40 00       	mov    $0x406f40,%esi
  402f62:	48 89 c7             	mov    %rax,%rdi
  402f65:	b8 00 00 00 00       	mov    $0x0,%eax
  402f6a:	e8 b1 24 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  402f6f:	b8 01 00 00 00       	mov    $0x1,%eax
  402f74:	e9 ee 01 00 00       	jmpq   403167 <gsi_build_parse_set_op_code_args+0x24e>
	}

	switch(p_json_msg->i_op_code)
  402f79:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402f7d:	8b 40 04             	mov    0x4(%rax),%eax
  402f80:	83 f8 05             	cmp    $0x5,%eax
  402f83:	0f 87 94 01 00 00    	ja     40311d <gsi_build_parse_set_op_code_args+0x204>
  402f89:	89 c0                	mov    %eax,%eax
  402f8b:	48 8b 04 c5 b8 73 40 	mov    0x4073b8(,%rax,8),%rax
  402f92:	00 
  402f93:	ff e0                	jmpq   *%rax
	{
		case GSI_READ_STR:
			// Get index
			p_json_msg->i_index = gsi_build_parse_get_msg_index(s_line);
  402f95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402f99:	48 89 c7             	mov    %rax,%rdi
  402f9c:	e8 d5 fd ff ff       	callq  402d76 <gsi_build_parse_get_msg_index>
  402fa1:	89 c2                	mov    %eax,%edx
  402fa3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402fa7:	89 50 0c             	mov    %edx,0xc(%rax)
			break;
  402faa:	e9 b3 01 00 00       	jmpq   403162 <gsi_build_parse_set_op_code_args+0x249>

		case GSI_WRITE_STR:
			// Get index + length
			p_json_msg->i_index    = gsi_build_parse_get_msg_index(s_line);
  402faf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fb3:	48 89 c7             	mov    %rax,%rdi
  402fb6:	e8 bb fd ff ff       	callq  402d76 <gsi_build_parse_get_msg_index>
  402fbb:	89 c2                	mov    %eax,%edx
  402fbd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402fc1:	89 50 0c             	mov    %edx,0xc(%rax)
			p_json_msg->i_data_len = gsi_build_parse_get_msg_len(*s_line);
  402fc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fc8:	48 8b 00             	mov    (%rax),%rax
  402fcb:	48 89 c7             	mov    %rax,%rdi
  402fce:	e8 36 fe ff ff       	callq  402e09 <gsi_build_parse_get_msg_len>
  402fd3:	89 c2                	mov    %eax,%edx
  402fd5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402fd9:	89 50 10             	mov    %edx,0x10(%rax)

			// Duplicate message content
			p_json_msg->s_data  = gsi_build_parse_strdup(gsi_build_parse_get_msg_content(s_line));
  402fdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fe0:	48 89 c7             	mov    %rax,%rdi
  402fe3:	e8 86 fe ff ff       	callq  402e6e <gsi_build_parse_get_msg_content>
  402fe8:	48 89 c7             	mov    %rax,%rdi
  402feb:	e8 f6 09 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  402ff0:	48 89 c2             	mov    %rax,%rdx
  402ff3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402ff7:	48 89 50 20          	mov    %rdx,0x20(%rax)
			if (NULL == p_json_msg->s_data)
  402ffb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402fff:	48 8b 40 20          	mov    0x20(%rax),%rax
  403003:	48 85 c0             	test   %rax,%rax
  403006:	0f 85 4f 01 00 00    	jne    40315b <gsi_build_parse_set_op_code_args+0x242>
			{
				return GSI_JSON_ERROR;
  40300c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403011:	e9 51 01 00 00       	jmpq   403167 <gsi_build_parse_set_op_code_args+0x24e>
			break;

		case GSI_READ_FILE:
		case GSI_PRINT_LOG:
			// Get file length
			p_json_msg->i_file_len = gsi_build_parse_get_msg_len(*s_line);
  403016:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40301a:	48 8b 00             	mov    (%rax),%rax
  40301d:	48 89 c7             	mov    %rax,%rdi
  403020:	e8 e4 fd ff ff       	callq  402e09 <gsi_build_parse_get_msg_len>
  403025:	89 c2                	mov    %eax,%edx
  403027:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40302b:	89 50 14             	mov    %edx,0x14(%rax)

			// Duplicate file name
			p_json_msg->s_file_name = gsi_build_parse_strdup(gsi_build_parse_get_file_name(s_line));
  40302e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403032:	48 89 c7             	mov    %rax,%rdi
  403035:	e8 7b 08 00 00       	callq  4038b5 <gsi_build_parse_get_file_name>
  40303a:	48 89 c7             	mov    %rax,%rdi
  40303d:	e8 a4 09 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  403042:	48 89 c2             	mov    %rax,%rdx
  403045:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403049:	48 89 50 18          	mov    %rdx,0x18(%rax)
			if (NULL == p_json_msg->s_file_name)
  40304d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403051:	48 8b 40 18          	mov    0x18(%rax),%rax
  403055:	48 85 c0             	test   %rax,%rax
  403058:	0f 85 00 01 00 00    	jne    40315e <gsi_build_parse_set_op_code_args+0x245>
			{
				return GSI_JSON_ERROR;
  40305e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403063:	e9 ff 00 00 00       	jmpq   403167 <gsi_build_parse_set_op_code_args+0x24e>
			break;

		case GSI_WRITE_FILE:
		case GSI_READ_FILE_BY_ID:
			// Get file length
			p_json_msg->i_file_len = gsi_build_parse_get_msg_len(*s_line);
  403068:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40306c:	48 8b 00             	mov    (%rax),%rax
  40306f:	48 89 c7             	mov    %rax,%rdi
  403072:	e8 92 fd ff ff       	callq  402e09 <gsi_build_parse_get_msg_len>
  403077:	89 c2                	mov    %eax,%edx
  403079:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40307d:	89 50 14             	mov    %edx,0x14(%rax)

			// Duplicate file name
			p_json_msg->s_file_name = gsi_build_parse_strdup(gsi_build_parse_get_file_name(s_line));
  403080:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403084:	48 89 c7             	mov    %rax,%rdi
  403087:	e8 29 08 00 00       	callq  4038b5 <gsi_build_parse_get_file_name>
  40308c:	48 89 c7             	mov    %rax,%rdi
  40308f:	e8 52 09 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  403094:	48 89 c2             	mov    %rax,%rdx
  403097:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40309b:	48 89 50 18          	mov    %rdx,0x18(%rax)
			if (NULL == p_json_msg->s_file_name)
  40309f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030a3:	48 8b 40 18          	mov    0x18(%rax),%rax
  4030a7:	48 85 c0             	test   %rax,%rax
  4030aa:	75 0a                	jne    4030b6 <gsi_build_parse_set_op_code_args+0x19d>
			{
				return GSI_JSON_ERROR;
  4030ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4030b1:	e9 b1 00 00 00       	jmpq   403167 <gsi_build_parse_set_op_code_args+0x24e>
			}

			// Data length
			p_json_msg->i_data_len = gsi_build_parse_get_msg_len(*s_line);
  4030b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4030ba:	48 8b 00             	mov    (%rax),%rax
  4030bd:	48 89 c7             	mov    %rax,%rdi
  4030c0:	e8 44 fd ff ff       	callq  402e09 <gsi_build_parse_get_msg_len>
  4030c5:	89 c2                	mov    %eax,%edx
  4030c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030cb:	89 50 10             	mov    %edx,0x10(%rax)

			// Allocate memory for s_data
			p_json_msg->s_data = gsi_build_parse_strdup(gsi_build_parse_get_msg_content(s_line));
  4030ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4030d2:	48 89 c7             	mov    %rax,%rdi
  4030d5:	e8 94 fd ff ff       	callq  402e6e <gsi_build_parse_get_msg_content>
  4030da:	48 89 c7             	mov    %rax,%rdi
  4030dd:	e8 04 09 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  4030e2:	48 89 c2             	mov    %rax,%rdx
  4030e5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030e9:	48 89 50 20          	mov    %rdx,0x20(%rax)
			if (NULL == p_json_msg->s_data)
  4030ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030f1:	48 8b 40 20          	mov    0x20(%rax),%rax
  4030f5:	48 85 c0             	test   %rax,%rax
  4030f8:	75 67                	jne    403161 <gsi_build_parse_set_op_code_args+0x248>
			{
				free(p_json_msg->s_file_name);
  4030fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030fe:	48 8b 40 18          	mov    0x18(%rax),%rax
  403102:	48 89 c7             	mov    %rax,%rdi
  403105:	e8 16 e4 ff ff       	callq  401520 <free@plt>
				p_json_msg->s_file_name = NULL;
  40310a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40310e:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  403115:	00 

				return GSI_JSON_ERROR;
  403116:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40311b:	eb 4a                	jmp    403167 <gsi_build_parse_set_op_code_args+0x24e>
			}

			break;

		default:
			LOG_ERROR("invalid operation code");
  40311d:	b8 00 00 00 00       	mov    $0x0,%eax
  403122:	e8 15 25 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403127:	48 89 c3             	mov    %rax,%rbx
  40312a:	b8 00 00 00 00       	mov    $0x0,%eax
  40312f:	e8 83 22 00 00       	callq  4053b7 <gsi_get_saved_file>
  403134:	41 b8 b4 02 00 00    	mov    $0x2b4,%r8d
  40313a:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  40313f:	48 89 da             	mov    %rbx,%rdx
  403142:	be 80 73 40 00       	mov    $0x407380,%esi
  403147:	48 89 c7             	mov    %rax,%rdi
  40314a:	b8 00 00 00 00       	mov    $0x0,%eax
  40314f:	e8 cc 22 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_JSON_ERROR;
  403154:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403159:	eb 0c                	jmp    403167 <gsi_build_parse_set_op_code_args+0x24e>
			if (NULL == p_json_msg->s_data)
			{
				return GSI_JSON_ERROR;
			}

			break;
  40315b:	90                   	nop
  40315c:	eb 04                	jmp    403162 <gsi_build_parse_set_op_code_args+0x249>
			if (NULL == p_json_msg->s_file_name)
			{
				return GSI_JSON_ERROR;
			}

			break;
  40315e:	90                   	nop
  40315f:	eb 01                	jmp    403162 <gsi_build_parse_set_op_code_args+0x249>
				p_json_msg->s_file_name = NULL;

				return GSI_JSON_ERROR;
			}

			break;
  403161:	90                   	nop
		default:
			LOG_ERROR("invalid operation code");
			return GSI_JSON_ERROR;
	}

	return GSI_JSON_SUCCESS;
  403162:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403167:	48 83 c4 18          	add    $0x18,%rsp
  40316b:	5b                   	pop    %rbx
  40316c:	5d                   	pop    %rbp
  40316d:	c3                   	retq   

000000000040316e <gsi_build_parse_json_obj_to_string>:
	 * Parameter:   [in-out] struct json_object *p_json - pointer to json object to use JSON-C library
	 * Return:		Success - char* - string that contatins all the structure in json format
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_json_obj_to_string(struct json_object *p_json, struct gsi_json_msg* p_json_msg)
{
  40316e:	55                   	push   %rbp
  40316f:	48 89 e5             	mov    %rsp,%rbp
  403172:	53                   	push   %rbx
  403173:	48 83 ec 28          	sub    $0x28,%rsp
  403177:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  40317b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int i_ret = 0;
  40317f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	// Check input validation
	if (NULL == p_json_msg)
  403186:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  40318b:	75 41                	jne    4031ce <gsi_build_parse_json_obj_to_string+0x60>
	{
		LOG_ERROR("invalid argument!");
  40318d:	b8 00 00 00 00       	mov    $0x0,%eax
  403192:	e8 a5 24 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403197:	48 89 c3             	mov    %rax,%rbx
  40319a:	b8 00 00 00 00       	mov    $0x0,%eax
  40319f:	e8 13 22 00 00       	callq  4053b7 <gsi_get_saved_file>
  4031a4:	41 b8 cc 02 00 00    	mov    $0x2cc,%r8d
  4031aa:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4031af:	48 89 da             	mov    %rbx,%rdx
  4031b2:	be 90 6e 40 00       	mov    $0x406e90,%esi
  4031b7:	48 89 c7             	mov    %rax,%rdi
  4031ba:	b8 00 00 00 00       	mov    $0x0,%eax
  4031bf:	e8 5c 22 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  4031c4:	b8 00 00 00 00       	mov    $0x0,%eax
  4031c9:	e9 fd 01 00 00       	jmpq   4033cb <gsi_build_parse_json_obj_to_string+0x25d>
	}

	// For each filed in structure - add object: <NAME>:<VALUE>
	i_ret += json_object_object_add(p_json, "Message Type",json_object_new_int(p_json_msg->i_msg_type));
  4031ce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4031d2:	8b 00                	mov    (%rax),%eax
  4031d4:	89 c7                	mov    %eax,%edi
  4031d6:	e8 35 e5 ff ff       	callq  401710 <json_object_new_int@plt>
  4031db:	48 89 c2             	mov    %rax,%rdx
  4031de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4031e2:	be e8 73 40 00       	mov    $0x4073e8,%esi
  4031e7:	48 89 c7             	mov    %rax,%rdi
  4031ea:	e8 91 e5 ff ff       	callq  401780 <json_object_object_add@plt>
  4031ef:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Op-Code", 	   json_object_new_int(p_json_msg->i_op_code));
  4031f2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4031f6:	8b 40 04             	mov    0x4(%rax),%eax
  4031f9:	89 c7                	mov    %eax,%edi
  4031fb:	e8 10 e5 ff ff       	callq  401710 <json_object_new_int@plt>
  403200:	48 89 c2             	mov    %rax,%rdx
  403203:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403207:	be f5 73 40 00       	mov    $0x4073f5,%esi
  40320c:	48 89 c7             	mov    %rax,%rdi
  40320f:	e8 6c e5 ff ff       	callq  401780 <json_object_object_add@plt>
  403214:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Op-Str", 	   json_object_new_string(gsi_build_parse_op_code_to_string(p_json_msg->i_op_code)));
  403217:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40321b:	8b 40 04             	mov    0x4(%rax),%eax
  40321e:	89 c7                	mov    %eax,%edi
  403220:	e8 9a 08 00 00       	callq  403abf <gsi_build_parse_op_code_to_string>
  403225:	48 89 c7             	mov    %rax,%rdi
  403228:	e8 73 e3 ff ff       	callq  4015a0 <json_object_new_string@plt>
  40322d:	48 89 c2             	mov    %rax,%rdx
  403230:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403234:	be fd 73 40 00       	mov    $0x4073fd,%esi
  403239:	48 89 c7             	mov    %rax,%rdi
  40323c:	e8 3f e5 ff ff       	callq  401780 <json_object_object_add@plt>
  403241:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Port", 	   json_object_new_int(p_json_msg->ui_port));
  403244:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  403248:	8b 40 08             	mov    0x8(%rax),%eax
  40324b:	89 c7                	mov    %eax,%edi
  40324d:	e8 be e4 ff ff       	callq  401710 <json_object_new_int@plt>
  403252:	48 89 c2             	mov    %rax,%rdx
  403255:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403259:	be 04 74 40 00       	mov    $0x407404,%esi
  40325e:	48 89 c7             	mov    %rax,%rdi
  403261:	e8 1a e5 ff ff       	callq  401780 <json_object_object_add@plt>
  403266:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Index",   	   json_object_new_int(p_json_msg->i_index));
  403269:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40326d:	8b 40 0c             	mov    0xc(%rax),%eax
  403270:	89 c7                	mov    %eax,%edi
  403272:	e8 99 e4 ff ff       	callq  401710 <json_object_new_int@plt>
  403277:	48 89 c2             	mov    %rax,%rdx
  40327a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40327e:	be 09 74 40 00       	mov    $0x407409,%esi
  403283:	48 89 c7             	mov    %rax,%rdi
  403286:	e8 f5 e4 ff ff       	callq  401780 <json_object_object_add@plt>
  40328b:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "Data Length", json_object_new_int(p_json_msg->i_data_len));
  40328e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  403292:	8b 40 10             	mov    0x10(%rax),%eax
  403295:	89 c7                	mov    %eax,%edi
  403297:	e8 74 e4 ff ff       	callq  401710 <json_object_new_int@plt>
  40329c:	48 89 c2             	mov    %rax,%rdx
  40329f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4032a3:	be 0f 74 40 00       	mov    $0x40740f,%esi
  4032a8:	48 89 c7             	mov    %rax,%rdi
  4032ab:	e8 d0 e4 ff ff       	callq  401780 <json_object_object_add@plt>
  4032b0:	01 45 ec             	add    %eax,-0x14(%rbp)
	i_ret += json_object_object_add(p_json, "File Length", json_object_new_int(p_json_msg->i_file_len));
  4032b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4032b7:	8b 40 14             	mov    0x14(%rax),%eax
  4032ba:	89 c7                	mov    %eax,%edi
  4032bc:	e8 4f e4 ff ff       	callq  401710 <json_object_new_int@plt>
  4032c1:	48 89 c2             	mov    %rax,%rdx
  4032c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4032c8:	be 1b 74 40 00       	mov    $0x40741b,%esi
  4032cd:	48 89 c7             	mov    %rax,%rdi
  4032d0:	e8 ab e4 ff ff       	callq  401780 <json_object_object_add@plt>
  4032d5:	01 45 ec             	add    %eax,-0x14(%rbp)

	// Check if has file name or NULL
	if (NULL != p_json_msg->s_file_name)
  4032d8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4032dc:	48 8b 40 18          	mov    0x18(%rax),%rax
  4032e0:	48 85 c0             	test   %rax,%rax
  4032e3:	74 29                	je     40330e <gsi_build_parse_json_obj_to_string+0x1a0>
	{
		i_ret += json_object_object_add(p_json, "File Name", json_object_new_string(p_json_msg->s_file_name));
  4032e5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4032e9:	48 8b 40 18          	mov    0x18(%rax),%rax
  4032ed:	48 89 c7             	mov    %rax,%rdi
  4032f0:	e8 ab e2 ff ff       	callq  4015a0 <json_object_new_string@plt>
  4032f5:	48 89 c2             	mov    %rax,%rdx
  4032f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4032fc:	be 27 74 40 00       	mov    $0x407427,%esi
  403301:	48 89 c7             	mov    %rax,%rdi
  403304:	e8 77 e4 ff ff       	callq  401780 <json_object_object_add@plt>
  403309:	01 45 ec             	add    %eax,-0x14(%rbp)
  40330c:	eb 19                	jmp    403327 <gsi_build_parse_json_obj_to_string+0x1b9>
	}
	else
	{
		i_ret += json_object_object_add(p_json, "File Name", NULL);
  40330e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403312:	ba 00 00 00 00       	mov    $0x0,%edx
  403317:	be 27 74 40 00       	mov    $0x407427,%esi
  40331c:	48 89 c7             	mov    %rax,%rdi
  40331f:	e8 5c e4 ff ff       	callq  401780 <json_object_object_add@plt>
  403324:	01 45 ec             	add    %eax,-0x14(%rbp)
	}

	// Check if has data or NULL
	if (NULL != p_json_msg->s_data)
  403327:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40332b:	48 8b 40 20          	mov    0x20(%rax),%rax
  40332f:	48 85 c0             	test   %rax,%rax
  403332:	74 29                	je     40335d <gsi_build_parse_json_obj_to_string+0x1ef>
	{
		i_ret += json_object_object_add(p_json, "Data", json_object_new_string(p_json_msg->s_data));
  403334:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  403338:	48 8b 40 20          	mov    0x20(%rax),%rax
  40333c:	48 89 c7             	mov    %rax,%rdi
  40333f:	e8 5c e2 ff ff       	callq  4015a0 <json_object_new_string@plt>
  403344:	48 89 c2             	mov    %rax,%rdx
  403347:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40334b:	be 31 74 40 00       	mov    $0x407431,%esi
  403350:	48 89 c7             	mov    %rax,%rdi
  403353:	e8 28 e4 ff ff       	callq  401780 <json_object_object_add@plt>
  403358:	01 45 ec             	add    %eax,-0x14(%rbp)
  40335b:	eb 19                	jmp    403376 <gsi_build_parse_json_obj_to_string+0x208>
	}
	else
	{
		i_ret += json_object_object_add(p_json, "Data", NULL);
  40335d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403361:	ba 00 00 00 00       	mov    $0x0,%edx
  403366:	be 31 74 40 00       	mov    $0x407431,%esi
  40336b:	48 89 c7             	mov    %rax,%rdi
  40336e:	e8 0d e4 ff ff       	callq  401780 <json_object_object_add@plt>
  403373:	01 45 ec             	add    %eax,-0x14(%rbp)
	}

	// Check status of adding all objects
	if (0 != i_ret)
  403376:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  40337a:	74 3e                	je     4033ba <gsi_build_parse_json_obj_to_string+0x24c>
	{
		LOG_ERROR("json object add failed");
  40337c:	b8 00 00 00 00       	mov    $0x0,%eax
  403381:	e8 b6 22 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403386:	48 89 c3             	mov    %rax,%rbx
  403389:	b8 00 00 00 00       	mov    $0x0,%eax
  40338e:	e8 24 20 00 00       	callq  4053b7 <gsi_get_saved_file>
  403393:	41 b8 f0 02 00 00    	mov    $0x2f0,%r8d
  403399:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  40339e:	48 89 da             	mov    %rbx,%rdx
  4033a1:	be 38 74 40 00       	mov    $0x407438,%esi
  4033a6:	48 89 c7             	mov    %rax,%rdi
  4033a9:	b8 00 00 00 00       	mov    $0x0,%eax
  4033ae:	e8 6d 20 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  4033b3:	b8 00 00 00 00       	mov    $0x0,%eax
  4033b8:	eb 11                	jmp    4033cb <gsi_build_parse_json_obj_to_string+0x25d>
	}

	// Converting the json object to string format, using JSON-C library function
	return (char *)json_object_to_json_string_ext(p_json, JSON_C_TO_STRING_PRETTY | JSON_C_TO_STRING_SPACED);
  4033ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4033be:	be 03 00 00 00       	mov    $0x3,%esi
  4033c3:	48 89 c7             	mov    %rax,%rdi
  4033c6:	e8 f5 e2 ff ff       	callq  4016c0 <json_object_to_json_string_ext@plt>
}
  4033cb:	48 83 c4 28          	add    $0x28,%rsp
  4033cf:	5b                   	pop    %rbx
  4033d0:	5d                   	pop    %rbp
  4033d1:	c3                   	retq   

00000000004033d2 <gsi_build_parse_string_to_json_object>:
	 * Parameter:   [out] struct json_object** p_json - pointer to fill
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR *OR* GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_string_to_json_object(char *s_data, struct json_object** p_json)
{
  4033d2:	55                   	push   %rbp
  4033d3:	48 89 e5             	mov    %rsp,%rbp
  4033d6:	53                   	push   %rbx
  4033d7:	48 83 ec 18          	sub    $0x18,%rsp
  4033db:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4033df:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if (NULL == s_data)
  4033e3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4033e8:	75 3e                	jne    403428 <gsi_build_parse_string_to_json_object+0x56>
	{
		LOG_ERROR("invalid argument!");
  4033ea:	b8 00 00 00 00       	mov    $0x0,%eax
  4033ef:	e8 48 22 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4033f4:	48 89 c3             	mov    %rax,%rbx
  4033f7:	b8 00 00 00 00       	mov    $0x0,%eax
  4033fc:	e8 b6 1f 00 00       	callq  4053b7 <gsi_get_saved_file>
  403401:	41 b8 05 03 00 00    	mov    $0x305,%r8d
  403407:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  40340c:	48 89 da             	mov    %rbx,%rdx
  40340f:	be 90 6e 40 00       	mov    $0x406e90,%esi
  403414:	48 89 c7             	mov    %rax,%rdi
  403417:	b8 00 00 00 00       	mov    $0x0,%eax
  40341c:	e8 ff 1f 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  403421:	b8 01 00 00 00       	mov    $0x1,%eax
  403426:	eb 65                	jmp    40348d <gsi_build_parse_string_to_json_object+0xbb>
	}

	// parse the string to json object
	*p_json = json_tokener_parse(s_data);
  403428:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40342c:	48 89 c7             	mov    %rax,%rdi
  40342f:	e8 dc e0 ff ff       	callq  401510 <json_tokener_parse@plt>
  403434:	48 89 c2             	mov    %rax,%rdx
  403437:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40343b:	48 89 10             	mov    %rdx,(%rax)
	if (NULL == *p_json)
  40343e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403442:	48 8b 00             	mov    (%rax),%rax
  403445:	48 85 c0             	test   %rax,%rax
  403448:	75 3e                	jne    403488 <gsi_build_parse_string_to_json_object+0xb6>
	{
		LOG_ERROR("string to json failed");
  40344a:	b8 00 00 00 00       	mov    $0x0,%eax
  40344f:	e8 e8 21 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403454:	48 89 c3             	mov    %rax,%rbx
  403457:	b8 00 00 00 00       	mov    $0x0,%eax
  40345c:	e8 56 1f 00 00       	callq  4053b7 <gsi_get_saved_file>
  403461:	41 b8 0d 03 00 00    	mov    $0x30d,%r8d
  403467:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  40346c:	48 89 da             	mov    %rbx,%rdx
  40346f:	be 70 74 40 00       	mov    $0x407470,%esi
  403474:	48 89 c7             	mov    %rax,%rdi
  403477:	b8 00 00 00 00       	mov    $0x0,%eax
  40347c:	e8 9f 1f 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  403481:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403486:	eb 05                	jmp    40348d <gsi_build_parse_string_to_json_object+0xbb>
	}

	return GSI_JSON_SUCCESS;
  403488:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40348d:	48 83 c4 18          	add    $0x18,%rsp
  403491:	5b                   	pop    %rbx
  403492:	5d                   	pop    %rbp
  403493:	c3                   	retq   

0000000000403494 <gsi_build_parse_json_object_to_json_msg>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to fill
	 * Return:		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR *OR* GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_json_object_to_json_msg(struct json_object *p_json, struct gsi_json_msg* p_json_msg)
{
  403494:	55                   	push   %rbp
  403495:	48 89 e5             	mov    %rsp,%rbp
  403498:	53                   	push   %rbx
  403499:	48 83 ec 18          	sub    $0x18,%rsp
  40349d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4034a1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((NULL == p_json) || (NULL == p_json_msg))
  4034a5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4034aa:	74 07                	je     4034b3 <gsi_build_parse_json_object_to_json_msg+0x1f>
  4034ac:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  4034b1:	75 41                	jne    4034f4 <gsi_build_parse_json_object_to_json_msg+0x60>
	{
		LOG_ERROR("invalid arguments!");
  4034b3:	b8 00 00 00 00       	mov    $0x0,%eax
  4034b8:	e8 7f 21 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4034bd:	48 89 c3             	mov    %rax,%rbx
  4034c0:	b8 00 00 00 00       	mov    $0x0,%eax
  4034c5:	e8 ed 1e 00 00       	callq  4053b7 <gsi_get_saved_file>
  4034ca:	41 b8 21 03 00 00    	mov    $0x321,%r8d
  4034d0:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4034d5:	48 89 da             	mov    %rbx,%rdx
  4034d8:	be 40 6f 40 00       	mov    $0x406f40,%esi
  4034dd:	48 89 c7             	mov    %rax,%rdi
  4034e0:	b8 00 00 00 00       	mov    $0x0,%eax
  4034e5:	e8 36 1f 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  4034ea:	b8 01 00 00 00       	mov    $0x1,%eax
  4034ef:	e9 bf 00 00 00       	jmpq   4035b3 <gsi_build_parse_json_object_to_json_msg+0x11f>
	}

	// Initialize p_json_msg fields. using JSON-C library functions
	p_json_msg->i_msg_type = json_object_get_int(json_object_object_get(p_json, "Message Type"));
  4034f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4034f8:	be e8 73 40 00       	mov    $0x4073e8,%esi
  4034fd:	48 89 c7             	mov    %rax,%rdi
  403500:	e8 6b e3 ff ff       	callq  401870 <json_object_object_get@plt>
  403505:	48 89 c7             	mov    %rax,%rdi
  403508:	e8 d3 e1 ff ff       	callq  4016e0 <json_object_get_int@plt>
  40350d:	89 c2                	mov    %eax,%edx
  40350f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403513:	89 10                	mov    %edx,(%rax)
	p_json_msg->i_op_code  = json_object_get_int(json_object_object_get(p_json, "Op-Code"));
  403515:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403519:	be f5 73 40 00       	mov    $0x4073f5,%esi
  40351e:	48 89 c7             	mov    %rax,%rdi
  403521:	e8 4a e3 ff ff       	callq  401870 <json_object_object_get@plt>
  403526:	48 89 c7             	mov    %rax,%rdi
  403529:	e8 b2 e1 ff ff       	callq  4016e0 <json_object_get_int@plt>
  40352e:	89 c2                	mov    %eax,%edx
  403530:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403534:	89 50 04             	mov    %edx,0x4(%rax)
	p_json_msg->ui_port    = json_object_get_int(json_object_object_get(p_json, "Port"));
  403537:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40353b:	be 04 74 40 00       	mov    $0x407404,%esi
  403540:	48 89 c7             	mov    %rax,%rdi
  403543:	e8 28 e3 ff ff       	callq  401870 <json_object_object_get@plt>
  403548:	48 89 c7             	mov    %rax,%rdi
  40354b:	e8 90 e1 ff ff       	callq  4016e0 <json_object_get_int@plt>
  403550:	89 c2                	mov    %eax,%edx
  403552:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403556:	89 50 08             	mov    %edx,0x8(%rax)

	// Initialize relevant fields according to operaion code
	if (GSI_JSON_SUCCESS != gsi_build_parse_handle_op_code(p_json, p_json_msg))
  403559:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  40355d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403561:	48 89 d6             	mov    %rdx,%rsi
  403564:	48 89 c7             	mov    %rax,%rdi
  403567:	e8 4e 00 00 00       	callq  4035ba <gsi_build_parse_handle_op_code>
  40356c:	85 c0                	test   %eax,%eax
  40356e:	74 3e                	je     4035ae <gsi_build_parse_json_object_to_json_msg+0x11a>
	{
		LOG_ERROR("couldn't handle op code");
  403570:	b8 00 00 00 00       	mov    $0x0,%eax
  403575:	e8 c2 20 00 00       	callq  40563c <gsi_is_gen_timestamp>
  40357a:	48 89 c3             	mov    %rax,%rbx
  40357d:	b8 00 00 00 00       	mov    $0x0,%eax
  403582:	e8 30 1e 00 00       	callq  4053b7 <gsi_get_saved_file>
  403587:	41 b8 2d 03 00 00    	mov    $0x32d,%r8d
  40358d:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  403592:	48 89 da             	mov    %rbx,%rdx
  403595:	be a8 74 40 00       	mov    $0x4074a8,%esi
  40359a:	48 89 c7             	mov    %rax,%rdi
  40359d:	b8 00 00 00 00       	mov    $0x0,%eax
  4035a2:	e8 79 1e 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_ERROR;
  4035a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4035ac:	eb 05                	jmp    4035b3 <gsi_build_parse_json_object_to_json_msg+0x11f>
	}

	return GSI_JSON_SUCCESS;
  4035ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4035b3:	48 83 c4 18          	add    $0x18,%rsp
  4035b7:	5b                   	pop    %rbx
  4035b8:	5d                   	pop    %rbp
  4035b9:	c3                   	retq   

00000000004035ba <gsi_build_parse_handle_op_code>:
	 * Parameter:   [out] struct gsi_json_msg* p_json_msg - pointer to fill
	 * Return: 		Success - GSI_JSON_SUCCESS
	 * 				Failure - GSI_JSON_INVALID_ERR *OR* GSI_JSON_ERROR
#############################################################################*/
static int gsi_build_parse_handle_op_code(struct json_object *p_json, struct gsi_json_msg* p_json_msg)
{
  4035ba:	55                   	push   %rbp
  4035bb:	48 89 e5             	mov    %rsp,%rbp
  4035be:	53                   	push   %rbx
  4035bf:	48 83 ec 18          	sub    $0x18,%rsp
  4035c3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4035c7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if (NULL == p_json_msg)
  4035cb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  4035d0:	75 41                	jne    403613 <gsi_build_parse_handle_op_code+0x59>
	{
		LOG_ERROR("invalid argument!");
  4035d2:	b8 00 00 00 00       	mov    $0x0,%eax
  4035d7:	e8 60 20 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4035dc:	48 89 c3             	mov    %rax,%rbx
  4035df:	b8 00 00 00 00       	mov    $0x0,%eax
  4035e4:	e8 ce 1d 00 00       	callq  4053b7 <gsi_get_saved_file>
  4035e9:	41 b8 41 03 00 00    	mov    $0x341,%r8d
  4035ef:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4035f4:	48 89 da             	mov    %rbx,%rdx
  4035f7:	be 90 6e 40 00       	mov    $0x406e90,%esi
  4035fc:	48 89 c7             	mov    %rax,%rdi
  4035ff:	b8 00 00 00 00       	mov    $0x0,%eax
  403604:	e8 17 1e 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_JSON_INVALID_ERR;
  403609:	b8 01 00 00 00       	mov    $0x1,%eax
  40360e:	e9 9b 02 00 00       	jmpq   4038ae <gsi_build_parse_handle_op_code+0x2f4>
	}

	switch (p_json_msg->i_op_code)
  403613:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403617:	8b 40 04             	mov    0x4(%rax),%eax
  40361a:	83 f8 05             	cmp    $0x5,%eax
  40361d:	0f 87 41 02 00 00    	ja     403864 <gsi_build_parse_handle_op_code+0x2aa>
  403623:	89 c0                	mov    %eax,%eax
  403625:	48 8b 04 c5 38 75 40 	mov    0x407538(,%rax,8),%rax
  40362c:	00 
  40362d:	ff e0                	jmpq   *%rax
	{
		case GSI_READ_STR:
			// Get index
			p_json_msg->i_index = json_object_get_int(json_object_object_get(p_json, "Index"));
  40362f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403633:	be 09 74 40 00       	mov    $0x407409,%esi
  403638:	48 89 c7             	mov    %rax,%rdi
  40363b:	e8 30 e2 ff ff       	callq  401870 <json_object_object_get@plt>
  403640:	48 89 c7             	mov    %rax,%rdi
  403643:	e8 98 e0 ff ff       	callq  4016e0 <json_object_get_int@plt>
  403648:	89 c2                	mov    %eax,%edx
  40364a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40364e:	89 50 0c             	mov    %edx,0xc(%rax)
			break;
  403651:	e9 53 02 00 00       	jmpq   4038a9 <gsi_build_parse_handle_op_code+0x2ef>

		case GSI_WRITE_STR:
			// Get index and data length
			p_json_msg->i_index    = json_object_get_int(json_object_object_get(p_json, "Index"));
  403656:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40365a:	be 09 74 40 00       	mov    $0x407409,%esi
  40365f:	48 89 c7             	mov    %rax,%rdi
  403662:	e8 09 e2 ff ff       	callq  401870 <json_object_object_get@plt>
  403667:	48 89 c7             	mov    %rax,%rdi
  40366a:	e8 71 e0 ff ff       	callq  4016e0 <json_object_get_int@plt>
  40366f:	89 c2                	mov    %eax,%edx
  403671:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403675:	89 50 0c             	mov    %edx,0xc(%rax)
			p_json_msg->i_data_len = json_object_get_int(json_object_object_get(p_json, "Data Length"));
  403678:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40367c:	be 0f 74 40 00       	mov    $0x40740f,%esi
  403681:	48 89 c7             	mov    %rax,%rdi
  403684:	e8 e7 e1 ff ff       	callq  401870 <json_object_object_get@plt>
  403689:	48 89 c7             	mov    %rax,%rdi
  40368c:	e8 4f e0 ff ff       	callq  4016e0 <json_object_get_int@plt>
  403691:	89 c2                	mov    %eax,%edx
  403693:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403697:	89 50 10             	mov    %edx,0x10(%rax)

			// Duplicate the data
			p_json_msg->s_data = gsi_build_parse_strdup(json_object_get_string(json_object_object_get(p_json, "Data")));
  40369a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40369e:	be 31 74 40 00       	mov    $0x407431,%esi
  4036a3:	48 89 c7             	mov    %rax,%rdi
  4036a6:	e8 c5 e1 ff ff       	callq  401870 <json_object_object_get@plt>
  4036ab:	48 89 c7             	mov    %rax,%rdi
  4036ae:	e8 2d df ff ff       	callq  4015e0 <json_object_get_string@plt>
  4036b3:	48 89 c7             	mov    %rax,%rdi
  4036b6:	e8 2b 03 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  4036bb:	48 89 c2             	mov    %rax,%rdx
  4036be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4036c2:	48 89 50 20          	mov    %rdx,0x20(%rax)
			if (NULL == p_json_msg->s_data)
  4036c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4036ca:	48 8b 40 20          	mov    0x20(%rax),%rax
  4036ce:	48 85 c0             	test   %rax,%rax
  4036d1:	0f 85 cb 01 00 00    	jne    4038a2 <gsi_build_parse_handle_op_code+0x2e8>
			{
				return GSI_JSON_ERROR;
  4036d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4036dc:	e9 cd 01 00 00       	jmpq   4038ae <gsi_build_parse_handle_op_code+0x2f4>
			break;

		case GSI_READ_FILE:
	    case GSI_PRINT_LOG:
			// Get file name length
			p_json_msg->i_file_len 	= json_object_get_int(json_object_object_get(p_json, "File Length"));
  4036e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4036e5:	be 1b 74 40 00       	mov    $0x40741b,%esi
  4036ea:	48 89 c7             	mov    %rax,%rdi
  4036ed:	e8 7e e1 ff ff       	callq  401870 <json_object_object_get@plt>
  4036f2:	48 89 c7             	mov    %rax,%rdi
  4036f5:	e8 e6 df ff ff       	callq  4016e0 <json_object_get_int@plt>
  4036fa:	89 c2                	mov    %eax,%edx
  4036fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403700:	89 50 14             	mov    %edx,0x14(%rax)

			// Duplicate the file name
			p_json_msg->s_file_name = gsi_build_parse_strdup(json_object_get_string(json_object_object_get(p_json, "File Name")));
  403703:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403707:	be 27 74 40 00       	mov    $0x407427,%esi
  40370c:	48 89 c7             	mov    %rax,%rdi
  40370f:	e8 5c e1 ff ff       	callq  401870 <json_object_object_get@plt>
  403714:	48 89 c7             	mov    %rax,%rdi
  403717:	e8 c4 de ff ff       	callq  4015e0 <json_object_get_string@plt>
  40371c:	48 89 c7             	mov    %rax,%rdi
  40371f:	e8 c2 02 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  403724:	48 89 c2             	mov    %rax,%rdx
  403727:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40372b:	48 89 50 18          	mov    %rdx,0x18(%rax)
			if (NULL == p_json_msg->s_file_name)
  40372f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403733:	48 8b 40 18          	mov    0x18(%rax),%rax
  403737:	48 85 c0             	test   %rax,%rax
  40373a:	0f 85 65 01 00 00    	jne    4038a5 <gsi_build_parse_handle_op_code+0x2eb>
			{
				return GSI_JSON_ERROR;
  403740:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403745:	e9 64 01 00 00       	jmpq   4038ae <gsi_build_parse_handle_op_code+0x2f4>

		case GSI_WRITE_FILE:
		case GSI_READ_FILE_BY_ID:

			// Get source file length
			p_json_msg->i_file_len 	= json_object_get_int(json_object_object_get(p_json, "File Length"));
  40374a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40374e:	be 1b 74 40 00       	mov    $0x40741b,%esi
  403753:	48 89 c7             	mov    %rax,%rdi
  403756:	e8 15 e1 ff ff       	callq  401870 <json_object_object_get@plt>
  40375b:	48 89 c7             	mov    %rax,%rdi
  40375e:	e8 7d df ff ff       	callq  4016e0 <json_object_get_int@plt>
  403763:	89 c2                	mov    %eax,%edx
  403765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403769:	89 50 14             	mov    %edx,0x14(%rax)

			// Duplicate the source file name
			p_json_msg->s_file_name = gsi_build_parse_strdup(json_object_get_string(json_object_object_get(p_json, "File Name")));
  40376c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403770:	be 27 74 40 00       	mov    $0x407427,%esi
  403775:	48 89 c7             	mov    %rax,%rdi
  403778:	e8 f3 e0 ff ff       	callq  401870 <json_object_object_get@plt>
  40377d:	48 89 c7             	mov    %rax,%rdi
  403780:	e8 5b de ff ff       	callq  4015e0 <json_object_get_string@plt>
  403785:	48 89 c7             	mov    %rax,%rdi
  403788:	e8 59 02 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  40378d:	48 89 c2             	mov    %rax,%rdx
  403790:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403794:	48 89 50 18          	mov    %rdx,0x18(%rax)
			if (NULL == p_json_msg->s_file_name)
  403798:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40379c:	48 8b 40 18          	mov    0x18(%rax),%rax
  4037a0:	48 85 c0             	test   %rax,%rax
  4037a3:	75 41                	jne    4037e6 <gsi_build_parse_handle_op_code+0x22c>
			{
				LOG_ERROR("memory allocation for s_file_name failed");
  4037a5:	b8 00 00 00 00       	mov    $0x0,%eax
  4037aa:	e8 8d 1e 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4037af:	48 89 c3             	mov    %rax,%rbx
  4037b2:	b8 00 00 00 00       	mov    $0x0,%eax
  4037b7:	e8 fb 1b 00 00       	callq  4053b7 <gsi_get_saved_file>
  4037bc:	41 b8 72 03 00 00    	mov    $0x372,%r8d
  4037c2:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4037c7:	48 89 da             	mov    %rbx,%rdx
  4037ca:	be e8 74 40 00       	mov    $0x4074e8,%esi
  4037cf:	48 89 c7             	mov    %rax,%rdi
  4037d2:	b8 00 00 00 00       	mov    $0x0,%eax
  4037d7:	e8 44 1c 00 00       	callq  405420 <gsi_is_write_to_log>
				return GSI_JSON_ERROR;
  4037dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4037e1:	e9 c8 00 00 00       	jmpq   4038ae <gsi_build_parse_handle_op_code+0x2f4>
			}

			// Get destination file length
			p_json_msg->i_data_len = json_object_get_int(json_object_object_get(p_json, "Data Length"));
  4037e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4037ea:	be 0f 74 40 00       	mov    $0x40740f,%esi
  4037ef:	48 89 c7             	mov    %rax,%rdi
  4037f2:	e8 79 e0 ff ff       	callq  401870 <json_object_object_get@plt>
  4037f7:	48 89 c7             	mov    %rax,%rdi
  4037fa:	e8 e1 de ff ff       	callq  4016e0 <json_object_get_int@plt>
  4037ff:	89 c2                	mov    %eax,%edx
  403801:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403805:	89 50 10             	mov    %edx,0x10(%rax)

			// Duplicate the destination file name
			p_json_msg->s_data = gsi_build_parse_strdup(json_object_get_string(json_object_object_get(p_json, "Data")));
  403808:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40380c:	be 31 74 40 00       	mov    $0x407431,%esi
  403811:	48 89 c7             	mov    %rax,%rdi
  403814:	e8 57 e0 ff ff       	callq  401870 <json_object_object_get@plt>
  403819:	48 89 c7             	mov    %rax,%rdi
  40381c:	e8 bf dd ff ff       	callq  4015e0 <json_object_get_string@plt>
  403821:	48 89 c7             	mov    %rax,%rdi
  403824:	e8 bd 01 00 00       	callq  4039e6 <gsi_build_parse_strdup>
  403829:	48 89 c2             	mov    %rax,%rdx
  40382c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403830:	48 89 50 20          	mov    %rdx,0x20(%rax)
			if (NULL == p_json_msg->s_data)
  403834:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403838:	48 8b 40 20          	mov    0x20(%rax),%rax
  40383c:	48 85 c0             	test   %rax,%rax
  40383f:	75 67                	jne    4038a8 <gsi_build_parse_handle_op_code+0x2ee>
			{
				free(p_json_msg->s_file_name);
  403841:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403845:	48 8b 40 18          	mov    0x18(%rax),%rax
  403849:	48 89 c7             	mov    %rax,%rdi
  40384c:	e8 cf dc ff ff       	callq  401520 <free@plt>
				p_json_msg->s_file_name = NULL;
  403851:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403855:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  40385c:	00 

				return GSI_JSON_ERROR;
  40385d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  403862:	eb 4a                	jmp    4038ae <gsi_build_parse_handle_op_code+0x2f4>
			}

			break;

		default:
			LOG_ERROR("invalid operation code");
  403864:	b8 00 00 00 00       	mov    $0x0,%eax
  403869:	e8 ce 1d 00 00       	callq  40563c <gsi_is_gen_timestamp>
  40386e:	48 89 c3             	mov    %rax,%rbx
  403871:	b8 00 00 00 00       	mov    $0x0,%eax
  403876:	e8 3c 1b 00 00       	callq  4053b7 <gsi_get_saved_file>
  40387b:	41 b8 86 03 00 00    	mov    $0x386,%r8d
  403881:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  403886:	48 89 da             	mov    %rbx,%rdx
  403889:	be 80 73 40 00       	mov    $0x407380,%esi
  40388e:	48 89 c7             	mov    %rax,%rdi
  403891:	b8 00 00 00 00       	mov    $0x0,%eax
  403896:	e8 85 1b 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_JSON_ERROR;
  40389b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4038a0:	eb 0c                	jmp    4038ae <gsi_build_parse_handle_op_code+0x2f4>
			if (NULL == p_json_msg->s_data)
			{
				return GSI_JSON_ERROR;
			}

			break;
  4038a2:	90                   	nop
  4038a3:	eb 04                	jmp    4038a9 <gsi_build_parse_handle_op_code+0x2ef>
			if (NULL == p_json_msg->s_file_name)
			{
				return GSI_JSON_ERROR;
			}

			break;
  4038a5:	90                   	nop
  4038a6:	eb 01                	jmp    4038a9 <gsi_build_parse_handle_op_code+0x2ef>
				p_json_msg->s_file_name = NULL;

				return GSI_JSON_ERROR;
			}

			break;
  4038a8:	90                   	nop
		default:
			LOG_ERROR("invalid operation code");
			return GSI_JSON_ERROR;
	}

	return GSI_JSON_SUCCESS;
  4038a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4038ae:	48 83 c4 18          	add    $0x18,%rsp
  4038b2:	5b                   	pop    %rbx
  4038b3:	5d                   	pop    %rbp
  4038b4:	c3                   	retq   

00000000004038b5 <gsi_build_parse_get_file_name>:
	 * Parameter:   [in] char** s_line - address of current line
	 * Return:		Success - char* - source file name
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_get_file_name(char** s_line)
{
  4038b5:	55                   	push   %rbp
  4038b6:	48 89 e5             	mov    %rsp,%rbp
  4038b9:	53                   	push   %rbx
  4038ba:	48 83 ec 28          	sub    $0x28,%rsp
  4038be:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	char* s_src_file = NULL;
  4038c2:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  4038c9:	00 
	char* s_runner = NULL;
  4038ca:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  4038d1:	00 

	// Check input validation
	if (NULL == s_line)
  4038d2:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  4038d7:	75 53                	jne    40392c <gsi_build_parse_get_file_name+0x77>
	{
		LOG_ERROR("invalid argument!");
  4038d9:	b8 00 00 00 00       	mov    $0x0,%eax
  4038de:	e8 59 1d 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4038e3:	48 89 c3             	mov    %rax,%rbx
  4038e6:	b8 00 00 00 00       	mov    $0x0,%eax
  4038eb:	e8 c7 1a 00 00       	callq  4053b7 <gsi_get_saved_file>
  4038f0:	41 b8 9d 03 00 00    	mov    $0x39d,%r8d
  4038f6:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  4038fb:	48 89 da             	mov    %rbx,%rdx
  4038fe:	be 90 6e 40 00       	mov    $0x406e90,%esi
  403903:	48 89 c7             	mov    %rax,%rdi
  403906:	b8 00 00 00 00       	mov    $0x0,%eax
  40390b:	e8 10 1b 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  403910:	b8 00 00 00 00       	mov    $0x0,%eax
  403915:	e9 c5 00 00 00       	jmpq   4039df <gsi_build_parse_get_file_name+0x12a>
	}

	//Skip all white space before the file name
	while (('\0' != **s_line) && (isspace(**s_line)))
	{
		++(*s_line);
  40391a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40391e:	48 8b 00             	mov    (%rax),%rax
  403921:	48 8d 50 01          	lea    0x1(%rax),%rdx
  403925:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403929:	48 89 10             	mov    %rdx,(%rax)
		LOG_ERROR("invalid argument!");
		return NULL;
	}

	//Skip all white space before the file name
	while (('\0' != **s_line) && (isspace(**s_line)))
  40392c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403930:	48 8b 00             	mov    (%rax),%rax
  403933:	0f b6 00             	movzbl (%rax),%eax
  403936:	84 c0                	test   %al,%al
  403938:	74 2b                	je     403965 <gsi_build_parse_get_file_name+0xb0>
  40393a:	e8 b1 df ff ff       	callq  4018f0 <__ctype_b_loc@plt>
  40393f:	48 8b 10             	mov    (%rax),%rdx
  403942:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403946:	48 8b 00             	mov    (%rax),%rax
  403949:	0f b6 00             	movzbl (%rax),%eax
  40394c:	48 0f be c0          	movsbq %al,%rax
  403950:	48 01 c0             	add    %rax,%rax
  403953:	48 01 d0             	add    %rdx,%rax
  403956:	0f b7 00             	movzwl (%rax),%eax
  403959:	0f b7 c0             	movzwl %ax,%eax
  40395c:	25 00 20 00 00       	and    $0x2000,%eax
  403961:	85 c0                	test   %eax,%eax
  403963:	75 b5                	jne    40391a <gsi_build_parse_get_file_name+0x65>
	{
		++(*s_line);
	}

	// Start point to hold the name of the file
	s_src_file = *s_line;
  403965:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403969:	48 8b 00             	mov    (%rax),%rax
  40396c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// Runner pointer to run until meet white space
	s_runner = s_src_file;
  403970:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403974:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// Main run loop
	while (!isspace(*s_runner) && ('\n' != *s_runner))
  403978:	eb 05                	jmp    40397f <gsi_build_parse_get_file_name+0xca>
	{
		++s_runner;
  40397a:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)

	// Runner pointer to run until meet white space
	s_runner = s_src_file;

	// Main run loop
	while (!isspace(*s_runner) && ('\n' != *s_runner))
  40397f:	e8 6c df ff ff       	callq  4018f0 <__ctype_b_loc@plt>
  403984:	48 8b 10             	mov    (%rax),%rdx
  403987:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40398b:	0f b6 00             	movzbl (%rax),%eax
  40398e:	48 0f be c0          	movsbq %al,%rax
  403992:	48 01 c0             	add    %rax,%rax
  403995:	48 01 d0             	add    %rdx,%rax
  403998:	0f b7 00             	movzwl (%rax),%eax
  40399b:	0f b7 c0             	movzwl %ax,%eax
  40399e:	25 00 20 00 00       	and    $0x2000,%eax
  4039a3:	85 c0                	test   %eax,%eax
  4039a5:	75 0b                	jne    4039b2 <gsi_build_parse_get_file_name+0xfd>
  4039a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4039ab:	0f b6 00             	movzbl (%rax),%eax
  4039ae:	3c 0a                	cmp    $0xa,%al
  4039b0:	75 c8                	jne    40397a <gsi_build_parse_get_file_name+0xc5>
	{
		++s_runner;
	}

	// Split the string in the current position
	*s_runner = '\0';
  4039b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4039b6:	c6 00 00             	movb   $0x0,(%rax)

	// Move the original pointer by length of the file name
	*s_line += strlen(s_src_file) + 1;
  4039b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4039bd:	48 8b 18             	mov    (%rax),%rbx
  4039c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4039c4:	48 89 c7             	mov    %rax,%rdi
  4039c7:	e8 24 dc ff ff       	callq  4015f0 <strlen@plt>
  4039cc:	48 83 c0 01          	add    $0x1,%rax
  4039d0:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  4039d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4039d8:	48 89 10             	mov    %rdx,(%rax)

	return s_src_file;
  4039db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  4039df:	48 83 c4 28          	add    $0x28,%rsp
  4039e3:	5b                   	pop    %rbx
  4039e4:	5d                   	pop    %rbp
  4039e5:	c3                   	retq   

00000000004039e6 <gsi_build_parse_strdup>:
	 * Parameter:   [in] char* s_src - source string
	 * Return:		Success - duplicate string
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_strdup(const char* s_src)
{
  4039e6:	55                   	push   %rbp
  4039e7:	48 89 e5             	mov    %rsp,%rbp
  4039ea:	53                   	push   %rbx
  4039eb:	48 83 ec 28          	sub    $0x28,%rsp
  4039ef:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	char* s_dest = NULL;
  4039f3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  4039fa:	00 

	// Check input validation
	if (NULL == s_src)
  4039fb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  403a00:	75 3e                	jne    403a40 <gsi_build_parse_strdup+0x5a>
	{
		LOG_ERROR("invalid argument!");
  403a02:	b8 00 00 00 00       	mov    $0x0,%eax
  403a07:	e8 30 1c 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403a0c:	48 89 c3             	mov    %rax,%rbx
  403a0f:	b8 00 00 00 00       	mov    $0x0,%eax
  403a14:	e8 9e 19 00 00       	callq  4053b7 <gsi_get_saved_file>
  403a19:	41 b8 ca 03 00 00    	mov    $0x3ca,%r8d
  403a1f:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  403a24:	48 89 da             	mov    %rbx,%rdx
  403a27:	be 90 6e 40 00       	mov    $0x406e90,%esi
  403a2c:	48 89 c7             	mov    %rax,%rdi
  403a2f:	b8 00 00 00 00       	mov    $0x0,%eax
  403a34:	e8 e7 19 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  403a39:	b8 00 00 00 00       	mov    $0x0,%eax
  403a3e:	eb 78                	jmp    403ab8 <gsi_build_parse_strdup+0xd2>
	}

	// Allocate memory for the destination
	s_dest = (char *)malloc(strlen(s_src) + 1);
  403a40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403a44:	48 89 c7             	mov    %rax,%rdi
  403a47:	e8 a4 db ff ff       	callq  4015f0 <strlen@plt>
  403a4c:	48 83 c0 01          	add    $0x1,%rax
  403a50:	48 89 c7             	mov    %rax,%rdi
  403a53:	e8 58 dd ff ff       	callq  4017b0 <malloc@plt>
  403a58:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == s_dest)
  403a5c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  403a61:	75 3e                	jne    403aa1 <gsi_build_parse_strdup+0xbb>
	{
		LOG_ERROR("memory allocation in for dupliaction failed");
  403a63:	b8 00 00 00 00       	mov    $0x0,%eax
  403a68:	e8 cf 1b 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403a6d:	48 89 c3             	mov    %rax,%rbx
  403a70:	b8 00 00 00 00       	mov    $0x0,%eax
  403a75:	e8 3d 19 00 00       	callq  4053b7 <gsi_get_saved_file>
  403a7a:	41 b8 d2 03 00 00    	mov    $0x3d2,%r8d
  403a80:	b9 70 6e 40 00       	mov    $0x406e70,%ecx
  403a85:	48 89 da             	mov    %rbx,%rdx
  403a88:	be 68 75 40 00       	mov    $0x407568,%esi
  403a8d:	48 89 c7             	mov    %rax,%rdi
  403a90:	b8 00 00 00 00       	mov    $0x0,%eax
  403a95:	e8 86 19 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  403a9a:	b8 00 00 00 00       	mov    $0x0,%eax
  403a9f:	eb 17                	jmp    403ab8 <gsi_build_parse_strdup+0xd2>
	}

	// Copy content
	strcpy(s_dest, s_src);
  403aa1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  403aa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403aa9:	48 89 d6             	mov    %rdx,%rsi
  403aac:	48 89 c7             	mov    %rax,%rdi
  403aaf:	e8 ac da ff ff       	callq  401560 <strcpy@plt>

	return s_dest;
  403ab4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  403ab8:	48 83 c4 28          	add    $0x28,%rsp
  403abc:	5b                   	pop    %rbx
  403abd:	5d                   	pop    %rbp
  403abe:	c3                   	retq   

0000000000403abf <gsi_build_parse_op_code_to_string>:
	 * Parameter:   [in] int i_op_code - op code number
	 * Return:		Success - op code as string literal
	 * 				Failure - NULL
#############################################################################*/
static char* gsi_build_parse_op_code_to_string(int i_op_code)
{
  403abf:	55                   	push   %rbp
  403ac0:	48 89 e5             	mov    %rsp,%rbp
  403ac3:	89 7d fc             	mov    %edi,-0x4(%rbp)
	switch(i_op_code)
  403ac6:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  403aca:	77 37                	ja     403b03 <gsi_build_parse_op_code_to_string+0x44>
  403acc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  403acf:	48 8b 04 c5 f8 75 40 	mov    0x4075f8(,%rax,8),%rax
  403ad6:	00 
  403ad7:	ff e0                	jmpq   *%rax
	{
		case GSI_READ_STR:
			return "READ_STR";
  403ad9:	b8 b5 75 40 00       	mov    $0x4075b5,%eax
  403ade:	eb 28                	jmp    403b08 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_WRITE_STR:
			return "WRITE_STR";
  403ae0:	b8 be 75 40 00       	mov    $0x4075be,%eax
  403ae5:	eb 21                	jmp    403b08 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_READ_FILE:
			return "READ_FILE";
  403ae7:	b8 c8 75 40 00       	mov    $0x4075c8,%eax
  403aec:	eb 1a                	jmp    403b08 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_PRINT_LOG:
			return "PRINT_LOG";
  403aee:	b8 d2 75 40 00       	mov    $0x4075d2,%eax
  403af3:	eb 13                	jmp    403b08 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_WRITE_FILE:
			return "WRITE_FILE";
  403af5:	b8 dc 75 40 00       	mov    $0x4075dc,%eax
  403afa:	eb 0c                	jmp    403b08 <gsi_build_parse_op_code_to_string+0x49>

		case GSI_READ_FILE_BY_ID:
			return "READ_STR_BY_ID";
  403afc:	b8 e7 75 40 00       	mov    $0x4075e7,%eax
  403b01:	eb 05                	jmp    403b08 <gsi_build_parse_op_code_to_string+0x49>

		default:
			return NULL;
  403b03:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
  403b08:	5d                   	pop    %rbp
  403b09:	c3                   	retq   

0000000000403b0a <gsi_is_network_tcp_reset>:
	 * Parameter:   [in] struct gsi_net_tcp* p_this - pointer to structure TCP
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_reset(struct gsi_net_tcp* p_this)
{
  403b0a:	55                   	push   %rbp
  403b0b:	48 89 e5             	mov    %rsp,%rbp
  403b0e:	53                   	push   %rbx
  403b0f:	48 83 ec 18          	sub    $0x18,%rsp
  403b13:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == p_this)
  403b17:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  403b1c:	75 3e                	jne    403b5c <gsi_is_network_tcp_reset+0x52>
	{
		LOG_ERROR("invalid argument!");
  403b1e:	b8 00 00 00 00       	mov    $0x0,%eax
  403b23:	e8 14 1b 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403b28:	48 89 c3             	mov    %rax,%rbx
  403b2b:	b8 00 00 00 00       	mov    $0x0,%eax
  403b30:	e8 82 18 00 00       	callq  4053b7 <gsi_get_saved_file>
  403b35:	41 b8 2c 00 00 00    	mov    $0x2c,%r8d
  403b3b:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403b40:	48 89 da             	mov    %rbx,%rdx
  403b43:	be 48 76 40 00       	mov    $0x407648,%esi
  403b48:	48 89 c7             	mov    %rax,%rdi
  403b4b:	b8 00 00 00 00       	mov    $0x0,%eax
  403b50:	e8 cb 18 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  403b55:	b8 01 00 00 00       	mov    $0x1,%eax
  403b5a:	eb 1b                	jmp    403b77 <gsi_is_network_tcp_reset+0x6d>
	}

	// Set all fields to 0/NULL according to their type
	memset(p_this, 0, sizeof(struct gsi_net_tcp));
  403b5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403b60:	ba 50 00 00 00       	mov    $0x50,%edx
  403b65:	be 00 00 00 00       	mov    $0x0,%esi
  403b6a:	48 89 c7             	mov    %rax,%rdi
  403b6d:	e8 0e db ff ff       	callq  401680 <memset@plt>

	return GSI_NET_RC_SUCCESS;
  403b72:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403b77:	48 83 c4 18          	add    $0x18,%rsp
  403b7b:	5b                   	pop    %rbx
  403b7c:	5d                   	pop    %rbp
  403b7d:	c3                   	retq   

0000000000403b7e <gsi_is_network_tcp_set_sockaddr>:
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_set_sockaddr(struct sockaddr_in *p_addr,
														  	    char *s_hostname,
																int i_port)
{
  403b7e:	55                   	push   %rbp
  403b7f:	48 89 e5             	mov    %rsp,%rbp
  403b82:	53                   	push   %rbx
  403b83:	48 83 ec 28          	sub    $0x28,%rsp
  403b87:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  403b8b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  403b8f:	89 55 dc             	mov    %edx,-0x24(%rbp)
	// Check input validation
	if (NULL == p_addr)
  403b92:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  403b97:	75 41                	jne    403bda <gsi_is_network_tcp_set_sockaddr+0x5c>
	{
		LOG_ERROR("invalid argument!");
  403b99:	b8 00 00 00 00       	mov    $0x0,%eax
  403b9e:	e8 99 1a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403ba3:	48 89 c3             	mov    %rax,%rbx
  403ba6:	b8 00 00 00 00       	mov    $0x0,%eax
  403bab:	e8 07 18 00 00       	callq  4053b7 <gsi_get_saved_file>
  403bb0:	41 b8 48 00 00 00    	mov    $0x48,%r8d
  403bb6:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403bbb:	48 89 da             	mov    %rbx,%rdx
  403bbe:	be 48 76 40 00       	mov    $0x407648,%esi
  403bc3:	48 89 c7             	mov    %rax,%rdi
  403bc6:	b8 00 00 00 00       	mov    $0x0,%eax
  403bcb:	e8 50 18 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  403bd0:	b8 01 00 00 00       	mov    $0x1,%eax
  403bd5:	e9 b7 00 00 00       	jmpq   403c91 <gsi_is_network_tcp_set_sockaddr+0x113>
	}

	// Setup socket parameters to INET (IPv4)
	p_addr->sin_family = AF_INET;
  403bda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403bde:	66 c7 00 02 00       	movw   $0x2,(%rax)

	// Translate Hostname to IP Address
	if (0 >= inet_pton(AF_INET, s_hostname, &p_addr->sin_addr))
  403be3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403be7:	48 8d 50 04          	lea    0x4(%rax),%rdx
  403beb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403bef:	48 89 c6             	mov    %rax,%rsi
  403bf2:	bf 02 00 00 00       	mov    $0x2,%edi
  403bf7:	e8 64 db ff ff       	callq  401760 <inet_pton@plt>
  403bfc:	85 c0                	test   %eax,%eax
  403bfe:	7f 3e                	jg     403c3e <gsi_is_network_tcp_set_sockaddr+0xc0>
	{
		LOG_ERROR("translation ip failed");
  403c00:	b8 00 00 00 00       	mov    $0x0,%eax
  403c05:	e8 32 1a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403c0a:	48 89 c3             	mov    %rax,%rbx
  403c0d:	b8 00 00 00 00       	mov    $0x0,%eax
  403c12:	e8 a0 17 00 00       	callq  4053b7 <gsi_get_saved_file>
  403c17:	41 b8 52 00 00 00    	mov    $0x52,%r8d
  403c1d:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403c22:	48 89 da             	mov    %rbx,%rdx
  403c25:	be 80 76 40 00       	mov    $0x407680,%esi
  403c2a:	48 89 c7             	mov    %rax,%rdi
  403c2d:	b8 00 00 00 00       	mov    $0x0,%eax
  403c32:	e8 e9 17 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  403c37:	b8 01 00 00 00       	mov    $0x1,%eax
  403c3c:	eb 53                	jmp    403c91 <gsi_is_network_tcp_set_sockaddr+0x113>
	}

	// Translate Port to network byte order
	p_addr->sin_port = htons(i_port);
  403c3e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  403c41:	0f b7 c0             	movzwl %ax,%eax
  403c44:	89 c7                	mov    %eax,%edi
  403c46:	e8 e5 d9 ff ff       	callq  401630 <htons@plt>
  403c4b:	89 c2                	mov    %eax,%edx
  403c4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403c51:	66 89 50 02          	mov    %dx,0x2(%rax)

	LOG_INFO("set socket parameters success");
  403c55:	b8 00 00 00 00       	mov    $0x0,%eax
  403c5a:	e8 dd 19 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403c5f:	48 89 c3             	mov    %rax,%rbx
  403c62:	b8 00 00 00 00       	mov    $0x0,%eax
  403c67:	e8 4b 17 00 00       	callq  4053b7 <gsi_get_saved_file>
  403c6c:	41 b8 59 00 00 00    	mov    $0x59,%r8d
  403c72:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403c77:	48 89 da             	mov    %rbx,%rdx
  403c7a:	be b8 76 40 00       	mov    $0x4076b8,%esi
  403c7f:	48 89 c7             	mov    %rax,%rdi
  403c82:	b8 00 00 00 00       	mov    $0x0,%eax
  403c87:	e8 94 17 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  403c8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403c91:	48 83 c4 28          	add    $0x28,%rsp
  403c95:	5b                   	pop    %rbx
  403c96:	5d                   	pop    %rbp
  403c97:	c3                   	retq   

0000000000403c98 <gsi_is_network_tcp_connect>:
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_connect(struct sockaddr_in *p_serv_addr,
													 	   int *p_socket_fd)
{
  403c98:	55                   	push   %rbp
  403c99:	48 89 e5             	mov    %rsp,%rbp
  403c9c:	53                   	push   %rbx
  403c9d:	48 83 ec 18          	sub    $0x18,%rsp
  403ca1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  403ca5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((NULL == p_serv_addr) || (NULL == p_socket_fd))
  403ca9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  403cae:	74 07                	je     403cb7 <gsi_is_network_tcp_connect+0x1f>
  403cb0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  403cb5:	75 41                	jne    403cf8 <gsi_is_network_tcp_connect+0x60>
	{
		LOG_ERROR("invalid arguments!");
  403cb7:	b8 00 00 00 00       	mov    $0x0,%eax
  403cbc:	e8 7b 19 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403cc1:	48 89 c3             	mov    %rax,%rbx
  403cc4:	b8 00 00 00 00       	mov    $0x0,%eax
  403cc9:	e8 e9 16 00 00       	callq  4053b7 <gsi_get_saved_file>
  403cce:	41 b8 6f 00 00 00    	mov    $0x6f,%r8d
  403cd4:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403cd9:	48 89 da             	mov    %rbx,%rdx
  403cdc:	be f8 76 40 00       	mov    $0x4076f8,%esi
  403ce1:	48 89 c7             	mov    %rax,%rdi
  403ce4:	b8 00 00 00 00       	mov    $0x0,%eax
  403ce9:	e8 32 17 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  403cee:	b8 01 00 00 00       	mov    $0x1,%eax
  403cf3:	e9 fe 00 00 00       	jmpq   403df6 <gsi_is_network_tcp_connect+0x15e>
	}

	// Open a Socket and update p_socket_fd
	if (0 > (*p_socket_fd = socket(AF_INET, SOCK_STREAM, 0)))
  403cf8:	ba 00 00 00 00       	mov    $0x0,%edx
  403cfd:	be 01 00 00 00       	mov    $0x1,%esi
  403d02:	bf 02 00 00 00       	mov    $0x2,%edi
  403d07:	e8 f4 db ff ff       	callq  401900 <socket@plt>
  403d0c:	89 c2                	mov    %eax,%edx
  403d0e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403d12:	89 10                	mov    %edx,(%rax)
  403d14:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403d18:	8b 00                	mov    (%rax),%eax
  403d1a:	85 c0                	test   %eax,%eax
  403d1c:	79 41                	jns    403d5f <gsi_is_network_tcp_connect+0xc7>
	{
		LOG_ERROR("socket fail");
  403d1e:	b8 00 00 00 00       	mov    $0x0,%eax
  403d23:	e8 14 19 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403d28:	48 89 c3             	mov    %rax,%rbx
  403d2b:	b8 00 00 00 00       	mov    $0x0,%eax
  403d30:	e8 82 16 00 00       	callq  4053b7 <gsi_get_saved_file>
  403d35:	41 b8 76 00 00 00    	mov    $0x76,%r8d
  403d3b:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403d40:	48 89 da             	mov    %rbx,%rdx
  403d43:	be 30 77 40 00       	mov    $0x407730,%esi
  403d48:	48 89 c7             	mov    %rax,%rdi
  403d4b:	b8 00 00 00 00       	mov    $0x0,%eax
  403d50:	e8 cb 16 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  403d55:	b8 01 00 00 00       	mov    $0x1,%eax
  403d5a:	e9 97 00 00 00       	jmpq   403df6 <gsi_is_network_tcp_connect+0x15e>
	}

	// Connect to Server
	if (0 > connect(*p_socket_fd, (struct sockaddr *)p_serv_addr, sizeof(struct sockaddr_in)))
  403d5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  403d63:	8b 00                	mov    (%rax),%eax
  403d65:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  403d69:	ba 10 00 00 00       	mov    $0x10,%edx
  403d6e:	48 89 ce             	mov    %rcx,%rsi
  403d71:	89 c7                	mov    %eax,%edi
  403d73:	e8 28 db ff ff       	callq  4018a0 <connect@plt>
  403d78:	85 c0                	test   %eax,%eax
  403d7a:	79 3e                	jns    403dba <gsi_is_network_tcp_connect+0x122>
	{
		LOG_ERROR("connect fail");
  403d7c:	b8 00 00 00 00       	mov    $0x0,%eax
  403d81:	e8 b6 18 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403d86:	48 89 c3             	mov    %rax,%rbx
  403d89:	b8 00 00 00 00       	mov    $0x0,%eax
  403d8e:	e8 24 16 00 00       	callq  4053b7 <gsi_get_saved_file>
  403d93:	41 b8 7d 00 00 00    	mov    $0x7d,%r8d
  403d99:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403d9e:	48 89 da             	mov    %rbx,%rdx
  403da1:	be 60 77 40 00       	mov    $0x407760,%esi
  403da6:	48 89 c7             	mov    %rax,%rdi
  403da9:	b8 00 00 00 00       	mov    $0x0,%eax
  403dae:	e8 6d 16 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_CONNECTERR;
  403db3:	b8 04 00 00 00       	mov    $0x4,%eax
  403db8:	eb 3c                	jmp    403df6 <gsi_is_network_tcp_connect+0x15e>
	}

	LOG_INFO("connect success!");
  403dba:	b8 00 00 00 00       	mov    $0x0,%eax
  403dbf:	e8 78 18 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403dc4:	48 89 c3             	mov    %rax,%rbx
  403dc7:	b8 00 00 00 00       	mov    $0x0,%eax
  403dcc:	e8 e6 15 00 00       	callq  4053b7 <gsi_get_saved_file>
  403dd1:	41 b8 81 00 00 00    	mov    $0x81,%r8d
  403dd7:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403ddc:	48 89 da             	mov    %rbx,%rdx
  403ddf:	be 90 77 40 00       	mov    $0x407790,%esi
  403de4:	48 89 c7             	mov    %rax,%rdi
  403de7:	b8 00 00 00 00       	mov    $0x0,%eax
  403dec:	e8 2f 16 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  403df1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  403df6:	48 83 c4 18          	add    $0x18,%rsp
  403dfa:	5b                   	pop    %rbx
  403dfb:	5d                   	pop    %rbp
  403dfc:	c3                   	retq   

0000000000403dfd <gsi_is_network_tcp_send>:
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR *OR* GSI_NET_RC_CONNECTERR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_send(struct gsi_net_tcp *p_this,
														char *s_msg)
{
  403dfd:	55                   	push   %rbp
  403dfe:	48 89 e5             	mov    %rsp,%rbp
  403e01:	53                   	push   %rbx
  403e02:	48 83 ec 28          	sub    $0x28,%rsp
  403e06:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  403e0a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int i_len = 0;
  403e0e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	int i_count = 0;
  403e15:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	struct gsi_cs_tcp_message *p_msg = (struct gsi_cs_tcp_message *)s_msg;
  403e1c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  403e20:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// Check input validation
	if ((NULL == p_this) || (NULL == p_msg))
  403e24:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  403e29:	74 07                	je     403e32 <gsi_is_network_tcp_send+0x35>
  403e2b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  403e30:	75 41                	jne    403e73 <gsi_is_network_tcp_send+0x76>
	{
		LOG_ERROR("invalid arguments!");
  403e32:	b8 00 00 00 00       	mov    $0x0,%eax
  403e37:	e8 00 18 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403e3c:	48 89 c3             	mov    %rax,%rbx
  403e3f:	b8 00 00 00 00       	mov    $0x0,%eax
  403e44:	e8 6e 15 00 00       	callq  4053b7 <gsi_get_saved_file>
  403e49:	41 b8 98 00 00 00    	mov    $0x98,%r8d
  403e4f:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403e54:	48 89 da             	mov    %rbx,%rdx
  403e57:	be f8 76 40 00       	mov    $0x4076f8,%esi
  403e5c:	48 89 c7             	mov    %rax,%rdi
  403e5f:	b8 00 00 00 00       	mov    $0x0,%eax
  403e64:	e8 b7 15 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  403e69:	b8 01 00 00 00       	mov    $0x1,%eax
  403e6e:	e9 c1 01 00 00       	jmpq   404034 <gsi_is_network_tcp_send+0x237>
	}

	// Save message size for later comparison
	i_len = sizeof(*p_msg) - sizeof(char*);
  403e73:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%rbp)
	/* 	Attempt to WRITE:
	 * 		if i_count == original requested i_len -- Success
	 * 		if i_count < 0 -- Error, Attempt to Re-Connect
	 * 		if 0 < i_count < i_len - Partial. Consider an Error
	 */
	while ((i_count = write(p_this->i_connection_fd, p_msg, i_len)) < 0)
  403e7a:	e9 97 00 00 00       	jmpq   403f16 <gsi_is_network_tcp_send+0x119>
	{
		LOG_INFO("try to reconnect...");
  403e7f:	b8 00 00 00 00       	mov    $0x0,%eax
  403e84:	e8 b3 17 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403e89:	48 89 c3             	mov    %rax,%rbx
  403e8c:	b8 00 00 00 00       	mov    $0x0,%eax
  403e91:	e8 21 15 00 00       	callq  4053b7 <gsi_get_saved_file>
  403e96:	41 b8 a6 00 00 00    	mov    $0xa6,%r8d
  403e9c:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403ea1:	48 89 da             	mov    %rbx,%rdx
  403ea4:	be c8 77 40 00       	mov    $0x4077c8,%esi
  403ea9:	48 89 c7             	mov    %rax,%rdi
  403eac:	b8 00 00 00 00       	mov    $0x0,%eax
  403eb1:	e8 6a 15 00 00       	callq  405420 <gsi_is_write_to_log>

		if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_connect(&p_this->serv_addr, &p_this->i_connection_fd))
  403eb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403eba:	48 8d 50 1c          	lea    0x1c(%rax),%rdx
  403ebe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403ec2:	48 83 c0 2c          	add    $0x2c,%rax
  403ec6:	48 89 d6             	mov    %rdx,%rsi
  403ec9:	48 89 c7             	mov    %rax,%rdi
  403ecc:	e8 c7 fd ff ff       	callq  403c98 <gsi_is_network_tcp_connect>
  403ed1:	85 c0                	test   %eax,%eax
  403ed3:	74 41                	je     403f16 <gsi_is_network_tcp_send+0x119>
		{
			LOG_ERROR("connection failed!");
  403ed5:	b8 00 00 00 00       	mov    $0x0,%eax
  403eda:	e8 5d 17 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403edf:	48 89 c3             	mov    %rax,%rbx
  403ee2:	b8 00 00 00 00       	mov    $0x0,%eax
  403ee7:	e8 cb 14 00 00       	callq  4053b7 <gsi_get_saved_file>
  403eec:	41 b8 aa 00 00 00    	mov    $0xaa,%r8d
  403ef2:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403ef7:	48 89 da             	mov    %rbx,%rdx
  403efa:	be 00 78 40 00       	mov    $0x407800,%esi
  403eff:	48 89 c7             	mov    %rax,%rdi
  403f02:	b8 00 00 00 00       	mov    $0x0,%eax
  403f07:	e8 14 15 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_NET_RC_CONNECTERR;
  403f0c:	b8 04 00 00 00       	mov    $0x4,%eax
  403f11:	e9 1e 01 00 00       	jmpq   404034 <gsi_is_network_tcp_send+0x237>
	/* 	Attempt to WRITE:
	 * 		if i_count == original requested i_len -- Success
	 * 		if i_count < 0 -- Error, Attempt to Re-Connect
	 * 		if 0 < i_count < i_len - Partial. Consider an Error
	 */
	while ((i_count = write(p_this->i_connection_fd, p_msg, i_len)) < 0)
  403f16:	8b 45 e0             	mov    -0x20(%rbp),%eax
  403f19:	48 63 d0             	movslq %eax,%rdx
  403f1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403f20:	8b 40 1c             	mov    0x1c(%rax),%eax
  403f23:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  403f27:	48 89 ce             	mov    %rcx,%rsi
  403f2a:	89 c7                	mov    %eax,%edi
  403f2c:	e8 7f d6 ff ff       	callq  4015b0 <write@plt>
  403f31:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  403f34:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  403f38:	0f 88 41 ff ff ff    	js     403e7f <gsi_is_network_tcp_send+0x82>
			return GSI_NET_RC_CONNECTERR;
		}
	}

	// Send message content
	if ((GSI_REGULAR_MSG == p_msg->e_type_msg) &&
  403f3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403f42:	8b 40 04             	mov    0x4(%rax),%eax
  403f45:	83 f8 01             	cmp    $0x1,%eax
  403f48:	75 68                	jne    403fb2 <gsi_is_network_tcp_send+0x1b5>
		(0 > write(p_this->i_connection_fd, p_msg->s_message, p_msg->ui_len)))
  403f4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403f4e:	8b 40 08             	mov    0x8(%rax),%eax
  403f51:	89 c2                	mov    %eax,%edx
  403f53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403f57:	48 8b 48 10          	mov    0x10(%rax),%rcx
  403f5b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403f5f:	8b 40 1c             	mov    0x1c(%rax),%eax
  403f62:	48 89 ce             	mov    %rcx,%rsi
  403f65:	89 c7                	mov    %eax,%edi
  403f67:	e8 44 d6 ff ff       	callq  4015b0 <write@plt>
			return GSI_NET_RC_CONNECTERR;
		}
	}

	// Send message content
	if ((GSI_REGULAR_MSG == p_msg->e_type_msg) &&
  403f6c:	48 85 c0             	test   %rax,%rax
  403f6f:	79 41                	jns    403fb2 <gsi_is_network_tcp_send+0x1b5>
		(0 > write(p_this->i_connection_fd, p_msg->s_message, p_msg->ui_len)))
	{
		LOG_ERROR("write message failed");
  403f71:	b8 00 00 00 00       	mov    $0x0,%eax
  403f76:	e8 c1 16 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403f7b:	48 89 c3             	mov    %rax,%rbx
  403f7e:	b8 00 00 00 00       	mov    $0x0,%eax
  403f83:	e8 2f 14 00 00       	callq  4053b7 <gsi_get_saved_file>
  403f88:	41 b8 b3 00 00 00    	mov    $0xb3,%r8d
  403f8e:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403f93:	48 89 da             	mov    %rbx,%rdx
  403f96:	be 38 78 40 00       	mov    $0x407838,%esi
  403f9b:	48 89 c7             	mov    %rax,%rdi
  403f9e:	b8 00 00 00 00       	mov    $0x0,%eax
  403fa3:	e8 78 14 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  403fa8:	b8 01 00 00 00       	mov    $0x1,%eax
  403fad:	e9 82 00 00 00       	jmpq   404034 <gsi_is_network_tcp_send+0x237>
	}

	// Case of: 0 < i_count < i_len
	if (i_count < i_len)
  403fb2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  403fb5:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  403fb8:	7d 3e                	jge    403ff8 <gsi_is_network_tcp_send+0x1fb>
	{
		LOG_ERROR("partial write");
  403fba:	b8 00 00 00 00       	mov    $0x0,%eax
  403fbf:	e8 78 16 00 00       	callq  40563c <gsi_is_gen_timestamp>
  403fc4:	48 89 c3             	mov    %rax,%rbx
  403fc7:	b8 00 00 00 00       	mov    $0x0,%eax
  403fcc:	e8 e6 13 00 00       	callq  4053b7 <gsi_get_saved_file>
  403fd1:	41 b8 ba 00 00 00    	mov    $0xba,%r8d
  403fd7:	b9 28 76 40 00       	mov    $0x407628,%ecx
  403fdc:	48 89 da             	mov    %rbx,%rdx
  403fdf:	be 70 78 40 00       	mov    $0x407870,%esi
  403fe4:	48 89 c7             	mov    %rax,%rdi
  403fe7:	b8 00 00 00 00       	mov    $0x0,%eax
  403fec:	e8 2f 14 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  403ff1:	b8 01 00 00 00       	mov    $0x1,%eax
  403ff6:	eb 3c                	jmp    404034 <gsi_is_network_tcp_send+0x237>
	}

	LOG_INFO("message sent successfully");
  403ff8:	b8 00 00 00 00       	mov    $0x0,%eax
  403ffd:	e8 3a 16 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404002:	48 89 c3             	mov    %rax,%rbx
  404005:	b8 00 00 00 00       	mov    $0x0,%eax
  40400a:	e8 a8 13 00 00       	callq  4053b7 <gsi_get_saved_file>
  40400f:	41 b8 be 00 00 00    	mov    $0xbe,%r8d
  404015:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40401a:	48 89 da             	mov    %rbx,%rdx
  40401d:	be a0 78 40 00       	mov    $0x4078a0,%esi
  404022:	48 89 c7             	mov    %rax,%rdi
  404025:	b8 00 00 00 00       	mov    $0x0,%eax
  40402a:	e8 f1 13 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  40402f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404034:	48 83 c4 28          	add    $0x28,%rsp
  404038:	5b                   	pop    %rbx
  404039:	5d                   	pop    %rbp
  40403a:	c3                   	retq   

000000000040403b <gsi_is_network_tcp_client_init>:
	 * Parameter:   [in] char* s_tcp_addr - Address to connect to <IPAddress>:<Port>
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR *OR* GSI_NET_RC_CONNECTERR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_client_init(struct gsi_net_tcp *p_this, char* s_tcp_addr)
{
  40403b:	55                   	push   %rbp
  40403c:	48 89 e5             	mov    %rsp,%rbp
  40403f:	53                   	push   %rbx
  404040:	48 83 ec 28          	sub    $0x28,%rsp
  404044:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  404048:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Check input validation
	if ((NULL == p_this) || (NULL == s_tcp_addr))
  40404c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  404051:	74 07                	je     40405a <gsi_is_network_tcp_client_init+0x1f>
  404053:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  404058:	75 41                	jne    40409b <gsi_is_network_tcp_client_init+0x60>
	{
		LOG_ERROR("invalid arguments!");
  40405a:	b8 00 00 00 00       	mov    $0x0,%eax
  40405f:	e8 d8 15 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404064:	48 89 c3             	mov    %rax,%rbx
  404067:	b8 00 00 00 00       	mov    $0x0,%eax
  40406c:	e8 46 13 00 00       	callq  4053b7 <gsi_get_saved_file>
  404071:	41 b8 d0 00 00 00    	mov    $0xd0,%r8d
  404077:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40407c:	48 89 da             	mov    %rbx,%rdx
  40407f:	be f8 76 40 00       	mov    $0x4076f8,%esi
  404084:	48 89 c7             	mov    %rax,%rdi
  404087:	b8 00 00 00 00       	mov    $0x0,%eax
  40408c:	e8 8f 13 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404091:	b8 01 00 00 00       	mov    $0x1,%eax
  404096:	e9 77 01 00 00       	jmpq   404212 <gsi_is_network_tcp_client_init+0x1d7>
	}

	// Initialize address parameters
	char* s_port = set_address_parameters(p_this, s_tcp_addr);
  40409b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  40409f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4040a3:	48 89 d6             	mov    %rdx,%rsi
  4040a6:	48 89 c7             	mov    %rax,%rdi
  4040a9:	e8 8c 0a 00 00       	callq  404b3a <set_address_parameters>
  4040ae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == s_port)
  4040b2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4040b7:	75 41                	jne    4040fa <gsi_is_network_tcp_client_init+0xbf>
	{
		LOG_ERROR("invalid form of address");
  4040b9:	b8 00 00 00 00       	mov    $0x0,%eax
  4040be:	e8 79 15 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4040c3:	48 89 c3             	mov    %rax,%rbx
  4040c6:	b8 00 00 00 00       	mov    $0x0,%eax
  4040cb:	e8 e7 12 00 00       	callq  4053b7 <gsi_get_saved_file>
  4040d0:	41 b8 d8 00 00 00    	mov    $0xd8,%r8d
  4040d6:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4040db:	48 89 da             	mov    %rbx,%rdx
  4040de:	be e0 78 40 00       	mov    $0x4078e0,%esi
  4040e3:	48 89 c7             	mov    %rax,%rdi
  4040e6:	b8 00 00 00 00       	mov    $0x0,%eax
  4040eb:	e8 30 13 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  4040f0:	b8 01 00 00 00       	mov    $0x1,%eax
  4040f5:	e9 18 01 00 00       	jmpq   404212 <gsi_is_network_tcp_client_init+0x1d7>
	}

	// Set port member
	p_this->ui_port = atoi(s_port);
  4040fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4040fe:	48 89 c7             	mov    %rax,%rdi
  404101:	e8 5a d7 ff ff       	callq  401860 <atoi@plt>
  404106:	89 c2                	mov    %eax,%edx
  404108:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40410c:	89 50 28             	mov    %edx,0x28(%rax)

	// Set socket parameters
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_set_sockaddr(&p_this->serv_addr,
															   p_this->s_tcp_addr,
															   p_this->ui_port))
  40410f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404113:	8b 40 28             	mov    0x28(%rax),%eax

	// Set port member
	p_this->ui_port = atoi(s_port);

	// Set socket parameters
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_set_sockaddr(&p_this->serv_addr,
  404116:	89 c6                	mov    %eax,%esi
  404118:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40411c:	48 8b 00             	mov    (%rax),%rax
  40411f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  404123:	48 8d 4a 2c          	lea    0x2c(%rdx),%rcx
  404127:	89 f2                	mov    %esi,%edx
  404129:	48 89 c6             	mov    %rax,%rsi
  40412c:	48 89 cf             	mov    %rcx,%rdi
  40412f:	e8 4a fa ff ff       	callq  403b7e <gsi_is_network_tcp_set_sockaddr>
  404134:	85 c0                	test   %eax,%eax
  404136:	74 41                	je     404179 <gsi_is_network_tcp_client_init+0x13e>
															   p_this->s_tcp_addr,
															   p_this->ui_port))
	{
		LOG_ERROR("set socket parameters failed");
  404138:	b8 00 00 00 00       	mov    $0x0,%eax
  40413d:	e8 fa 14 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404142:	48 89 c3             	mov    %rax,%rbx
  404145:	b8 00 00 00 00       	mov    $0x0,%eax
  40414a:	e8 68 12 00 00       	callq  4053b7 <gsi_get_saved_file>
  40414f:	41 b8 e4 00 00 00    	mov    $0xe4,%r8d
  404155:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40415a:	48 89 da             	mov    %rbx,%rdx
  40415d:	be 20 79 40 00       	mov    $0x407920,%esi
  404162:	48 89 c7             	mov    %rax,%rdi
  404165:	b8 00 00 00 00       	mov    $0x0,%eax
  40416a:	e8 b1 12 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  40416f:	b8 01 00 00 00       	mov    $0x1,%eax
  404174:	e9 99 00 00 00       	jmpq   404212 <gsi_is_network_tcp_client_init+0x1d7>
	}

	// Connect to Server
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_connect(&p_this->serv_addr, &p_this->i_connection_fd))
  404179:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40417d:	48 8d 50 1c          	lea    0x1c(%rax),%rdx
  404181:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404185:	48 83 c0 2c          	add    $0x2c,%rax
  404189:	48 89 d6             	mov    %rdx,%rsi
  40418c:	48 89 c7             	mov    %rax,%rdi
  40418f:	e8 04 fb ff ff       	callq  403c98 <gsi_is_network_tcp_connect>
  404194:	85 c0                	test   %eax,%eax
  404196:	74 3e                	je     4041d6 <gsi_is_network_tcp_client_init+0x19b>
	{
		LOG_ERROR("connection failed!");
  404198:	b8 00 00 00 00       	mov    $0x0,%eax
  40419d:	e8 9a 14 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4041a2:	48 89 c3             	mov    %rax,%rbx
  4041a5:	b8 00 00 00 00       	mov    $0x0,%eax
  4041aa:	e8 08 12 00 00       	callq  4053b7 <gsi_get_saved_file>
  4041af:	41 b8 eb 00 00 00    	mov    $0xeb,%r8d
  4041b5:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4041ba:	48 89 da             	mov    %rbx,%rdx
  4041bd:	be 00 78 40 00       	mov    $0x407800,%esi
  4041c2:	48 89 c7             	mov    %rax,%rdi
  4041c5:	b8 00 00 00 00       	mov    $0x0,%eax
  4041ca:	e8 51 12 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_CONNECTERR;
  4041cf:	b8 04 00 00 00       	mov    $0x4,%eax
  4041d4:	eb 3c                	jmp    404212 <gsi_is_network_tcp_client_init+0x1d7>
	}

	LOG_INFO("client init successfully");
  4041d6:	b8 00 00 00 00       	mov    $0x0,%eax
  4041db:	e8 5c 14 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4041e0:	48 89 c3             	mov    %rax,%rbx
  4041e3:	b8 00 00 00 00       	mov    $0x0,%eax
  4041e8:	e8 ca 11 00 00       	callq  4053b7 <gsi_get_saved_file>
  4041ed:	41 b8 ef 00 00 00    	mov    $0xef,%r8d
  4041f3:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4041f8:	48 89 da             	mov    %rbx,%rdx
  4041fb:	be 60 79 40 00       	mov    $0x407960,%esi
  404200:	48 89 c7             	mov    %rax,%rdi
  404203:	b8 00 00 00 00       	mov    $0x0,%eax
  404208:	e8 13 12 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  40420d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404212:	48 83 c4 28          	add    $0x28,%rsp
  404216:	5b                   	pop    %rbx
  404217:	5d                   	pop    %rbp
  404218:	c3                   	retq   

0000000000404219 <gsi_is_network_tcp_server_init>:
	 * Parameter:   [in] unsigned int ui_port - port to connect to
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_server_init(struct gsi_net_tcp *p_this, unsigned int ui_port)
{
  404219:	55                   	push   %rbp
  40421a:	48 89 e5             	mov    %rsp,%rbp
  40421d:	41 54                	push   %r12
  40421f:	53                   	push   %rbx
  404220:	48 83 ec 20          	sub    $0x20,%rsp
  404224:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  404228:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  40422b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  404232:	00 00 
  404234:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  404238:	31 c0                	xor    %eax,%eax
	// Check input validation
	if (NULL == p_this)
  40423a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  40423f:	75 41                	jne    404282 <gsi_is_network_tcp_server_init+0x69>
	{
		LOG_ERROR("invalid arguments!");
  404241:	b8 00 00 00 00       	mov    $0x0,%eax
  404246:	e8 f1 13 00 00       	callq  40563c <gsi_is_gen_timestamp>
  40424b:	48 89 c3             	mov    %rax,%rbx
  40424e:	b8 00 00 00 00       	mov    $0x0,%eax
  404253:	e8 5f 11 00 00       	callq  4053b7 <gsi_get_saved_file>
  404258:	41 b8 03 01 00 00    	mov    $0x103,%r8d
  40425e:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404263:	48 89 da             	mov    %rbx,%rdx
  404266:	be f8 76 40 00       	mov    $0x4076f8,%esi
  40426b:	48 89 c7             	mov    %rax,%rdi
  40426e:	b8 00 00 00 00       	mov    $0x0,%eax
  404273:	e8 a8 11 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404278:	b8 01 00 00 00       	mov    $0x1,%eax
  40427d:	e9 b4 02 00 00       	jmpq   404536 <gsi_is_network_tcp_server_init+0x31d>
	}

	// Reset server parameters
	if(GSI_NET_RC_SUCCESS != gsi_is_network_tcp_reset(p_this))
  404282:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404286:	48 89 c7             	mov    %rax,%rdi
  404289:	e8 7c f8 ff ff       	callq  403b0a <gsi_is_network_tcp_reset>
  40428e:	85 c0                	test   %eax,%eax
  404290:	74 41                	je     4042d3 <gsi_is_network_tcp_server_init+0xba>
	{
		LOG_ERROR("reset server parameters failed");
  404292:	b8 00 00 00 00       	mov    $0x0,%eax
  404297:	e8 a0 13 00 00       	callq  40563c <gsi_is_gen_timestamp>
  40429c:	48 89 c3             	mov    %rax,%rbx
  40429f:	b8 00 00 00 00       	mov    $0x0,%eax
  4042a4:	e8 0e 11 00 00       	callq  4053b7 <gsi_get_saved_file>
  4042a9:	41 b8 0a 01 00 00    	mov    $0x10a,%r8d
  4042af:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4042b4:	48 89 da             	mov    %rbx,%rdx
  4042b7:	be a0 79 40 00       	mov    $0x4079a0,%esi
  4042bc:	48 89 c7             	mov    %rax,%rdi
  4042bf:	b8 00 00 00 00       	mov    $0x0,%eax
  4042c4:	e8 57 11 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  4042c9:	b8 01 00 00 00       	mov    $0x1,%eax
  4042ce:	e9 63 02 00 00       	jmpq   404536 <gsi_is_network_tcp_server_init+0x31d>
	}

	// Set local ip
	p_this->s_tcp_addr = "127.0.0.1";
  4042d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4042d7:	48 c7 00 e0 79 40 00 	movq   $0x4079e0,(%rax)
	p_this->ui_port = ui_port;
  4042de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4042e2:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  4042e5:	89 50 28             	mov    %edx,0x28(%rax)

	// Set socket parameters
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_set_sockaddr(&p_this->serv_addr,
															   p_this->s_tcp_addr,
															   p_this->ui_port))
  4042e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4042ec:	8b 40 28             	mov    0x28(%rax),%eax
	// Set local ip
	p_this->s_tcp_addr = "127.0.0.1";
	p_this->ui_port = ui_port;

	// Set socket parameters
	if (GSI_NET_RC_SUCCESS != gsi_is_network_tcp_set_sockaddr(&p_this->serv_addr,
  4042ef:	89 c6                	mov    %eax,%esi
  4042f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4042f5:	48 8b 00             	mov    (%rax),%rax
  4042f8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  4042fc:	48 8d 4a 2c          	lea    0x2c(%rdx),%rcx
  404300:	89 f2                	mov    %esi,%edx
  404302:	48 89 c6             	mov    %rax,%rsi
  404305:	48 89 cf             	mov    %rcx,%rdi
  404308:	e8 71 f8 ff ff       	callq  403b7e <gsi_is_network_tcp_set_sockaddr>
  40430d:	85 c0                	test   %eax,%eax
  40430f:	74 41                	je     404352 <gsi_is_network_tcp_server_init+0x139>
															   p_this->s_tcp_addr,
															   p_this->ui_port))
	{
		LOG_ERROR("set socket parameters failed");
  404311:	b8 00 00 00 00       	mov    $0x0,%eax
  404316:	e8 21 13 00 00       	callq  40563c <gsi_is_gen_timestamp>
  40431b:	48 89 c3             	mov    %rax,%rbx
  40431e:	b8 00 00 00 00       	mov    $0x0,%eax
  404323:	e8 8f 10 00 00       	callq  4053b7 <gsi_get_saved_file>
  404328:	41 b8 17 01 00 00    	mov    $0x117,%r8d
  40432e:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404333:	48 89 da             	mov    %rbx,%rdx
  404336:	be 20 79 40 00       	mov    $0x407920,%esi
  40433b:	48 89 c7             	mov    %rax,%rdi
  40433e:	b8 00 00 00 00       	mov    $0x0,%eax
  404343:	e8 d8 10 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404348:	b8 01 00 00 00       	mov    $0x1,%eax
  40434d:	e9 e4 01 00 00       	jmpq   404536 <gsi_is_network_tcp_server_init+0x31d>
	}

	// Clear the field of last message
	p_this->s_last_msg = NULL;
  404352:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404356:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  40435d:	00 

	// Create Listen Socket, used to receive connections
    p_this->i_listen_fd = socket(AF_INET, SOCK_STREAM, 0);
  40435e:	ba 00 00 00 00       	mov    $0x0,%edx
  404363:	be 01 00 00 00       	mov    $0x1,%esi
  404368:	bf 02 00 00 00       	mov    $0x2,%edi
  40436d:	e8 8e d5 ff ff       	callq  401900 <socket@plt>
  404372:	89 c2                	mov    %eax,%edx
  404374:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404378:	89 50 18             	mov    %edx,0x18(%rax)
    if (0 > p_this->i_listen_fd)
  40437b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40437f:	8b 40 18             	mov    0x18(%rax),%eax
  404382:	85 c0                	test   %eax,%eax
  404384:	79 41                	jns    4043c7 <gsi_is_network_tcp_server_init+0x1ae>
    {
    	LOG_ERROR("socket failed");
  404386:	b8 00 00 00 00       	mov    $0x0,%eax
  40438b:	e8 ac 12 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404390:	48 89 c3             	mov    %rax,%rbx
  404393:	b8 00 00 00 00       	mov    $0x0,%eax
  404398:	e8 1a 10 00 00       	callq  4053b7 <gsi_get_saved_file>
  40439d:	41 b8 22 01 00 00    	mov    $0x122,%r8d
  4043a3:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4043a8:	48 89 da             	mov    %rbx,%rdx
  4043ab:	be f0 79 40 00       	mov    $0x4079f0,%esi
  4043b0:	48 89 c7             	mov    %rax,%rdi
  4043b3:	b8 00 00 00 00       	mov    $0x0,%eax
  4043b8:	e8 63 10 00 00       	callq  405420 <gsi_is_write_to_log>
    	return GSI_NET_RC_ERROR;
  4043bd:	b8 01 00 00 00       	mov    $0x1,%eax
  4043c2:	e9 6f 01 00 00       	jmpq   404536 <gsi_is_network_tcp_server_init+0x31d>
    }

    // Reuse local address
    int i_reuse_addr = GSI_IS_TRUE;
  4043c7:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%rbp)
    if(0 < setsockopt(p_this->i_listen_fd, SOL_SOCKET, SO_REUSEADDR, &i_reuse_addr, sizeof(int)))
  4043ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4043d2:	8b 40 18             	mov    0x18(%rax),%eax
  4043d5:	48 8d 55 e4          	lea    -0x1c(%rbp),%rdx
  4043d9:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  4043df:	48 89 d1             	mov    %rdx,%rcx
  4043e2:	ba 02 00 00 00       	mov    $0x2,%edx
  4043e7:	be 01 00 00 00       	mov    $0x1,%esi
  4043ec:	89 c7                	mov    %eax,%edi
  4043ee:	e8 9d d1 ff ff       	callq  401590 <setsockopt@plt>
  4043f3:	85 c0                	test   %eax,%eax
  4043f5:	7e 41                	jle    404438 <gsi_is_network_tcp_server_init+0x21f>
	{
		LOG_ERROR("cannot set socket options");
  4043f7:	b8 00 00 00 00       	mov    $0x0,%eax
  4043fc:	e8 3b 12 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404401:	48 89 c3             	mov    %rax,%rbx
  404404:	b8 00 00 00 00       	mov    $0x0,%eax
  404409:	e8 a9 0f 00 00       	callq  4053b7 <gsi_get_saved_file>
  40440e:	41 b8 2a 01 00 00    	mov    $0x12a,%r8d
  404414:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404419:	48 89 da             	mov    %rbx,%rdx
  40441c:	be 20 7a 40 00       	mov    $0x407a20,%esi
  404421:	48 89 c7             	mov    %rax,%rdi
  404424:	b8 00 00 00 00       	mov    $0x0,%eax
  404429:	e8 f2 0f 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  40442e:	b8 01 00 00 00       	mov    $0x1,%eax
  404433:	e9 fe 00 00 00       	jmpq   404536 <gsi_is_network_tcp_server_init+0x31d>
	}

    // Bind the socket fd to specific address
    if (0 > bind(p_this->i_listen_fd, (struct sockaddr*)(&p_this->serv_addr), sizeof(struct sockaddr)))
  404438:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40443c:	48 8d 48 2c          	lea    0x2c(%rax),%rcx
  404440:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404444:	8b 40 18             	mov    0x18(%rax),%eax
  404447:	ba 10 00 00 00       	mov    $0x10,%edx
  40444c:	48 89 ce             	mov    %rcx,%rsi
  40444f:	89 c7                	mov    %eax,%edi
  404451:	e8 9a d3 ff ff       	callq  4017f0 <bind@plt>
  404456:	85 c0                	test   %eax,%eax
  404458:	79 41                	jns    40449b <gsi_is_network_tcp_server_init+0x282>
    {
    	LOG_ERROR("bind failed");
  40445a:	b8 00 00 00 00       	mov    $0x0,%eax
  40445f:	e8 d8 11 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404464:	48 89 c3             	mov    %rax,%rbx
  404467:	b8 00 00 00 00       	mov    $0x0,%eax
  40446c:	e8 46 0f 00 00       	callq  4053b7 <gsi_get_saved_file>
  404471:	41 b8 31 01 00 00    	mov    $0x131,%r8d
  404477:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40447c:	48 89 da             	mov    %rbx,%rdx
  40447f:	be 60 7a 40 00       	mov    $0x407a60,%esi
  404484:	48 89 c7             	mov    %rax,%rdi
  404487:	b8 00 00 00 00       	mov    $0x0,%eax
  40448c:	e8 8f 0f 00 00       	callq  405420 <gsi_is_write_to_log>
    	return GSI_NET_RC_ERROR;
  404491:	b8 01 00 00 00       	mov    $0x1,%eax
  404496:	e9 9b 00 00 00       	jmpq   404536 <gsi_is_network_tcp_server_init+0x31d>
    }

    // Set socket to listen for connection requests
    if (0 > listen(p_this->i_listen_fd, GSI_IS_MAX_LISTEN))
  40449b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40449f:	8b 40 18             	mov    0x18(%rax),%eax
  4044a2:	be 0a 00 00 00       	mov    $0xa,%esi
  4044a7:	89 c7                	mov    %eax,%edi
  4044a9:	e8 22 d3 ff ff       	callq  4017d0 <listen@plt>
  4044ae:	85 c0                	test   %eax,%eax
  4044b0:	79 3e                	jns    4044f0 <gsi_is_network_tcp_server_init+0x2d7>
    {
    	LOG_ERROR("listen failed");
  4044b2:	b8 00 00 00 00       	mov    $0x0,%eax
  4044b7:	e8 80 11 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4044bc:	48 89 c3             	mov    %rax,%rbx
  4044bf:	b8 00 00 00 00       	mov    $0x0,%eax
  4044c4:	e8 ee 0e 00 00       	callq  4053b7 <gsi_get_saved_file>
  4044c9:	41 b8 38 01 00 00    	mov    $0x138,%r8d
  4044cf:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4044d4:	48 89 da             	mov    %rbx,%rdx
  4044d7:	be 90 7a 40 00       	mov    $0x407a90,%esi
  4044dc:	48 89 c7             	mov    %rax,%rdi
  4044df:	b8 00 00 00 00       	mov    $0x0,%eax
  4044e4:	e8 37 0f 00 00       	callq  405420 <gsi_is_write_to_log>
    	return GSI_NET_RC_ERROR;
  4044e9:	b8 01 00 00 00       	mov    $0x1,%eax
  4044ee:	eb 46                	jmp    404536 <gsi_is_network_tcp_server_init+0x31d>
    }

    LOG_INFO("server is listening on port %d", p_this->ui_port);
  4044f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4044f4:	8b 58 28             	mov    0x28(%rax),%ebx
  4044f7:	b8 00 00 00 00       	mov    $0x0,%eax
  4044fc:	e8 3b 11 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404501:	49 89 c4             	mov    %rax,%r12
  404504:	b8 00 00 00 00       	mov    $0x0,%eax
  404509:	e8 a9 0e 00 00       	callq  4053b7 <gsi_get_saved_file>
  40450e:	41 89 d9             	mov    %ebx,%r9d
  404511:	41 b8 3c 01 00 00    	mov    $0x13c,%r8d
  404517:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40451c:	4c 89 e2             	mov    %r12,%rdx
  40451f:	be c0 7a 40 00       	mov    $0x407ac0,%esi
  404524:	48 89 c7             	mov    %rax,%rdi
  404527:	b8 00 00 00 00       	mov    $0x0,%eax
  40452c:	e8 ef 0e 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  404531:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404536:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  40453a:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  404541:	00 00 
  404543:	74 05                	je     40454a <gsi_is_network_tcp_server_init+0x331>
  404545:	e8 b6 d0 ff ff       	callq  401600 <__stack_chk_fail@plt>
  40454a:	48 83 c4 20          	add    $0x20,%rsp
  40454e:	5b                   	pop    %rbx
  40454f:	41 5c                	pop    %r12
  404551:	5d                   	pop    %rbp
  404552:	c3                   	retq   

0000000000404553 <gsi_is_network_tcp_server_poll>:
	 * Parameter:   [in] struct gsi_net_tcp *p_this - pointer to structure TCP Server
	 * Return:		Success - GSI_NET_RC_HASDATA *OR* GSI_NET_RC_SUCCESS(non empty buffer)
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_server_poll(struct gsi_net_tcp *p_this)
{
  404553:	55                   	push   %rbp
  404554:	48 89 e5             	mov    %rsp,%rbp
  404557:	41 54                	push   %r12
  404559:	53                   	push   %rbx
  40455a:	48 83 ec 20          	sub    $0x20,%rsp
  40455e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	// Check input validation
	if (NULL == p_this)
  404562:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  404567:	75 41                	jne    4045aa <gsi_is_network_tcp_server_poll+0x57>
	{
		LOG_ERROR("invalid argument!");
  404569:	b8 00 00 00 00       	mov    $0x0,%eax
  40456e:	e8 c9 10 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404573:	48 89 c3             	mov    %rax,%rbx
  404576:	b8 00 00 00 00       	mov    $0x0,%eax
  40457b:	e8 37 0e 00 00       	callq  4053b7 <gsi_get_saved_file>
  404580:	41 b8 54 01 00 00    	mov    $0x154,%r8d
  404586:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40458b:	48 89 da             	mov    %rbx,%rdx
  40458e:	be 48 76 40 00       	mov    $0x407648,%esi
  404593:	48 89 c7             	mov    %rax,%rdi
  404596:	b8 00 00 00 00       	mov    $0x0,%eax
  40459b:	e8 80 0e 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  4045a0:	b8 01 00 00 00       	mov    $0x1,%eax
  4045a5:	e9 15 02 00 00       	jmpq   4047bf <gsi_is_network_tcp_server_poll+0x26c>
	}

	// Setup POLL for Listen FD (Server connection requests)
	p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].fd 	= p_this->i_listen_fd;
  4045aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4045ae:	8b 50 18             	mov    0x18(%rax),%edx
  4045b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4045b5:	89 50 3c             	mov    %edx,0x3c(%rax)
	p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].events = POLLIN;
  4045b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4045bc:	66 c7 40 40 01 00    	movw   $0x1,0x40(%rax)
	if (0 == p_this->i_listen_fd)
  4045c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4045c6:	8b 40 18             	mov    0x18(%rax),%eax
  4045c9:	85 c0                	test   %eax,%eax
  4045cb:	75 41                	jne    40460e <gsi_is_network_tcp_server_poll+0xbb>
	{
		LOG_ERROR("server not listen");
  4045cd:	b8 00 00 00 00       	mov    $0x0,%eax
  4045d2:	e8 65 10 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4045d7:	48 89 c3             	mov    %rax,%rbx
  4045da:	b8 00 00 00 00       	mov    $0x0,%eax
  4045df:	e8 d3 0d 00 00       	callq  4053b7 <gsi_get_saved_file>
  4045e4:	41 b8 5d 01 00 00    	mov    $0x15d,%r8d
  4045ea:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4045ef:	48 89 da             	mov    %rbx,%rdx
  4045f2:	be 00 7b 40 00       	mov    $0x407b00,%esi
  4045f7:	48 89 c7             	mov    %rax,%rdi
  4045fa:	b8 00 00 00 00       	mov    $0x0,%eax
  4045ff:	e8 1c 0e 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404604:	b8 01 00 00 00       	mov    $0x1,%eax
  404609:	e9 b1 01 00 00       	jmpq   4047bf <gsi_is_network_tcp_server_poll+0x26c>
	}

	// If Already connected, Setup POLL for Connection FD as well
	if (0 < p_this->i_connection_fd)
  40460e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404612:	8b 40 1c             	mov    0x1c(%rax),%eax
  404615:	85 c0                	test   %eax,%eax
  404617:	7e 18                	jle    404631 <gsi_is_network_tcp_server_poll+0xde>
	{
		p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].fd	 = p_this->i_connection_fd;
  404619:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40461d:	8b 50 1c             	mov    0x1c(%rax),%edx
  404620:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404624:	89 50 44             	mov    %edx,0x44(%rax)
		p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].events = POLLIN;
  404627:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40462b:	66 c7 40 48 01 00    	movw   $0x1,0x48(%rax)
	}

	// Start poll to alert ready fds
	int i_rc = poll(p_this->pfds, GSI_IS_MAX_CONN, GSI_IS_POLL_DELAY_MSECS);
  404631:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404635:	48 83 c0 3c          	add    $0x3c,%rax
  404639:	ba 10 27 00 00       	mov    $0x2710,%edx
  40463e:	be 02 00 00 00       	mov    $0x2,%esi
  404643:	48 89 c7             	mov    %rax,%rdi
  404646:	e8 95 d1 ff ff       	callq  4017e0 <poll@plt>
  40464b:	89 45 ec             	mov    %eax,-0x14(%rbp)

	switch (i_rc)
  40464e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  404651:	83 f8 08             	cmp    $0x8,%eax
  404654:	75 41                	jne    404697 <gsi_is_network_tcp_server_poll+0x144>
	{
		case POLLERR:
			LOG_ERROR("poll error!");
  404656:	b8 00 00 00 00       	mov    $0x0,%eax
  40465b:	e8 dc 0f 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404660:	48 89 c3             	mov    %rax,%rbx
  404663:	b8 00 00 00 00       	mov    $0x0,%eax
  404668:	e8 4a 0d 00 00       	callq  4053b7 <gsi_get_saved_file>
  40466d:	41 b8 6e 01 00 00    	mov    $0x16e,%r8d
  404673:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404678:	48 89 da             	mov    %rbx,%rdx
  40467b:	be 38 7b 40 00       	mov    $0x407b38,%esi
  404680:	48 89 c7             	mov    %rax,%rdi
  404683:	b8 00 00 00 00       	mov    $0x0,%eax
  404688:	e8 93 0d 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_NET_RC_ERROR;
  40468d:	b8 01 00 00 00       	mov    $0x1,%eax
  404692:	e9 28 01 00 00       	jmpq   4047bf <gsi_is_network_tcp_server_poll+0x26c>
		default:
			if (p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].revents & POLLIN)
  404697:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40469b:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  40469f:	98                   	cwtl   
  4046a0:	83 e0 01             	and    $0x1,%eax
  4046a3:	85 c0                	test   %eax,%eax
  4046a5:	0f 84 ae 00 00 00    	je     404759 <gsi_is_network_tcp_server_poll+0x206>
			{
				// Accept New Connection
				p_this->i_connection_fd = accept(p_this->i_listen_fd, (struct sockaddr*)NULL, NULL);
  4046ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4046af:	8b 40 18             	mov    0x18(%rax),%eax
  4046b2:	ba 00 00 00 00       	mov    $0x0,%edx
  4046b7:	be 00 00 00 00       	mov    $0x0,%esi
  4046bc:	89 c7                	mov    %eax,%edi
  4046be:	e8 8d d1 ff ff       	callq  401850 <accept@plt>
  4046c3:	89 c2                	mov    %eax,%edx
  4046c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4046c9:	89 50 1c             	mov    %edx,0x1c(%rax)
				if (0 > p_this->i_connection_fd)
  4046cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4046d0:	8b 40 1c             	mov    0x1c(%rax),%eax
  4046d3:	85 c0                	test   %eax,%eax
  4046d5:	79 41                	jns    404718 <gsi_is_network_tcp_server_poll+0x1c5>
				{
					LOG_ERROR("accept failed!");
  4046d7:	b8 00 00 00 00       	mov    $0x0,%eax
  4046dc:	e8 5b 0f 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4046e1:	48 89 c3             	mov    %rax,%rbx
  4046e4:	b8 00 00 00 00       	mov    $0x0,%eax
  4046e9:	e8 c9 0c 00 00       	callq  4053b7 <gsi_get_saved_file>
  4046ee:	41 b8 77 01 00 00    	mov    $0x177,%r8d
  4046f4:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4046f9:	48 89 da             	mov    %rbx,%rdx
  4046fc:	be 68 7b 40 00       	mov    $0x407b68,%esi
  404701:	48 89 c7             	mov    %rax,%rdi
  404704:	b8 00 00 00 00       	mov    $0x0,%eax
  404709:	e8 12 0d 00 00       	callq  405420 <gsi_is_write_to_log>
					return GSI_NET_RC_ERROR;
  40470e:	b8 01 00 00 00       	mov    $0x1,%eax
  404713:	e9 a7 00 00 00       	jmpq   4047bf <gsi_is_network_tcp_server_poll+0x26c>
				}
				LOG_INFO("new connection accepted on port %d", p_this->ui_port);
  404718:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40471c:	8b 58 28             	mov    0x28(%rax),%ebx
  40471f:	b8 00 00 00 00       	mov    $0x0,%eax
  404724:	e8 13 0f 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404729:	49 89 c4             	mov    %rax,%r12
  40472c:	b8 00 00 00 00       	mov    $0x0,%eax
  404731:	e8 81 0c 00 00       	callq  4053b7 <gsi_get_saved_file>
  404736:	41 89 d9             	mov    %ebx,%r9d
  404739:	41 b8 7a 01 00 00    	mov    $0x17a,%r8d
  40473f:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404744:	4c 89 e2             	mov    %r12,%rdx
  404747:	be 98 7b 40 00       	mov    $0x407b98,%esi
  40474c:	48 89 c7             	mov    %rax,%rdi
  40474f:	b8 00 00 00 00       	mov    $0x0,%eax
  404754:	e8 c7 0c 00 00       	callq  405420 <gsi_is_write_to_log>
			}

			if (p_this->i_connection_fd && (p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].revents & POLLIN))
  404759:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40475d:	8b 40 1c             	mov    0x1c(%rax),%eax
  404760:	85 c0                	test   %eax,%eax
  404762:	74 1e                	je     404782 <gsi_is_network_tcp_server_poll+0x22f>
  404764:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404768:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  40476c:	98                   	cwtl   
  40476d:	83 e0 01             	and    $0x1,%eax
  404770:	85 c0                	test   %eax,%eax
  404772:	74 0e                	je     404782 <gsi_is_network_tcp_server_poll+0x22f>
			{
				// Get Input from Channel
				return read_check_heartbeat(p_this);
  404774:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404778:	48 89 c7             	mov    %rax,%rdi
  40477b:	e8 ea 04 00 00       	callq  404c6a <read_check_heartbeat>
  404780:	eb 3d                	jmp    4047bf <gsi_is_network_tcp_server_poll+0x26c>
			}

			break;
  404782:	90                   	nop
	}

	LOG_INFO("server poll successfully");
  404783:	b8 00 00 00 00       	mov    $0x0,%eax
  404788:	e8 af 0e 00 00       	callq  40563c <gsi_is_gen_timestamp>
  40478d:	48 89 c3             	mov    %rax,%rbx
  404790:	b8 00 00 00 00       	mov    $0x0,%eax
  404795:	e8 1d 0c 00 00       	callq  4053b7 <gsi_get_saved_file>
  40479a:	41 b8 86 01 00 00    	mov    $0x186,%r8d
  4047a0:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4047a5:	48 89 da             	mov    %rbx,%rdx
  4047a8:	be e0 7b 40 00       	mov    $0x407be0,%esi
  4047ad:	48 89 c7             	mov    %rax,%rdi
  4047b0:	b8 00 00 00 00       	mov    $0x0,%eax
  4047b5:	e8 66 0c 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  4047ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4047bf:	48 83 c4 20          	add    $0x20,%rsp
  4047c3:	5b                   	pop    %rbx
  4047c4:	41 5c                	pop    %r12
  4047c6:	5d                   	pop    %rbp
  4047c7:	c3                   	retq   

00000000004047c8 <gsi_is_network_tcp_server_read>:
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure	- GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_server_read(struct gsi_net_tcp *p_this,
														 	   char* s_msg)
{
  4047c8:	55                   	push   %rbp
  4047c9:	48 89 e5             	mov    %rsp,%rbp
  4047cc:	53                   	push   %rbx
  4047cd:	48 83 ec 28          	sub    $0x28,%rsp
  4047d1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  4047d5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int i_count = 0;
  4047d9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	struct gsi_cs_tcp_message *p_msg = (struct gsi_cs_tcp_message *)s_msg;
  4047e0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4047e4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// Check input validation
	if ((NULL == p_this) || (NULL == p_msg))
  4047e8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  4047ed:	74 07                	je     4047f6 <gsi_is_network_tcp_server_read+0x2e>
  4047ef:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4047f4:	75 41                	jne    404837 <gsi_is_network_tcp_server_read+0x6f>
	{
		LOG_ERROR("invalid arguments!");
  4047f6:	b8 00 00 00 00       	mov    $0x0,%eax
  4047fb:	e8 3c 0e 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404800:	48 89 c3             	mov    %rax,%rbx
  404803:	b8 00 00 00 00       	mov    $0x0,%eax
  404808:	e8 aa 0b 00 00       	callq  4053b7 <gsi_get_saved_file>
  40480d:	41 b8 9d 01 00 00    	mov    $0x19d,%r8d
  404813:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404818:	48 89 da             	mov    %rbx,%rdx
  40481b:	be f8 76 40 00       	mov    $0x4076f8,%esi
  404820:	48 89 c7             	mov    %rax,%rdi
  404823:	b8 00 00 00 00       	mov    $0x0,%eax
  404828:	e8 f3 0b 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  40482d:	b8 01 00 00 00       	mov    $0x1,%eax
  404832:	e9 8c 01 00 00       	jmpq   4049c3 <gsi_is_network_tcp_server_read+0x1fb>
	}

	// Reset p_msg buffer
	memset(p_msg, 0, sizeof(struct gsi_cs_tcp_message));
  404837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40483b:	ba 18 00 00 00       	mov    $0x18,%edx
  404840:	be 00 00 00 00       	mov    $0x0,%esi
  404845:	48 89 c7             	mov    %rax,%rdi
  404848:	e8 33 ce ff ff       	callq  401680 <memset@plt>

	// Check if buffer is empty
	if (NULL == p_this->s_last_msg)
  40484d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404851:	48 8b 40 10          	mov    0x10(%rax),%rax
  404855:	48 85 c0             	test   %rax,%rax
  404858:	75 52                	jne    4048ac <gsi_is_network_tcp_server_read+0xe4>
	{
		if (GSI_NET_RC_ERROR == read_check_heartbeat(p_this))
  40485a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40485e:	48 89 c7             	mov    %rax,%rdi
  404861:	e8 04 04 00 00       	callq  404c6a <read_check_heartbeat>
  404866:	83 f8 01             	cmp    $0x1,%eax
  404869:	75 41                	jne    4048ac <gsi_is_network_tcp_server_read+0xe4>
		{
			LOG_ERROR("heartbeat failed");
  40486b:	b8 00 00 00 00       	mov    $0x0,%eax
  404870:	e8 c7 0d 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404875:	48 89 c3             	mov    %rax,%rbx
  404878:	b8 00 00 00 00       	mov    $0x0,%eax
  40487d:	e8 35 0b 00 00       	callq  4053b7 <gsi_get_saved_file>
  404882:	41 b8 a9 01 00 00    	mov    $0x1a9,%r8d
  404888:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40488d:	48 89 da             	mov    %rbx,%rdx
  404890:	be 20 7c 40 00       	mov    $0x407c20,%esi
  404895:	48 89 c7             	mov    %rax,%rdi
  404898:	b8 00 00 00 00       	mov    $0x0,%eax
  40489d:	e8 7e 0b 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_NET_RC_ERROR;
  4048a2:	b8 01 00 00 00       	mov    $0x1,%eax
  4048a7:	e9 17 01 00 00       	jmpq   4049c3 <gsi_is_network_tcp_server_read+0x1fb>
		}
	}

	// Read the data from the buffer of last message
	i_count = strlen(p_this->s_last_msg) + 1;
  4048ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4048b0:	48 8b 40 10          	mov    0x10(%rax),%rax
  4048b4:	48 89 c7             	mov    %rax,%rdi
  4048b7:	e8 34 cd ff ff       	callq  4015f0 <strlen@plt>
  4048bc:	83 c0 01             	add    $0x1,%eax
  4048bf:	89 45 e4             	mov    %eax,-0x1c(%rbp)

	// Allocate memory for s_message buffer
	p_msg->s_message = (char *)malloc(i_count);
  4048c2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  4048c5:	48 98                	cltq   
  4048c7:	48 89 c7             	mov    %rax,%rdi
  4048ca:	e8 e1 ce ff ff       	callq  4017b0 <malloc@plt>
  4048cf:	48 89 c2             	mov    %rax,%rdx
  4048d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4048d6:	48 89 50 10          	mov    %rdx,0x10(%rax)
	if (NULL == p_msg->s_message)
  4048da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4048de:	48 8b 40 10          	mov    0x10(%rax),%rax
  4048e2:	48 85 c0             	test   %rax,%rax
  4048e5:	75 41                	jne    404928 <gsi_is_network_tcp_server_read+0x160>
	{
		LOG_ERROR("memory allocation for s_message failed");
  4048e7:	b8 00 00 00 00       	mov    $0x0,%eax
  4048ec:	e8 4b 0d 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4048f1:	48 89 c3             	mov    %rax,%rbx
  4048f4:	b8 00 00 00 00       	mov    $0x0,%eax
  4048f9:	e8 b9 0a 00 00       	callq  4053b7 <gsi_get_saved_file>
  4048fe:	41 b8 b5 01 00 00    	mov    $0x1b5,%r8d
  404904:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404909:	48 89 da             	mov    %rbx,%rdx
  40490c:	be 58 7c 40 00       	mov    $0x407c58,%esi
  404911:	48 89 c7             	mov    %rax,%rdi
  404914:	b8 00 00 00 00       	mov    $0x0,%eax
  404919:	e8 02 0b 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  40491e:	b8 01 00 00 00       	mov    $0x1,%eax
  404923:	e9 9b 00 00 00       	jmpq   4049c3 <gsi_is_network_tcp_server_read+0x1fb>
	}

	// Copy the message content
	memcpy(p_msg->s_message, p_this->s_last_msg, i_count);
  404928:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  40492b:	48 63 d0             	movslq %eax,%rdx
  40492e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404932:	48 8b 48 10          	mov    0x10(%rax),%rcx
  404936:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40493a:	48 8b 40 10          	mov    0x10(%rax),%rax
  40493e:	48 89 ce             	mov    %rcx,%rsi
  404941:	48 89 c7             	mov    %rax,%rdi
  404944:	e8 07 ce ff ff       	callq  401750 <memcpy@plt>

	// Set message length
	p_msg->ui_len = i_count;
  404949:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  40494c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404950:	89 50 08             	mov    %edx,0x8(%rax)

	// Set message type
	p_msg->e_type_msg = GSI_REGULAR_MSG;
  404953:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404957:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)

	// Copy the content of ui_port
	p_msg->ui_port = p_this->ui_port;
  40495e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404962:	8b 50 28             	mov    0x28(%rax),%edx
  404965:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404969:	89 10                	mov    %edx,(%rax)

	// Reset the last message buffer for the next message
	free(p_this->s_last_msg);
  40496b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40496f:	48 8b 40 10          	mov    0x10(%rax),%rax
  404973:	48 89 c7             	mov    %rax,%rdi
  404976:	e8 a5 cb ff ff       	callq  401520 <free@plt>
	p_this->s_last_msg = NULL;
  40497b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40497f:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  404986:	00 

	LOG_INFO("server read new message");
  404987:	b8 00 00 00 00       	mov    $0x0,%eax
  40498c:	e8 ab 0c 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404991:	48 89 c3             	mov    %rax,%rbx
  404994:	b8 00 00 00 00       	mov    $0x0,%eax
  404999:	e8 19 0a 00 00       	callq  4053b7 <gsi_get_saved_file>
  40499e:	41 b8 c9 01 00 00    	mov    $0x1c9,%r8d
  4049a4:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4049a9:	48 89 da             	mov    %rbx,%rdx
  4049ac:	be a0 7c 40 00       	mov    $0x407ca0,%esi
  4049b1:	48 89 c7             	mov    %rax,%rdi
  4049b4:	b8 00 00 00 00       	mov    $0x0,%eax
  4049b9:	e8 62 0a 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  4049be:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4049c3:	48 83 c4 28          	add    $0x28,%rsp
  4049c7:	5b                   	pop    %rbx
  4049c8:	5d                   	pop    %rbp
  4049c9:	c3                   	retq   

00000000004049ca <gsi_is_network_tcp_server_cleanup>:
	 * Parameter:   [in] struct gsi_net_tcp *p_this - pointer to structure TCP Server
	 * Return:		Success - GSI_NET_RC_SUCCESS
	 * 				Failure - GSI_NET_RC_ERROR
#############################################################################*/
enum gsi_is_network_return_code gsi_is_network_tcp_server_cleanup(struct gsi_net_tcp *p_this)
{
  4049ca:	55                   	push   %rbp
  4049cb:	48 89 e5             	mov    %rsp,%rbp
  4049ce:	53                   	push   %rbx
  4049cf:	48 83 ec 18          	sub    $0x18,%rsp
  4049d3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == p_this)
  4049d7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4049dc:	75 41                	jne    404a1f <gsi_is_network_tcp_server_cleanup+0x55>
	{
		LOG_ERROR("invalid argument!");
  4049de:	b8 00 00 00 00       	mov    $0x0,%eax
  4049e3:	e8 54 0c 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4049e8:	48 89 c3             	mov    %rax,%rbx
  4049eb:	b8 00 00 00 00       	mov    $0x0,%eax
  4049f0:	e8 c2 09 00 00       	callq  4053b7 <gsi_get_saved_file>
  4049f5:	41 b8 d9 01 00 00    	mov    $0x1d9,%r8d
  4049fb:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404a00:	48 89 da             	mov    %rbx,%rdx
  404a03:	be 48 76 40 00       	mov    $0x407648,%esi
  404a08:	48 89 c7             	mov    %rax,%rdi
  404a0b:	b8 00 00 00 00       	mov    $0x0,%eax
  404a10:	e8 0b 0a 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404a15:	b8 01 00 00 00       	mov    $0x1,%eax
  404a1a:	e9 14 01 00 00       	jmpq   404b33 <gsi_is_network_tcp_server_cleanup+0x169>
	}

	// Close connection socket (if open)
	if (p_this->i_connection_fd)
  404a1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404a23:	8b 40 1c             	mov    0x1c(%rax),%eax
  404a26:	85 c0                	test   %eax,%eax
  404a28:	74 68                	je     404a92 <gsi_is_network_tcp_server_cleanup+0xc8>
	{
		if (0 > close(p_this->i_connection_fd))
  404a2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404a2e:	8b 40 1c             	mov    0x1c(%rax),%eax
  404a31:	89 c7                	mov    %eax,%edi
  404a33:	e8 58 cc ff ff       	callq  401690 <close@plt>
  404a38:	85 c0                	test   %eax,%eax
  404a3a:	79 41                	jns    404a7d <gsi_is_network_tcp_server_cleanup+0xb3>
		{
			LOG_ERROR("close connection fd failed");
  404a3c:	b8 00 00 00 00       	mov    $0x0,%eax
  404a41:	e8 f6 0b 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404a46:	48 89 c3             	mov    %rax,%rbx
  404a49:	b8 00 00 00 00       	mov    $0x0,%eax
  404a4e:	e8 64 09 00 00       	callq  4053b7 <gsi_get_saved_file>
  404a53:	41 b8 e2 01 00 00    	mov    $0x1e2,%r8d
  404a59:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404a5e:	48 89 da             	mov    %rbx,%rdx
  404a61:	be d8 7c 40 00       	mov    $0x407cd8,%esi
  404a66:	48 89 c7             	mov    %rax,%rdi
  404a69:	b8 00 00 00 00       	mov    $0x0,%eax
  404a6e:	e8 ad 09 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_NET_RC_ERROR;
  404a73:	b8 01 00 00 00       	mov    $0x1,%eax
  404a78:	e9 b6 00 00 00       	jmpq   404b33 <gsi_is_network_tcp_server_cleanup+0x169>
		}

		// Reset poll_fds array of connection type
		p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].fd	 = 0;
  404a7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404a81:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
		p_this->pfds[GSI_IS_POLL_SOCKET_CONNECT].events = 0;
  404a88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404a8c:	66 c7 40 48 00 00    	movw   $0x0,0x48(%rax)
	}

	// Close listen socket
	if (0 > close(p_this->i_listen_fd))
  404a92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404a96:	8b 40 18             	mov    0x18(%rax),%eax
  404a99:	89 c7                	mov    %eax,%edi
  404a9b:	e8 f0 cb ff ff       	callq  401690 <close@plt>
  404aa0:	85 c0                	test   %eax,%eax
  404aa2:	79 3e                	jns    404ae2 <gsi_is_network_tcp_server_cleanup+0x118>
	{
		LOG_ERROR("close listen fd failed");
  404aa4:	b8 00 00 00 00       	mov    $0x0,%eax
  404aa9:	e8 8e 0b 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404aae:	48 89 c3             	mov    %rax,%rbx
  404ab1:	b8 00 00 00 00       	mov    $0x0,%eax
  404ab6:	e8 fc 08 00 00       	callq  4053b7 <gsi_get_saved_file>
  404abb:	41 b8 ee 01 00 00    	mov    $0x1ee,%r8d
  404ac1:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404ac6:	48 89 da             	mov    %rbx,%rdx
  404ac9:	be 18 7d 40 00       	mov    $0x407d18,%esi
  404ace:	48 89 c7             	mov    %rax,%rdi
  404ad1:	b8 00 00 00 00       	mov    $0x0,%eax
  404ad6:	e8 45 09 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404adb:	b8 01 00 00 00       	mov    $0x1,%eax
  404ae0:	eb 51                	jmp    404b33 <gsi_is_network_tcp_server_cleanup+0x169>
	}

	// Reset poll_fds array of listen type
	p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].fd		= 0;
  404ae2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404ae6:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	p_this->pfds[GSI_IS_POLL_SOCKET_LISTEN].events	= 0;
  404aed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404af1:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)

	LOG_INFO("cleanup successfully\n");
  404af7:	b8 00 00 00 00       	mov    $0x0,%eax
  404afc:	e8 3b 0b 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404b01:	48 89 c3             	mov    %rax,%rbx
  404b04:	b8 00 00 00 00       	mov    $0x0,%eax
  404b09:	e8 a9 08 00 00       	callq  4053b7 <gsi_get_saved_file>
  404b0e:	41 b8 f6 01 00 00    	mov    $0x1f6,%r8d
  404b14:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404b19:	48 89 da             	mov    %rbx,%rdx
  404b1c:	be 50 7d 40 00       	mov    $0x407d50,%esi
  404b21:	48 89 c7             	mov    %rax,%rdi
  404b24:	b8 00 00 00 00       	mov    $0x0,%eax
  404b29:	e8 f2 08 00 00       	callq  405420 <gsi_is_write_to_log>
	return GSI_NET_RC_SUCCESS;
  404b2e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  404b33:	48 83 c4 18          	add    $0x18,%rsp
  404b37:	5b                   	pop    %rbx
  404b38:	5d                   	pop    %rbp
  404b39:	c3                   	retq   

0000000000404b3a <set_address_parameters>:
	 * Parameter:   [in] char* s_tcp_addr - address to connect to
	 * Return:		Success - char* - pointer to port as string
	 * 				Failure - NULL
#############################################################################*/
static char* set_address_parameters(struct gsi_net_tcp *p_this, char* s_tcp_addr)
{
  404b3a:	55                   	push   %rbp
  404b3b:	48 89 e5             	mov    %rsp,%rbp
  404b3e:	53                   	push   %rbx
  404b3f:	48 83 ec 28          	sub    $0x28,%rsp
  404b43:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  404b47:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Check input validation
	if ((NULL == p_this) || (NULL == s_tcp_addr))
  404b4b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  404b50:	74 07                	je     404b59 <set_address_parameters+0x1f>
  404b52:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  404b57:	75 41                	jne    404b9a <set_address_parameters+0x60>
	{
		LOG_ERROR("invalid arguments!");
  404b59:	b8 00 00 00 00       	mov    $0x0,%eax
  404b5e:	e8 d9 0a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404b63:	48 89 c3             	mov    %rax,%rbx
  404b66:	b8 00 00 00 00       	mov    $0x0,%eax
  404b6b:	e8 47 08 00 00       	callq  4053b7 <gsi_get_saved_file>
  404b70:	41 b8 0a 02 00 00    	mov    $0x20a,%r8d
  404b76:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404b7b:	48 89 da             	mov    %rbx,%rdx
  404b7e:	be f8 76 40 00       	mov    $0x4076f8,%esi
  404b83:	48 89 c7             	mov    %rax,%rdi
  404b86:	b8 00 00 00 00       	mov    $0x0,%eax
  404b8b:	e8 90 08 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  404b90:	b8 00 00 00 00       	mov    $0x0,%eax
  404b95:	e9 c9 00 00 00       	jmpq   404c63 <set_address_parameters+0x129>
	}

	// Update the field in the pointer
	p_this->s_tcp_addr = s_tcp_addr;
  404b9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404b9e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  404ba2:	48 89 10             	mov    %rdx,(%rax)

	// Find the ':' character inside the string
	char *s_port = strchr(p_this->s_tcp_addr, ':');
  404ba5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404ba9:	48 8b 00             	mov    (%rax),%rax
  404bac:	be 3a 00 00 00       	mov    $0x3a,%esi
  404bb1:	48 89 c7             	mov    %rax,%rdi
  404bb4:	e8 87 ca ff ff       	callq  401640 <strchr@plt>
  404bb9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == s_port)
  404bbd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  404bc2:	75 3e                	jne    404c02 <set_address_parameters+0xc8>
	{
		LOG_ERROR("The s_tcp_addr string doesn't contain ':'");
  404bc4:	b8 00 00 00 00       	mov    $0x0,%eax
  404bc9:	e8 6e 0a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404bce:	48 89 c3             	mov    %rax,%rbx
  404bd1:	b8 00 00 00 00       	mov    $0x0,%eax
  404bd6:	e8 dc 07 00 00       	callq  4053b7 <gsi_get_saved_file>
  404bdb:	41 b8 15 02 00 00    	mov    $0x215,%r8d
  404be1:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404be6:	48 89 da             	mov    %rbx,%rdx
  404be9:	be 88 7d 40 00       	mov    $0x407d88,%esi
  404bee:	48 89 c7             	mov    %rax,%rdi
  404bf1:	b8 00 00 00 00       	mov    $0x0,%eax
  404bf6:	e8 25 08 00 00       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  404bfb:	b8 00 00 00 00       	mov    $0x0,%eax
  404c00:	eb 61                	jmp    404c63 <set_address_parameters+0x129>
	}

	// Split Connect String <host_ip>:<port number> to Host IP Addr and Port Number
	*s_port = '\0';
  404c02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  404c06:	c6 00 00             	movb   $0x0,(%rax)
	++s_port;
  404c09:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)

	// Clear the Serv Addr (struct sockaddr_in)
	memset(&p_this->serv_addr, 0, sizeof(p_this->serv_addr));
  404c0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  404c12:	48 83 c0 2c          	add    $0x2c,%rax
  404c16:	ba 10 00 00 00       	mov    $0x10,%edx
  404c1b:	be 00 00 00 00       	mov    $0x0,%esi
  404c20:	48 89 c7             	mov    %rax,%rdi
  404c23:	e8 58 ca ff ff       	callq  401680 <memset@plt>

	LOG_INFO("set address parameters successfully");
  404c28:	b8 00 00 00 00       	mov    $0x0,%eax
  404c2d:	e8 0a 0a 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404c32:	48 89 c3             	mov    %rax,%rbx
  404c35:	b8 00 00 00 00       	mov    $0x0,%eax
  404c3a:	e8 78 07 00 00       	callq  4053b7 <gsi_get_saved_file>
  404c3f:	41 b8 20 02 00 00    	mov    $0x220,%r8d
  404c45:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404c4a:	48 89 da             	mov    %rbx,%rdx
  404c4d:	be d8 7d 40 00       	mov    $0x407dd8,%esi
  404c52:	48 89 c7             	mov    %rax,%rdi
  404c55:	b8 00 00 00 00       	mov    $0x0,%eax
  404c5a:	e8 c1 07 00 00       	callq  405420 <gsi_is_write_to_log>
	return s_port;
  404c5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  404c63:	48 83 c4 28          	add    $0x28,%rsp
  404c67:	5b                   	pop    %rbx
  404c68:	5d                   	pop    %rbp
  404c69:	c3                   	retq   

0000000000404c6a <read_check_heartbeat>:
	 * Parameter:   [in] struct gsi_net_tcp *p_this - pointer to structure TCP Server
	 * Return:		Success - GSI_NET_RC_HASDATA *OR* GSI_NET_RC_SUCCESS(non empty buffer)
	 * 				Failure - GSI_NET_RC_ERROR *OR* GSI_NET_RC_CONNECTERR
#############################################################################*/
static enum gsi_is_network_return_code read_check_heartbeat(struct gsi_net_tcp *p_this)
{
  404c6a:	55                   	push   %rbp
  404c6b:	48 89 e5             	mov    %rsp,%rbp
  404c6e:	41 54                	push   %r12
  404c70:	53                   	push   %rbx
  404c71:	48 83 ec 40          	sub    $0x40,%rsp
  404c75:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  404c79:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  404c80:	00 00 
  404c82:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  404c86:	31 c0                	xor    %eax,%eax
	struct gsi_cs_tcp_message msg;

	// Check input validation
	if (NULL == p_this)
  404c88:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  404c8d:	75 41                	jne    404cd0 <read_check_heartbeat+0x66>
	{
		LOG_ERROR("invalid argument!");
  404c8f:	b8 00 00 00 00       	mov    $0x0,%eax
  404c94:	e8 a3 09 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404c99:	48 89 c3             	mov    %rax,%rbx
  404c9c:	b8 00 00 00 00       	mov    $0x0,%eax
  404ca1:	e8 11 07 00 00       	callq  4053b7 <gsi_get_saved_file>
  404ca6:	41 b8 33 02 00 00    	mov    $0x233,%r8d
  404cac:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404cb1:	48 89 da             	mov    %rbx,%rdx
  404cb4:	be 48 76 40 00       	mov    $0x407648,%esi
  404cb9:	48 89 c7             	mov    %rax,%rdi
  404cbc:	b8 00 00 00 00       	mov    $0x0,%eax
  404cc1:	e8 5a 07 00 00       	callq  405420 <gsi_is_write_to_log>
		return GSI_NET_RC_ERROR;
  404cc6:	b8 01 00 00 00       	mov    $0x1,%eax
  404ccb:	e9 16 05 00 00       	jmpq   4051e6 <read_check_heartbeat+0x57c>
	}

	// Reset message
	memset(&msg, 0, sizeof(msg));
  404cd0:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  404cd4:	ba 18 00 00 00       	mov    $0x18,%edx
  404cd9:	be 00 00 00 00       	mov    $0x0,%esi
  404cde:	48 89 c7             	mov    %rax,%rdi
  404ce1:	e8 9a c9 ff ff       	callq  401680 <memset@plt>

	// Check if buffer is empty
	if (NULL == p_this->s_last_msg)
  404ce6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404cea:	48 8b 40 10          	mov    0x10(%rax),%rax
  404cee:	48 85 c0             	test   %rax,%rax
  404cf1:	0f 85 ea 04 00 00    	jne    4051e1 <read_check_heartbeat+0x577>
	{
		// Read part of the structure to know what is the message length
		int i_count = read(p_this->i_connection_fd, &msg, sizeof(msg) - sizeof(char *));
  404cf7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404cfb:	8b 40 1c             	mov    0x1c(%rax),%eax
  404cfe:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  404d02:	ba 10 00 00 00       	mov    $0x10,%edx
  404d07:	48 89 ce             	mov    %rcx,%rsi
  404d0a:	89 c7                	mov    %eax,%edi
  404d0c:	e8 8f c9 ff ff       	callq  4016a0 <read@plt>
  404d11:	89 45 cc             	mov    %eax,-0x34(%rbp)
		if (0 > i_count)
  404d14:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  404d18:	79 41                	jns    404d5b <read_check_heartbeat+0xf1>
		{
			LOG_ERROR("read failed");
  404d1a:	b8 00 00 00 00       	mov    $0x0,%eax
  404d1f:	e8 18 09 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404d24:	48 89 c3             	mov    %rax,%rbx
  404d27:	b8 00 00 00 00       	mov    $0x0,%eax
  404d2c:	e8 86 06 00 00       	callq  4053b7 <gsi_get_saved_file>
  404d31:	41 b8 41 02 00 00    	mov    $0x241,%r8d
  404d37:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404d3c:	48 89 da             	mov    %rbx,%rdx
  404d3f:	be 20 7e 40 00       	mov    $0x407e20,%esi
  404d44:	48 89 c7             	mov    %rax,%rdi
  404d47:	b8 00 00 00 00       	mov    $0x0,%eax
  404d4c:	e8 cf 06 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_NET_RC_ERROR;
  404d51:	b8 01 00 00 00       	mov    $0x1,%eax
  404d56:	e9 8b 04 00 00       	jmpq   4051e6 <read_check_heartbeat+0x57c>
		}
		else if (0 < i_count)
  404d5b:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  404d5f:	0f 8e 33 04 00 00    	jle    405198 <read_check_heartbeat+0x52e>
		{
			LOG_DEBUG("first read %d bytes from fd: %d", i_count, p_this->i_connection_fd);
  404d65:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404d69:	8b 58 1c             	mov    0x1c(%rax),%ebx
  404d6c:	b8 00 00 00 00       	mov    $0x0,%eax
  404d71:	e8 c6 08 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404d76:	49 89 c4             	mov    %rax,%r12
  404d79:	b8 00 00 00 00       	mov    $0x0,%eax
  404d7e:	e8 34 06 00 00       	callq  4053b7 <gsi_get_saved_file>
  404d83:	48 89 c7             	mov    %rax,%rdi
  404d86:	8b 45 cc             	mov    -0x34(%rbp),%eax
  404d89:	48 83 ec 08          	sub    $0x8,%rsp
  404d8d:	53                   	push   %rbx
  404d8e:	41 89 c1             	mov    %eax,%r9d
  404d91:	41 b8 46 02 00 00    	mov    $0x246,%r8d
  404d97:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404d9c:	4c 89 e2             	mov    %r12,%rdx
  404d9f:	be 50 7e 40 00       	mov    $0x407e50,%esi
  404da4:	b8 00 00 00 00       	mov    $0x0,%eax
  404da9:	e8 72 06 00 00       	callq  405420 <gsi_is_write_to_log>
  404dae:	48 83 c4 10          	add    $0x10,%rsp
			LOG_DEBUG("msg type: %d", msg.e_type_msg);
  404db2:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  404db5:	b8 00 00 00 00       	mov    $0x0,%eax
  404dba:	e8 7d 08 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404dbf:	49 89 c4             	mov    %rax,%r12
  404dc2:	b8 00 00 00 00       	mov    $0x0,%eax
  404dc7:	e8 eb 05 00 00       	callq  4053b7 <gsi_get_saved_file>
  404dcc:	41 89 d9             	mov    %ebx,%r9d
  404dcf:	41 b8 47 02 00 00    	mov    $0x247,%r8d
  404dd5:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404dda:	4c 89 e2             	mov    %r12,%rdx
  404ddd:	be 98 7e 40 00       	mov    $0x407e98,%esi
  404de2:	48 89 c7             	mov    %rax,%rdi
  404de5:	b8 00 00 00 00       	mov    $0x0,%eax
  404dea:	e8 31 06 00 00       	callq  405420 <gsi_is_write_to_log>
			LOG_DEBUG("msg length: %d", msg.ui_len);
  404def:	8b 5d d8             	mov    -0x28(%rbp),%ebx
  404df2:	b8 00 00 00 00       	mov    $0x0,%eax
  404df7:	e8 40 08 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404dfc:	49 89 c4             	mov    %rax,%r12
  404dff:	b8 00 00 00 00       	mov    $0x0,%eax
  404e04:	e8 ae 05 00 00       	callq  4053b7 <gsi_get_saved_file>
  404e09:	41 89 d9             	mov    %ebx,%r9d
  404e0c:	41 b8 48 02 00 00    	mov    $0x248,%r8d
  404e12:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404e17:	4c 89 e2             	mov    %r12,%rdx
  404e1a:	be c8 7e 40 00       	mov    $0x407ec8,%esi
  404e1f:	48 89 c7             	mov    %rax,%rdi
  404e22:	b8 00 00 00 00       	mov    $0x0,%eax
  404e27:	e8 f4 05 00 00       	callq  405420 <gsi_is_write_to_log>

			switch(msg.e_type_msg)
  404e2c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  404e2f:	83 f8 01             	cmp    $0x1,%eax
  404e32:	74 0e                	je     404e42 <read_check_heartbeat+0x1d8>
  404e34:	83 f8 02             	cmp    $0x2,%eax
  404e37:	0f 84 bb 02 00 00    	je     4050f8 <read_check_heartbeat+0x48e>
  404e3d:	e9 18 03 00 00       	jmpq   40515a <read_check_heartbeat+0x4f0>
			{
				case GSI_REGULAR_MSG:
				{
					if (GSI_IS_MAX_MSG_COUNT > p_this->i_msg_count)
  404e42:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404e46:	8b 40 24             	mov    0x24(%rax),%eax
  404e49:	83 f8 04             	cmp    $0x4,%eax
  404e4c:	0f 8f 3b 02 00 00    	jg     40508d <read_check_heartbeat+0x423>
					{
						// Allocate memory for last message (free it in server_read function)
						p_this->s_last_msg = (char *)calloc(msg.ui_len, sizeof(char));
  404e52:	8b 45 d8             	mov    -0x28(%rbp),%eax
  404e55:	89 c0                	mov    %eax,%eax
  404e57:	be 01 00 00 00       	mov    $0x1,%esi
  404e5c:	48 89 c7             	mov    %rax,%rdi
  404e5f:	e8 8c c8 ff ff       	callq  4016f0 <calloc@plt>
  404e64:	48 89 c2             	mov    %rax,%rdx
  404e67:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404e6b:	48 89 50 10          	mov    %rdx,0x10(%rax)
						if (NULL == p_this->s_last_msg)
  404e6f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404e73:	48 8b 40 10          	mov    0x10(%rax),%rax
  404e77:	48 85 c0             	test   %rax,%rax
  404e7a:	75 41                	jne    404ebd <read_check_heartbeat+0x253>
						{
							LOG_ERROR("memory allocation for last message failed");
  404e7c:	b8 00 00 00 00       	mov    $0x0,%eax
  404e81:	e8 b6 07 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404e86:	48 89 c3             	mov    %rax,%rbx
  404e89:	b8 00 00 00 00       	mov    $0x0,%eax
  404e8e:	e8 24 05 00 00       	callq  4053b7 <gsi_get_saved_file>
  404e93:	41 b8 54 02 00 00    	mov    $0x254,%r8d
  404e99:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404e9e:	48 89 da             	mov    %rbx,%rdx
  404ea1:	be f8 7e 40 00       	mov    $0x407ef8,%esi
  404ea6:	48 89 c7             	mov    %rax,%rdi
  404ea9:	b8 00 00 00 00       	mov    $0x0,%eax
  404eae:	e8 6d 05 00 00       	callq  405420 <gsi_is_write_to_log>
							return GSI_NET_RC_ERROR;
  404eb3:	b8 01 00 00 00       	mov    $0x1,%eax
  404eb8:	e9 29 03 00 00       	jmpq   4051e6 <read_check_heartbeat+0x57c>
						}

						// Read the message form the connection_fd
						int i_count = 0;
  404ebd:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
						int i_res = 0;
  404ec4:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
						int i_len = msg.ui_len;
  404ecb:	8b 45 d8             	mov    -0x28(%rbp),%eax
  404ece:	89 45 c8             	mov    %eax,-0x38(%rbp)
						while (0 != i_len)
  404ed1:	e9 99 00 00 00       	jmpq   404f6f <read_check_heartbeat+0x305>
						{
							i_count = read(p_this->i_connection_fd, p_this->s_last_msg + i_res, i_len);
  404ed6:	8b 45 c8             	mov    -0x38(%rbp),%eax
  404ed9:	48 63 d0             	movslq %eax,%rdx
  404edc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404ee0:	48 8b 48 10          	mov    0x10(%rax),%rcx
  404ee4:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  404ee7:	48 98                	cltq   
  404ee9:	48 01 c1             	add    %rax,%rcx
  404eec:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404ef0:	8b 40 1c             	mov    0x1c(%rax),%eax
  404ef3:	48 89 ce             	mov    %rcx,%rsi
  404ef6:	89 c7                	mov    %eax,%edi
  404ef8:	e8 a3 c7 ff ff       	callq  4016a0 <read@plt>
  404efd:	89 45 c0             	mov    %eax,-0x40(%rbp)
							if (0 > i_count)
  404f00:	83 7d c0 00          	cmpl   $0x0,-0x40(%rbp)
  404f04:	79 5d                	jns    404f63 <read_check_heartbeat+0x2f9>
							{
								free(p_this->s_last_msg);
  404f06:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404f0a:	48 8b 40 10          	mov    0x10(%rax),%rax
  404f0e:	48 89 c7             	mov    %rax,%rdi
  404f11:	e8 0a c6 ff ff       	callq  401520 <free@plt>
								p_this->s_last_msg = NULL;
  404f16:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404f1a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  404f21:	00 

								LOG_ERROR("read failed");
  404f22:	b8 00 00 00 00       	mov    $0x0,%eax
  404f27:	e8 10 07 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404f2c:	48 89 c3             	mov    %rax,%rbx
  404f2f:	b8 00 00 00 00       	mov    $0x0,%eax
  404f34:	e8 7e 04 00 00       	callq  4053b7 <gsi_get_saved_file>
  404f39:	41 b8 64 02 00 00    	mov    $0x264,%r8d
  404f3f:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404f44:	48 89 da             	mov    %rbx,%rdx
  404f47:	be 20 7e 40 00       	mov    $0x407e20,%esi
  404f4c:	48 89 c7             	mov    %rax,%rdi
  404f4f:	b8 00 00 00 00       	mov    $0x0,%eax
  404f54:	e8 c7 04 00 00       	callq  405420 <gsi_is_write_to_log>
								return GSI_NET_RC_ERROR;
  404f59:	b8 01 00 00 00       	mov    $0x1,%eax
  404f5e:	e9 83 02 00 00       	jmpq   4051e6 <read_check_heartbeat+0x57c>
							}

							i_res += i_count;
  404f63:	8b 45 c0             	mov    -0x40(%rbp),%eax
  404f66:	01 45 c4             	add    %eax,-0x3c(%rbp)
							i_len -= i_count;
  404f69:	8b 45 c0             	mov    -0x40(%rbp),%eax
  404f6c:	29 45 c8             	sub    %eax,-0x38(%rbp)

						// Read the message form the connection_fd
						int i_count = 0;
						int i_res = 0;
						int i_len = msg.ui_len;
						while (0 != i_len)
  404f6f:	83 7d c8 00          	cmpl   $0x0,-0x38(%rbp)
  404f73:	0f 85 5d ff ff ff    	jne    404ed6 <read_check_heartbeat+0x26c>

							i_res += i_count;
							i_len -= i_count;
						}

						LOG_DEBUG("second read %d bytes from fd: %d", i_count, p_this->i_connection_fd);
  404f79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404f7d:	8b 58 1c             	mov    0x1c(%rax),%ebx
  404f80:	b8 00 00 00 00       	mov    $0x0,%eax
  404f85:	e8 b2 06 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404f8a:	49 89 c4             	mov    %rax,%r12
  404f8d:	b8 00 00 00 00       	mov    $0x0,%eax
  404f92:	e8 20 04 00 00       	callq  4053b7 <gsi_get_saved_file>
  404f97:	48 89 c7             	mov    %rax,%rdi
  404f9a:	8b 45 c0             	mov    -0x40(%rbp),%eax
  404f9d:	48 83 ec 08          	sub    $0x8,%rsp
  404fa1:	53                   	push   %rbx
  404fa2:	41 89 c1             	mov    %eax,%r9d
  404fa5:	41 b8 6c 02 00 00    	mov    $0x26c,%r8d
  404fab:	b9 28 76 40 00       	mov    $0x407628,%ecx
  404fb0:	4c 89 e2             	mov    %r12,%rdx
  404fb3:	be 48 7f 40 00       	mov    $0x407f48,%esi
  404fb8:	b8 00 00 00 00       	mov    $0x0,%eax
  404fbd:	e8 5e 04 00 00       	callq  405420 <gsi_is_write_to_log>
  404fc2:	48 83 c4 10          	add    $0x10,%rsp
						LOG_DEBUG("is message complete: %d", (strlen(p_this->s_last_msg) == (i_count - 1)));
  404fc6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  404fca:	48 8b 40 10          	mov    0x10(%rax),%rax
  404fce:	48 89 c7             	mov    %rax,%rdi
  404fd1:	e8 1a c6 ff ff       	callq  4015f0 <strlen@plt>
  404fd6:	48 89 c2             	mov    %rax,%rdx
  404fd9:	8b 45 c0             	mov    -0x40(%rbp),%eax
  404fdc:	83 e8 01             	sub    $0x1,%eax
  404fdf:	48 98                	cltq   
  404fe1:	48 39 c2             	cmp    %rax,%rdx
  404fe4:	0f 94 c0             	sete   %al
  404fe7:	0f b6 d8             	movzbl %al,%ebx
  404fea:	b8 00 00 00 00       	mov    $0x0,%eax
  404fef:	e8 48 06 00 00       	callq  40563c <gsi_is_gen_timestamp>
  404ff4:	49 89 c4             	mov    %rax,%r12
  404ff7:	b8 00 00 00 00       	mov    $0x0,%eax
  404ffc:	e8 b6 03 00 00       	callq  4053b7 <gsi_get_saved_file>
  405001:	41 89 d9             	mov    %ebx,%r9d
  405004:	41 b8 6d 02 00 00    	mov    $0x26d,%r8d
  40500a:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40500f:	4c 89 e2             	mov    %r12,%rdx
  405012:	be 90 7f 40 00       	mov    $0x407f90,%esi
  405017:	48 89 c7             	mov    %rax,%rdi
  40501a:	b8 00 00 00 00       	mov    $0x0,%eax
  40501f:	e8 fc 03 00 00       	callq  405420 <gsi_is_write_to_log>

						// Update the message counter
						++(p_this->i_msg_count);
  405024:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405028:	8b 40 24             	mov    0x24(%rax),%eax
  40502b:	8d 50 01             	lea    0x1(%rax),%edx
  40502e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405032:	89 50 24             	mov    %edx,0x24(%rax)

						// Reset the heart beat in case that we are in the first message
						if (1 == p_this->i_msg_count)
  405035:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405039:	8b 40 24             	mov    0x24(%rax),%eax
  40503c:	83 f8 01             	cmp    $0x1,%eax
  40503f:	75 0b                	jne    40504c <read_check_heartbeat+0x3e2>
						{
							p_this->i_heartbeat = 0;
  405041:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405045:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%rax)
						}

						LOG_INFO("has data");
  40504c:	b8 00 00 00 00       	mov    $0x0,%eax
  405051:	e8 e6 05 00 00       	callq  40563c <gsi_is_gen_timestamp>
  405056:	48 89 c3             	mov    %rax,%rbx
  405059:	b8 00 00 00 00       	mov    $0x0,%eax
  40505e:	e8 54 03 00 00       	callq  4053b7 <gsi_get_saved_file>
  405063:	41 b8 78 02 00 00    	mov    $0x278,%r8d
  405069:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40506e:	48 89 da             	mov    %rbx,%rdx
  405071:	be d0 7f 40 00       	mov    $0x407fd0,%esi
  405076:	48 89 c7             	mov    %rax,%rdi
  405079:	b8 00 00 00 00       	mov    $0x0,%eax
  40507e:	e8 9d 03 00 00       	callq  405420 <gsi_is_write_to_log>
						return GSI_NET_RC_HASDATA;
  405083:	b8 80 00 00 00       	mov    $0x80,%eax
  405088:	e9 59 01 00 00       	jmpq   4051e6 <read_check_heartbeat+0x57c>
					}
					else if ((GSI_IS_MAX_MSG_COUNT <= p_this->i_msg_count) && (p_this->i_heartbeat != 1))
  40508d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405091:	8b 40 24             	mov    0x24(%rax),%eax
  405094:	83 f8 04             	cmp    $0x4,%eax
  405097:	0f 8e 43 01 00 00    	jle    4051e0 <read_check_heartbeat+0x576>
  40509d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4050a1:	8b 40 20             	mov    0x20(%rax),%eax
  4050a4:	83 f8 01             	cmp    $0x1,%eax
  4050a7:	0f 84 33 01 00 00    	je     4051e0 <read_check_heartbeat+0x576>
					{
						// Enter here if after MAX_MSG_COUNT messages there is no heart beat
						LOG_ERROR("client on port %d is not responding...closing connection", p_this->ui_port);
  4050ad:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4050b1:	8b 58 28             	mov    0x28(%rax),%ebx
  4050b4:	b8 00 00 00 00       	mov    $0x0,%eax
  4050b9:	e8 7e 05 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4050be:	49 89 c4             	mov    %rax,%r12
  4050c1:	b8 00 00 00 00       	mov    $0x0,%eax
  4050c6:	e8 ec 02 00 00       	callq  4053b7 <gsi_get_saved_file>
  4050cb:	41 89 d9             	mov    %ebx,%r9d
  4050ce:	41 b8 7e 02 00 00    	mov    $0x27e,%r8d
  4050d4:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4050d9:	4c 89 e2             	mov    %r12,%rdx
  4050dc:	be 00 80 40 00       	mov    $0x408000,%esi
  4050e1:	48 89 c7             	mov    %rax,%rdi
  4050e4:	b8 00 00 00 00       	mov    $0x0,%eax
  4050e9:	e8 32 03 00 00       	callq  405420 <gsi_is_write_to_log>
						return GSI_NET_RC_CONNECTERR;
  4050ee:	b8 04 00 00 00       	mov    $0x4,%eax
  4050f3:	e9 ee 00 00 00       	jmpq   4051e6 <read_check_heartbeat+0x57c>
					break;
				}
				case GSI_HEARTBEAT_MSG:
				{
					// Enter here if we got heart beat message
					++(p_this->i_heartbeat);
  4050f8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  4050fc:	8b 40 20             	mov    0x20(%rax),%eax
  4050ff:	8d 50 01             	lea    0x1(%rax),%edx
  405102:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405106:	89 50 20             	mov    %edx,0x20(%rax)

					// Reset message counter for next phase
					p_this->i_msg_count = 0;
  405109:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40510d:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%rax)
					LOG_INFO("got heartbeat from port: %d\n", p_this->ui_port);
  405114:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  405118:	8b 58 28             	mov    0x28(%rax),%ebx
  40511b:	b8 00 00 00 00       	mov    $0x0,%eax
  405120:	e8 17 05 00 00       	callq  40563c <gsi_is_gen_timestamp>
  405125:	49 89 c4             	mov    %rax,%r12
  405128:	b8 00 00 00 00       	mov    $0x0,%eax
  40512d:	e8 85 02 00 00       	callq  4053b7 <gsi_get_saved_file>
  405132:	41 89 d9             	mov    %ebx,%r9d
  405135:	41 b8 8a 02 00 00    	mov    $0x28a,%r8d
  40513b:	b9 28 76 40 00       	mov    $0x407628,%ecx
  405140:	4c 89 e2             	mov    %r12,%rdx
  405143:	be 60 80 40 00       	mov    $0x408060,%esi
  405148:	48 89 c7             	mov    %rax,%rdi
  40514b:	b8 00 00 00 00       	mov    $0x0,%eax
  405150:	e8 cb 02 00 00       	callq  405420 <gsi_is_write_to_log>

					break;
  405155:	e9 87 00 00 00       	jmpq   4051e1 <read_check_heartbeat+0x577>
				}
				default:
					LOG_ERROR("classified message failed");
  40515a:	b8 00 00 00 00       	mov    $0x0,%eax
  40515f:	e8 d8 04 00 00       	callq  40563c <gsi_is_gen_timestamp>
  405164:	48 89 c3             	mov    %rax,%rbx
  405167:	b8 00 00 00 00       	mov    $0x0,%eax
  40516c:	e8 46 02 00 00       	callq  4053b7 <gsi_get_saved_file>
  405171:	41 b8 8f 02 00 00    	mov    $0x28f,%r8d
  405177:	b9 28 76 40 00       	mov    $0x407628,%ecx
  40517c:	48 89 da             	mov    %rbx,%rdx
  40517f:	be a0 80 40 00       	mov    $0x4080a0,%esi
  405184:	48 89 c7             	mov    %rax,%rdi
  405187:	b8 00 00 00 00       	mov    $0x0,%eax
  40518c:	e8 8f 02 00 00       	callq  405420 <gsi_is_write_to_log>
					return GSI_NET_RC_ERROR;
  405191:	b8 01 00 00 00       	mov    $0x1,%eax
  405196:	eb 4e                	jmp    4051e6 <read_check_heartbeat+0x57c>

			} /* end  of switch case */
		}
		else // i_count = 0 so there is connection error
		{
			LOG_ERROR("client on port %d closed his channel", p_this->ui_port);
  405198:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40519c:	8b 58 28             	mov    0x28(%rax),%ebx
  40519f:	b8 00 00 00 00       	mov    $0x0,%eax
  4051a4:	e8 93 04 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4051a9:	49 89 c4             	mov    %rax,%r12
  4051ac:	b8 00 00 00 00       	mov    $0x0,%eax
  4051b1:	e8 01 02 00 00       	callq  4053b7 <gsi_get_saved_file>
  4051b6:	41 89 d9             	mov    %ebx,%r9d
  4051b9:	41 b8 96 02 00 00    	mov    $0x296,%r8d
  4051bf:	b9 28 76 40 00       	mov    $0x407628,%ecx
  4051c4:	4c 89 e2             	mov    %r12,%rdx
  4051c7:	be e0 80 40 00       	mov    $0x4080e0,%esi
  4051cc:	48 89 c7             	mov    %rax,%rdi
  4051cf:	b8 00 00 00 00       	mov    $0x0,%eax
  4051d4:	e8 47 02 00 00       	callq  405420 <gsi_is_write_to_log>
			return GSI_NET_RC_CONNECTERR;
  4051d9:	b8 04 00 00 00       	mov    $0x4,%eax
  4051de:	eb 06                	jmp    4051e6 <read_check_heartbeat+0x57c>
					{
						// Enter here if after MAX_MSG_COUNT messages there is no heart beat
						LOG_ERROR("client on port %d is not responding...closing connection", p_this->ui_port);
						return GSI_NET_RC_CONNECTERR;
					}
					break;
  4051e0:	90                   	nop
			LOG_ERROR("client on port %d closed his channel", p_this->ui_port);
			return GSI_NET_RC_CONNECTERR;
		}
	}

	return GSI_NET_RC_SUCCESS;
  4051e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4051e6:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  4051ea:	64 48 33 34 25 28 00 	xor    %fs:0x28,%rsi
  4051f1:	00 00 
  4051f3:	74 05                	je     4051fa <read_check_heartbeat+0x590>
  4051f5:	e8 06 c4 ff ff       	callq  401600 <__stack_chk_fail@plt>
  4051fa:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  4051fe:	5b                   	pop    %rbx
  4051ff:	41 5c                	pop    %r12
  405201:	5d                   	pop    %rbp
  405202:	c3                   	retq   

0000000000405203 <gsi_is_create_log_file>:
	 * 											  if NULL - set it to default path
	 * Return:		Success - FILE* - handler for the opened log_file
	 * 				Failure - NULL
#############################################################################*/
FILE* gsi_is_create_log_file(const char *s_log_name, char *s_log_path)
{
  405203:	55                   	push   %rbp
  405204:	48 89 e5             	mov    %rsp,%rbp
  405207:	48 81 ec 30 01 00 00 	sub    $0x130,%rsp
  40520e:	48 89 bd d8 fe ff ff 	mov    %rdi,-0x128(%rbp)
  405215:	48 89 b5 d0 fe ff ff 	mov    %rsi,-0x130(%rbp)
  40521c:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  405223:	00 00 
  405225:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  405229:	31 c0                	xor    %eax,%eax
	FILE* f_log = NULL;
  40522b:	48 c7 85 e8 fe ff ff 	movq   $0x0,-0x118(%rbp)
  405232:	00 00 00 00 
	char s_file_name[GSI_IS_LOG_MAX_FILE_NAME];
	int i_is_path_allocated = GSI_IS_LOG_FALSE;
  405236:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%rbp)
  40523d:	00 00 00 

	// Check input validation
	if (NULL == s_log_name)
  405240:	48 83 bd d8 fe ff ff 	cmpq   $0x0,-0x128(%rbp)
  405247:	00 
  405248:	75 14                	jne    40525e <gsi_is_create_log_file+0x5b>
	{
		printf("gsi_is_create_log_file: invalid argument\n");
  40524a:	bf 28 81 40 00       	mov    $0x408128,%edi
  40524f:	e8 2c c3 ff ff       	callq  401580 <puts@plt>
		return NULL;
  405254:	b8 00 00 00 00       	mov    $0x0,%eax
  405259:	e9 43 01 00 00       	jmpq   4053a1 <gsi_is_create_log_file+0x19e>
	}

	// Check if path is NULL - set it to default path
	if (NULL == s_log_path)
  40525e:	48 83 bd d0 fe ff ff 	cmpq   $0x0,-0x130(%rbp)
  405265:	00 
  405266:	75 4a                	jne    4052b2 <gsi_is_create_log_file+0xaf>
	{
		s_log_path = malloc(sizeof(GSI_IS_LOG_DEFAULT_PATH));
  405268:	bf 05 00 00 00       	mov    $0x5,%edi
  40526d:	e8 3e c5 ff ff       	callq  4017b0 <malloc@plt>
  405272:	48 89 85 d0 fe ff ff 	mov    %rax,-0x130(%rbp)
		if (NULL == s_log_path)
  405279:	48 83 bd d0 fe ff ff 	cmpq   $0x0,-0x130(%rbp)
  405280:	00 
  405281:	75 14                	jne    405297 <gsi_is_create_log_file+0x94>
		{
			printf("gsi_is_create_log_file: memory allocation for path failed\n");
  405283:	bf 58 81 40 00       	mov    $0x408158,%edi
  405288:	e8 f3 c2 ff ff       	callq  401580 <puts@plt>
			return NULL;
  40528d:	b8 00 00 00 00       	mov    $0x0,%eax
  405292:	e9 0a 01 00 00       	jmpq   4053a1 <gsi_is_create_log_file+0x19e>
		}

		i_is_path_allocated = GSI_IS_LOG_TRUE;
  405297:	c7 85 e4 fe ff ff 01 	movl   $0x1,-0x11c(%rbp)
  40529e:	00 00 00 
		strcpy(s_log_path, GSI_IS_LOG_DEFAULT_PATH);
  4052a1:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  4052a8:	c7 00 2f 74 6d 70    	movl   $0x706d742f,(%rax)
  4052ae:	c6 40 04 00          	movb   $0x0,0x4(%rax)
	}

	// Create thread pool from parameters in config file
	g_p_thread_pool = gsi_is_thread_pool_create(GSI_IS_LOG_THREADS, GSI_IS_LOG_QUEUE);
  4052b2:	be 64 00 00 00       	mov    $0x64,%esi
  4052b7:	bf 01 00 00 00       	mov    $0x1,%edi
  4052bc:	e8 4e 11 00 00       	callq  40640f <gsi_is_thread_pool_create>
  4052c1:	48 89 05 08 50 20 00 	mov    %rax,0x205008(%rip)        # 60a2d0 <g_p_thread_pool>
	if (NULL == g_p_thread_pool)
  4052c8:	48 8b 05 01 50 20 00 	mov    0x205001(%rip),%rax        # 60a2d0 <g_p_thread_pool>
  4052cf:	48 85 c0             	test   %rax,%rax
  4052d2:	75 14                	jne    4052e8 <gsi_is_create_log_file+0xe5>
	{
		printf("gsi_is_create_log_file: memory allocation failed\n");
  4052d4:	bf 98 81 40 00       	mov    $0x408198,%edi
  4052d9:	e8 a2 c2 ff ff       	callq  401580 <puts@plt>
		return NULL;
  4052de:	b8 00 00 00 00       	mov    $0x0,%eax
  4052e3:	e9 b9 00 00 00       	jmpq   4053a1 <gsi_is_create_log_file+0x19e>
	}

	// Build the log file name
	sprintf(s_file_name, "%s/%s-%s.log", s_log_path, s_log_name, gsi_is_gen_timestamp());
  4052e8:	b8 00 00 00 00       	mov    $0x0,%eax
  4052ed:	e8 4a 03 00 00       	callq  40563c <gsi_is_gen_timestamp>
  4052f2:	48 89 c6             	mov    %rax,%rsi
  4052f5:	48 8b 8d d8 fe ff ff 	mov    -0x128(%rbp),%rcx
  4052fc:	48 8b 95 d0 fe ff ff 	mov    -0x130(%rbp),%rdx
  405303:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  40530a:	49 89 f0             	mov    %rsi,%r8
  40530d:	be c9 81 40 00       	mov    $0x4081c9,%esi
  405312:	48 89 c7             	mov    %rax,%rdi
  405315:	b8 00 00 00 00       	mov    $0x0,%eax
  40531a:	e8 61 c5 ff ff       	callq  401880 <sprintf@plt>

	// Open file in append mode
	f_log = fopen(s_file_name, "a");
  40531f:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  405326:	be d6 81 40 00       	mov    $0x4081d6,%esi
  40532b:	48 89 c7             	mov    %rax,%rdi
  40532e:	e8 fd c4 ff ff       	callq  401830 <fopen@plt>
  405333:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	if (NULL == f_log)
  40533a:	48 83 bd e8 fe ff ff 	cmpq   $0x0,-0x118(%rbp)
  405341:	00 
  405342:	75 25                	jne    405369 <gsi_is_create_log_file+0x166>
	{
		printf("gsi_is_create_log_file: failed to open log file\n");
  405344:	bf d8 81 40 00       	mov    $0x4081d8,%edi
  405349:	e8 32 c2 ff ff       	callq  401580 <puts@plt>
		gsi_is_thread_pool_destroy(g_p_thread_pool, GSI_TP_DESTROY_IMMIDIATE);
  40534e:	48 8b 05 7b 4f 20 00 	mov    0x204f7b(%rip),%rax        # 60a2d0 <g_p_thread_pool>
  405355:	be 02 00 00 00       	mov    $0x2,%esi
  40535a:	48 89 c7             	mov    %rax,%rdi
  40535d:	e8 46 14 00 00       	callq  4067a8 <gsi_is_thread_pool_destroy>
		return NULL;
  405362:	b8 00 00 00 00       	mov    $0x0,%eax
  405367:	eb 38                	jmp    4053a1 <gsi_is_create_log_file+0x19e>
	}

	// Check if we allocated the path
	if (GSI_IS_LOG_TRUE == i_is_path_allocated)
  405369:	83 bd e4 fe ff ff 01 	cmpl   $0x1,-0x11c(%rbp)
  405370:	75 1a                	jne    40538c <gsi_is_create_log_file+0x189>
	{
		free (s_log_path);
  405372:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
  405379:	48 89 c7             	mov    %rax,%rdi
  40537c:	e8 9f c1 ff ff       	callq  401520 <free@plt>
		s_log_path = NULL;
  405381:	48 c7 85 d0 fe ff ff 	movq   $0x0,-0x130(%rbp)
  405388:	00 00 00 00 
	}

	// Initialize global pointer to log file
	g_p_log_file = f_log;
  40538c:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  405393:	48 89 05 3e 4f 20 00 	mov    %rax,0x204f3e(%rip)        # 60a2d8 <g_p_log_file>
	return f_log;
  40539a:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
}
  4053a1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4053a5:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
  4053ac:	00 00 
  4053ae:	74 05                	je     4053b5 <gsi_is_create_log_file+0x1b2>
  4053b0:	e8 4b c2 ff ff       	callq  401600 <__stack_chk_fail@plt>
  4053b5:	c9                   	leaveq 
  4053b6:	c3                   	retq   

00000000004053b7 <gsi_get_saved_file>:
	 * Description: return the FILE* pointer used to write to the log file
	 * Parameter:   [in] None
	 * Return:		FILE* - pointer to file
#############################################################################*/
FILE* gsi_get_saved_file()
{
  4053b7:	55                   	push   %rbp
  4053b8:	48 89 e5             	mov    %rsp,%rbp
	return g_p_log_file;
  4053bb:	48 8b 05 16 4f 20 00 	mov    0x204f16(%rip),%rax        # 60a2d8 <g_p_log_file>
}
  4053c2:	5d                   	pop    %rbp
  4053c3:	c3                   	retq   

00000000004053c4 <gsi_is_title_to_log>:
	 * Parameter:   [in] const char* s_title - content of the title to be logged
	 * Return:		Success - GSI_LOG_RC_SUCCESS
	 * 				Failure - GSI_LOG_RC_WRITE_ERROR *OR* GSI_LOG_RC_INVALID *OR* GSI_LOG_RC_MEMORY_ERROR
#############################################################################*/
enum gsi_is_log_rc gsi_is_title_to_log(FILE* f_log, const char* s_title)
{
  4053c4:	55                   	push   %rbp
  4053c5:	48 89 e5             	mov    %rsp,%rbp
  4053c8:	48 83 ec 10          	sub    $0x10,%rsp
  4053cc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  4053d0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check input validation
	if ((NULL == f_log) || (NULL == s_title))
  4053d4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  4053d9:	74 07                	je     4053e2 <gsi_is_title_to_log+0x1e>
  4053db:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  4053e0:	75 11                	jne    4053f3 <gsi_is_title_to_log+0x2f>
	{
		printf("gsi_is_title_to_log: invalid argumets\n");
  4053e2:	bf 08 82 40 00       	mov    $0x408208,%edi
  4053e7:	e8 94 c1 ff ff       	callq  401580 <puts@plt>
		return GSI_LOG_RC_INVALID;
  4053ec:	b8 04 00 00 00       	mov    $0x4,%eax
  4053f1:	eb 2b                	jmp    40541e <gsi_is_title_to_log+0x5a>
	}

	fprintf(f_log,
  4053f3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  4053f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4053fb:	be 30 82 40 00       	mov    $0x408230,%esi
  405400:	48 89 c7             	mov    %rax,%rdi
  405403:	b8 00 00 00 00       	mov    $0x0,%eax
  405408:	e8 13 c3 ff ff       	callq  401720 <fprintf@plt>
			"\n+++++++++++++++++++++++++++\n"
			"+\t[%s]   +\n"
			"+++++++++++++++++++++++++++\n",
			  s_title);
	fflush(f_log);
  40540d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  405411:	48 89 c7             	mov    %rax,%rdi
  405414:	e8 a7 c3 ff ff       	callq  4017c0 <fflush@plt>

	return GSI_LOG_RC_SUCCESS;
  405419:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40541e:	c9                   	leaveq 
  40541f:	c3                   	retq   

0000000000405420 <gsi_is_write_to_log>:
	 * Parameter:   [in] ... - List of parameters to be logged, must match s_format.
	 * Return:		Success - GSI_LOG_RC_SUCCESS
	 * 				Failure - GSI_LOG_RC_WRITE_ERROR *OR* GSI_LOG_RC_INVALID *OR* GSI_LOG_RC_MEMORY_ERROR
#############################################################################*/
enum gsi_is_log_rc gsi_is_write_to_log(FILE* f_log, const char* s_format, ...)
{
  405420:	55                   	push   %rbp
  405421:	48 89 e5             	mov    %rsp,%rbp
  405424:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  40542b:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  405432:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  405439:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  405440:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  405447:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  40544e:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  405455:	84 c0                	test   %al,%al
  405457:	74 20                	je     405479 <gsi_is_write_to_log+0x59>
  405459:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  40545d:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  405461:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  405465:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  405469:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  40546d:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  405471:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  405475:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  405479:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  405480:	00 00 
  405482:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  405489:	31 c0                	xor    %eax,%eax
	va_list optional_args;
	struct gsi_thread_args* p_thread_args = NULL;
  40548b:	48 c7 85 28 ff ff ff 	movq   $0x0,-0xd8(%rbp)
  405492:	00 00 00 00 

	// Check input validation
	if ((NULL == f_log) || (NULL == s_format))
  405496:	48 83 bd 18 ff ff ff 	cmpq   $0x0,-0xe8(%rbp)
  40549d:	00 
  40549e:	74 0a                	je     4054aa <gsi_is_write_to_log+0x8a>
  4054a0:	48 83 bd 10 ff ff ff 	cmpq   $0x0,-0xf0(%rbp)
  4054a7:	00 
  4054a8:	75 14                	jne    4054be <gsi_is_write_to_log+0x9e>
	{
		printf("gsi_is_write_to_log: invalid argumets\n");
  4054aa:	bf 78 82 40 00       	mov    $0x408278,%edi
  4054af:	e8 cc c0 ff ff       	callq  401580 <puts@plt>
		return GSI_LOG_RC_INVALID;
  4054b4:	b8 04 00 00 00       	mov    $0x4,%eax
  4054b9:	e9 06 01 00 00       	jmpq   4055c4 <gsi_is_write_to_log+0x1a4>
	}

	// Allocate memory for thread argument structure. free by running thread in thread_write_log().
	p_thread_args = (struct gsi_thread_args *)malloc(sizeof(struct gsi_thread_args));
  4054be:	bf 60 04 00 00       	mov    $0x460,%edi
  4054c3:	e8 e8 c2 ff ff       	callq  4017b0 <malloc@plt>
  4054c8:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	if (NULL == p_thread_args)
  4054cf:	48 83 bd 28 ff ff ff 	cmpq   $0x0,-0xd8(%rbp)
  4054d6:	00 
  4054d7:	75 0a                	jne    4054e3 <gsi_is_write_to_log+0xc3>
	{
		return GSI_LOG_RC_MEMORY_ERROR;
  4054d9:	b8 05 00 00 00       	mov    $0x5,%eax
  4054de:	e9 e1 00 00 00       	jmpq   4055c4 <gsi_is_write_to_log+0x1a4>
	}

	// Set fields
	p_thread_args->thread_id = pthread_self();
  4054e3:	e8 28 c3 ff ff       	callq  401810 <pthread_self@plt>
  4054e8:	48 89 c2             	mov    %rax,%rdx
  4054eb:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  4054f2:	48 89 10             	mov    %rdx,(%rax)
	p_thread_args->f_log = f_log;
  4054f5:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  4054fc:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  405503:	48 89 50 08          	mov    %rdx,0x8(%rax)

	// Reset s_message
	memset(p_thread_args->s_message, 0, sizeof(p_thread_args->s_message));
  405507:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  40550e:	48 83 c0 10          	add    $0x10,%rax
  405512:	ba 4c 04 00 00       	mov    $0x44c,%edx
  405517:	be 00 00 00 00       	mov    $0x0,%esi
  40551c:	48 89 c7             	mov    %rax,%rdi
  40551f:	e8 5c c1 ff ff       	callq  401680 <memset@plt>

	// Build message
	va_start(optional_args, s_format);
  405524:	c7 85 30 ff ff ff 10 	movl   $0x10,-0xd0(%rbp)
  40552b:	00 00 00 
  40552e:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  405535:	00 00 00 
  405538:	48 8d 45 10          	lea    0x10(%rbp),%rax
  40553c:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  405543:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  40554a:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	vsprintf(p_thread_args->s_message, s_format, optional_args);
  405551:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  405558:	48 8d 48 10          	lea    0x10(%rax),%rcx
  40555c:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  405563:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  40556a:	48 89 c6             	mov    %rax,%rsi
  40556d:	48 89 cf             	mov    %rcx,%rdi
  405570:	e8 8b c2 ff ff       	callq  401800 <vsprintf@plt>
	va_end(optional_args);

	// Add message work to Queue
	if (GSI_TP_RC_SUCCESS != gsi_is_thread_pool_add(g_p_thread_pool, thread_write_log, p_thread_args))
  405575:	48 8b 05 54 4d 20 00 	mov    0x204d54(%rip),%rax        # 60a2d0 <g_p_thread_pool>
  40557c:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  405583:	be de 56 40 00       	mov    $0x4056de,%esi
  405588:	48 89 c7             	mov    %rax,%rdi
  40558b:	e8 fb 10 00 00       	callq  40668b <gsi_is_thread_pool_add>
  405590:	85 c0                	test   %eax,%eax
  405592:	74 2b                	je     4055bf <gsi_is_write_to_log+0x19f>
	{
		if (NULL != p_thread_args)
  405594:	48 83 bd 28 ff ff ff 	cmpq   $0x0,-0xd8(%rbp)
  40559b:	00 
  40559c:	74 1a                	je     4055b8 <gsi_is_write_to_log+0x198>
		{
			free(p_thread_args);
  40559e:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  4055a5:	48 89 c7             	mov    %rax,%rdi
  4055a8:	e8 73 bf ff ff       	callq  401520 <free@plt>
			p_thread_args = NULL;
  4055ad:	48 c7 85 28 ff ff ff 	movq   $0x0,-0xd8(%rbp)
  4055b4:	00 00 00 00 
		}

		return GSI_LOG_RC_WRITE_ERROR;
  4055b8:	b8 03 00 00 00       	mov    $0x3,%eax
  4055bd:	eb 05                	jmp    4055c4 <gsi_is_write_to_log+0x1a4>
	}

	return GSI_LOG_RC_SUCCESS;
  4055bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4055c4:	48 8b 8d 48 ff ff ff 	mov    -0xb8(%rbp),%rcx
  4055cb:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  4055d2:	00 00 
  4055d4:	74 05                	je     4055db <gsi_is_write_to_log+0x1bb>
  4055d6:	e8 25 c0 ff ff       	callq  401600 <__stack_chk_fail@plt>
  4055db:	c9                   	leaveq 
  4055dc:	c3                   	retq   

00000000004055dd <gsi_is_close_log>:
	 * Parameter:   [in] FILE* f_log - Handler to the log file.
	 * Return:		Success - GSI_LOG_RC_SUCCESS
	 * 				Failure - GSI_LOG_RC_CLOSE_ERROR *OR* GSI_LOG_RC_INVALID
#############################################################################*/
enum gsi_is_log_rc gsi_is_close_log(FILE* f_log)
{
  4055dd:	55                   	push   %rbp
  4055de:	48 89 e5             	mov    %rsp,%rbp
  4055e1:	48 83 ec 10          	sub    $0x10,%rsp
  4055e5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Check input validation
	if (NULL == f_log)
  4055e9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  4055ee:	75 07                	jne    4055f7 <gsi_is_close_log+0x1a>
	{
		return GSI_LOG_RC_INVALID;
  4055f0:	b8 04 00 00 00       	mov    $0x4,%eax
  4055f5:	eb 43                	jmp    40563a <gsi_is_close_log+0x5d>
	}

	// Destroy thread pool gracefully to write all the messages in the Queue
	gsi_is_thread_pool_destroy(g_p_thread_pool, GSI_TP_DESTROY_GRACEFUL);
  4055f7:	48 8b 05 d2 4c 20 00 	mov    0x204cd2(%rip),%rax        # 60a2d0 <g_p_thread_pool>
  4055fe:	be 01 00 00 00       	mov    $0x1,%esi
  405603:	48 89 c7             	mov    %rax,%rdi
  405606:	e8 9d 11 00 00       	callq  4067a8 <gsi_is_thread_pool_destroy>

	// Close the log file
	if (0 != fclose(f_log))
  40560b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40560f:	48 89 c7             	mov    %rax,%rdi
  405612:	e8 b9 bf ff ff       	callq  4015d0 <fclose@plt>
  405617:	85 c0                	test   %eax,%eax
  405619:	74 07                	je     405622 <gsi_is_close_log+0x45>
	{
		return GSI_LOG_RC_CLOSE_ERROR;
  40561b:	b8 02 00 00 00       	mov    $0x2,%eax
  405620:	eb 18                	jmp    40563a <gsi_is_close_log+0x5d>
	}

	// Reset pointer
	f_log = NULL;
  405622:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  405629:	00 

	// Reset global pointer
	g_p_log_file = NULL;
  40562a:	48 c7 05 a3 4c 20 00 	movq   $0x0,0x204ca3(%rip)        # 60a2d8 <g_p_log_file>
  405631:	00 00 00 00 

	return GSI_LOG_RC_SUCCESS;
  405635:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40563a:	c9                   	leaveq 
  40563b:	c3                   	retq   

000000000040563c <gsi_is_gen_timestamp>:
	 * Description: Generate time stamp as string : "YYYY-MM-DD-HH:MM:SS"
	 * Parameter:   [in] None
	 * Return:		char* - time stamp as string
#############################################################################*/
char* gsi_is_gen_timestamp()
{
  40563c:	55                   	push   %rbp
  40563d:	48 89 e5             	mov    %rsp,%rbp
  405640:	48 83 ec 20          	sub    $0x20,%rsp
  405644:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40564b:	00 00 
  40564d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  405651:	31 c0                	xor    %eax,%eax
	static char s_time_stamp[GSI_IS_LOG_TIME_STAMP_LEN];

	time_t t = time(NULL);
  405653:	bf 00 00 00 00       	mov    $0x0,%edi
  405658:	e8 13 c1 ff ff       	callq  401770 <time@plt>
  40565d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	struct tm *curr_time = localtime(&t);
  405661:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  405665:	48 89 c7             	mov    %rax,%rdi
  405668:	e8 d3 be ff ff       	callq  401540 <localtime@plt>
  40566d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	sprintf(s_time_stamp, "%04d-%02d-%02d-%02d:%02d:%02d",
  405671:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  405675:	8b 10                	mov    (%rax),%edx
  405677:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40567b:	8b 40 04             	mov    0x4(%rax),%eax
  40567e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  405682:	44 8b 49 08          	mov    0x8(%rcx),%r9d
  405686:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  40568a:	44 8b 41 0c          	mov    0xc(%rcx),%r8d
			curr_time->tm_year + 1900,
			curr_time->tm_mon + 1,
  40568e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  405692:	8b 49 10             	mov    0x10(%rcx),%ecx
	static char s_time_stamp[GSI_IS_LOG_TIME_STAMP_LEN];

	time_t t = time(NULL);
	struct tm *curr_time = localtime(&t);

	sprintf(s_time_stamp, "%04d-%02d-%02d-%02d:%02d:%02d",
  405695:	8d 79 01             	lea    0x1(%rcx),%edi
			curr_time->tm_year + 1900,
  405698:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  40569c:	8b 49 14             	mov    0x14(%rcx),%ecx
	static char s_time_stamp[GSI_IS_LOG_TIME_STAMP_LEN];

	time_t t = time(NULL);
	struct tm *curr_time = localtime(&t);

	sprintf(s_time_stamp, "%04d-%02d-%02d-%02d:%02d:%02d",
  40569f:	8d b1 6c 07 00 00    	lea    0x76c(%rcx),%esi
  4056a5:	52                   	push   %rdx
  4056a6:	50                   	push   %rax
  4056a7:	89 f9                	mov    %edi,%ecx
  4056a9:	89 f2                	mov    %esi,%edx
  4056ab:	be 9e 82 40 00       	mov    $0x40829e,%esi
  4056b0:	bf e0 a2 60 00       	mov    $0x60a2e0,%edi
  4056b5:	b8 00 00 00 00       	mov    $0x0,%eax
  4056ba:	e8 c1 c1 ff ff       	callq  401880 <sprintf@plt>
  4056bf:	48 83 c4 10          	add    $0x10,%rsp
			curr_time->tm_mday,
			curr_time->tm_hour,
			curr_time->tm_min,
			curr_time->tm_sec);

	return s_time_stamp;
  4056c3:	b8 e0 a2 60 00       	mov    $0x60a2e0,%eax
}
  4056c8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4056cc:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
  4056d3:	00 00 
  4056d5:	74 05                	je     4056dc <gsi_is_gen_timestamp+0xa0>
  4056d7:	e8 24 bf ff ff       	callq  401600 <__stack_chk_fail@plt>
  4056dc:	c9                   	leaveq 
  4056dd:	c3                   	retq   

00000000004056de <thread_write_log>:
	 * 				Must free the s_message field that allocated by the calling function
	 * Parameter:   [in] void* p_args - pointer to struct gsi_thread_args
	 * Return:		Always NULL
#############################################################################*/
static void* thread_write_log(void* p_args)
{
  4056de:	55                   	push   %rbp
  4056df:	48 89 e5             	mov    %rsp,%rbp
  4056e2:	48 83 ec 20          	sub    $0x20,%rsp
  4056e6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	struct gsi_thread_args* p_thread_args = (struct gsi_thread_args*)p_args;
  4056ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4056ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	// Check input validation
	if (NULL == p_args)
  4056f2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4056f7:	75 11                	jne    40570a <thread_write_log+0x2c>
	{
		printf("p_args is NULL\n");
  4056f9:	bf bc 82 40 00       	mov    $0x4082bc,%edi
  4056fe:	e8 7d be ff ff       	callq  401580 <puts@plt>
		return NULL;
  405703:	b8 00 00 00 00       	mov    $0x0,%eax
  405708:	eb 76                	jmp    405780 <thread_write_log+0xa2>
	}

	do
	{
		if (NULL == p_thread_args->f_log)
  40570a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40570e:	48 8b 40 08          	mov    0x8(%rax),%rax
  405712:	48 85 c0             	test   %rax,%rax
  405715:	75 0c                	jne    405723 <thread_write_log+0x45>
		{
			printf("f_log is NULL\n");
  405717:	bf cb 82 40 00       	mov    $0x4082cb,%edi
  40571c:	e8 5f be ff ff       	callq  401580 <puts@plt>
			break;
  405721:	eb 44                	jmp    405767 <thread_write_log+0x89>
		}

		if (NULL == p_thread_args->s_message)
  405723:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  405727:	48 83 c0 10          	add    $0x10,%rax
  40572b:	48 85 c0             	test   %rax,%rax
  40572e:	75 0c                	jne    40573c <thread_write_log+0x5e>
		{
			printf("s_message is NULL\n");
  405730:	bf d9 82 40 00       	mov    $0x4082d9,%edi
  405735:	e8 46 be ff ff       	callq  401580 <puts@plt>
			break;
  40573a:	eb 2b                	jmp    405767 <thread_write_log+0x89>
		}

		// Write the message into log file
		fputs(p_thread_args->s_message, p_thread_args->f_log);
  40573c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  405740:	48 8b 40 08          	mov    0x8(%rax),%rax
  405744:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  405748:	48 83 c2 10          	add    $0x10,%rdx
  40574c:	48 89 c6             	mov    %rax,%rsi
  40574f:	48 89 d7             	mov    %rdx,%rdi
  405752:	e8 19 bf ff ff       	callq  401670 <fputs@plt>
		fflush(p_thread_args->f_log);
  405757:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40575b:	48 8b 40 08          	mov    0x8(%rax),%rax
  40575f:	48 89 c7             	mov    %rax,%rdi
  405762:	e8 59 c0 ff ff       	callq  4017c0 <fflush@plt>
	}
	while (0);

	free(p_args);
  405767:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40576b:	48 89 c7             	mov    %rax,%rdi
  40576e:	e8 ad bd ff ff       	callq  401520 <free@plt>
	p_args = NULL;
  405773:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  40577a:	00 

	return NULL;
  40577b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  405780:	c9                   	leaveq 
  405781:	c3                   	retq   

0000000000405782 <gsi_parse_json_config_open>:
	 * Parameter:   [in] char* s_config_file - configuration file to open
	 * Return:		Success - pointer to open file
	 * 				Failure - NULL
#############################################################################*/
FILE* gsi_parse_json_config_open(char* s_config_file)
{
  405782:	55                   	push   %rbp
  405783:	48 89 e5             	mov    %rsp,%rbp
  405786:	53                   	push   %rbx
  405787:	48 83 ec 28          	sub    $0x28,%rsp
  40578b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	FILE* f_config = NULL;
  40578f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  405796:	00 

	// Check input validation
	if (NULL == s_config_file)
  405797:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  40579c:	75 3e                	jne    4057dc <gsi_parse_json_config_open+0x5a>
	{
		LOG_ERROR("invalid configuration file");
  40579e:	b8 00 00 00 00       	mov    $0x0,%eax
  4057a3:	e8 94 fe ff ff       	callq  40563c <gsi_is_gen_timestamp>
  4057a8:	48 89 c3             	mov    %rax,%rbx
  4057ab:	b8 00 00 00 00       	mov    $0x0,%eax
  4057b0:	e8 02 fc ff ff       	callq  4053b7 <gsi_get_saved_file>
  4057b5:	41 b8 46 00 00 00    	mov    $0x46,%r8d
  4057bb:	b9 70 83 40 00       	mov    $0x408370,%ecx
  4057c0:	48 89 da             	mov    %rbx,%rdx
  4057c3:	be 90 83 40 00       	mov    $0x408390,%esi
  4057c8:	48 89 c7             	mov    %rax,%rdi
  4057cb:	b8 00 00 00 00       	mov    $0x0,%eax
  4057d0:	e8 4b fc ff ff       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  4057d5:	b8 00 00 00 00       	mov    $0x0,%eax
  4057da:	eb 65                	jmp    405841 <gsi_parse_json_config_open+0xbf>
	}

	// Open the configuration file
	f_config = fopen(s_config_file, "r");
  4057dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4057e0:	be cc 83 40 00       	mov    $0x4083cc,%esi
  4057e5:	48 89 c7             	mov    %rax,%rdi
  4057e8:	e8 43 c0 ff ff       	callq  401830 <fopen@plt>
  4057ed:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (NULL == f_config)
  4057f1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4057f6:	75 45                	jne    40583d <gsi_parse_json_config_open+0xbb>
	{
		LOG_ERROR("failed to open: %s", s_config_file);
  4057f8:	b8 00 00 00 00       	mov    $0x0,%eax
  4057fd:	e8 3a fe ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405802:	48 89 c3             	mov    %rax,%rbx
  405805:	b8 00 00 00 00       	mov    $0x0,%eax
  40580a:	e8 a8 fb ff ff       	callq  4053b7 <gsi_get_saved_file>
  40580f:	48 89 c7             	mov    %rax,%rdi
  405812:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405816:	49 89 c1             	mov    %rax,%r9
  405819:	41 b8 4e 00 00 00    	mov    $0x4e,%r8d
  40581f:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405824:	48 89 da             	mov    %rbx,%rdx
  405827:	be d0 83 40 00       	mov    $0x4083d0,%esi
  40582c:	b8 00 00 00 00       	mov    $0x0,%eax
  405831:	e8 ea fb ff ff       	callq  405420 <gsi_is_write_to_log>
		return NULL;
  405836:	b8 00 00 00 00       	mov    $0x0,%eax
  40583b:	eb 04                	jmp    405841 <gsi_parse_json_config_open+0xbf>
	}

	return f_config;
  40583d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  405841:	48 83 c4 28          	add    $0x28,%rsp
  405845:	5b                   	pop    %rbx
  405846:	5d                   	pop    %rbp
  405847:	c3                   	retq   

0000000000405848 <gsi_parse_json_config_close>:
	 * Parameter:   [in] FILE* f_config - pointer to open file to be closed
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_CLOSE_ERR *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
enum gsi_prase_json_config_rc gsi_parse_json_config_close(FILE* f_config)
{
  405848:	55                   	push   %rbp
  405849:	48 89 e5             	mov    %rsp,%rbp
  40584c:	53                   	push   %rbx
  40584d:	48 83 ec 18          	sub    $0x18,%rsp
  405851:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Check input validation
	if (NULL == f_config)
  405855:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  40585a:	75 3e                	jne    40589a <gsi_parse_json_config_close+0x52>
	{
		LOG_ERROR("invalid argument");
  40585c:	b8 00 00 00 00       	mov    $0x0,%eax
  405861:	e8 d6 fd ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405866:	48 89 c3             	mov    %rax,%rbx
  405869:	b8 00 00 00 00       	mov    $0x0,%eax
  40586e:	e8 44 fb ff ff       	callq  4053b7 <gsi_get_saved_file>
  405873:	41 b8 61 00 00 00    	mov    $0x61,%r8d
  405879:	b9 70 83 40 00       	mov    $0x408370,%ecx
  40587e:	48 89 da             	mov    %rbx,%rdx
  405881:	be 08 84 40 00       	mov    $0x408408,%esi
  405886:	48 89 c7             	mov    %rax,%rdi
  405889:	b8 00 00 00 00       	mov    $0x0,%eax
  40588e:	e8 8d fb ff ff       	callq  405420 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  405893:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  405898:	eb 53                	jmp    4058ed <gsi_parse_json_config_close+0xa5>
	}

	// Close configuration file
	if (0 != fclose(f_config))
  40589a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40589e:	48 89 c7             	mov    %rax,%rdi
  4058a1:	e8 2a bd ff ff       	callq  4015d0 <fclose@plt>
  4058a6:	85 c0                	test   %eax,%eax
  4058a8:	74 3e                	je     4058e8 <gsi_parse_json_config_close+0xa0>
	{
		LOG_ERROR("failed to close configuration file");
  4058aa:	b8 00 00 00 00       	mov    $0x0,%eax
  4058af:	e8 88 fd ff ff       	callq  40563c <gsi_is_gen_timestamp>
  4058b4:	48 89 c3             	mov    %rax,%rbx
  4058b7:	b8 00 00 00 00       	mov    $0x0,%eax
  4058bc:	e8 f6 fa ff ff       	callq  4053b7 <gsi_get_saved_file>
  4058c1:	41 b8 68 00 00 00    	mov    $0x68,%r8d
  4058c7:	b9 70 83 40 00       	mov    $0x408370,%ecx
  4058cc:	48 89 da             	mov    %rbx,%rdx
  4058cf:	be 40 84 40 00       	mov    $0x408440,%esi
  4058d4:	48 89 c7             	mov    %rax,%rdi
  4058d7:	b8 00 00 00 00       	mov    $0x0,%eax
  4058dc:	e8 3f fb ff ff       	callq  405420 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_CLOSE_ERR;
  4058e1:	b8 02 00 00 00       	mov    $0x2,%eax
  4058e6:	eb 05                	jmp    4058ed <gsi_parse_json_config_close+0xa5>
	}

	return GSI_PARSE_JSON_CONFIG_SUCCESS;
  4058e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4058ed:	48 83 c4 18          	add    $0x18,%rsp
  4058f1:	5b                   	pop    %rbx
  4058f2:	5d                   	pop    %rbp
  4058f3:	c3                   	retq   

00000000004058f4 <gsi_parse_json_config_read_line>:
	 * Parameter:   [out] char* s_value - buffer to get the value of the parameter
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_READ_ERR *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
enum gsi_prase_json_config_rc gsi_parse_json_config_read_line(FILE* f_config, char* s_key, char* s_value)
{
  4058f4:	55                   	push   %rbp
  4058f5:	48 89 e5             	mov    %rsp,%rbp
  4058f8:	53                   	push   %rbx
  4058f9:	48 81 ec 48 01 00 00 	sub    $0x148,%rsp
  405900:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  405907:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
  40590e:	48 89 95 b8 fe ff ff 	mov    %rdx,-0x148(%rbp)
  405915:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  40591c:	00 00 
  40591e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  405922:	31 c0                	xor    %eax,%eax
	char s_line[GSI_PARSE_JSON_CONFIG_MAX_LINE];
	char* s_separator = NULL;
  405924:	48 c7 85 d8 fe ff ff 	movq   $0x0,-0x128(%rbp)
  40592b:	00 00 00 00 

	// Check input validation
	if ((NULL == f_config) || (NULL == s_key) || (NULL == s_value))
  40592f:	48 83 bd c8 fe ff ff 	cmpq   $0x0,-0x138(%rbp)
  405936:	00 
  405937:	74 14                	je     40594d <gsi_parse_json_config_read_line+0x59>
  405939:	48 83 bd c0 fe ff ff 	cmpq   $0x0,-0x140(%rbp)
  405940:	00 
  405941:	74 0a                	je     40594d <gsi_parse_json_config_read_line+0x59>
  405943:	48 83 bd b8 fe ff ff 	cmpq   $0x0,-0x148(%rbp)
  40594a:	00 
  40594b:	75 41                	jne    40598e <gsi_parse_json_config_read_line+0x9a>
	{
		LOG_ERROR("read_line: invalid arguments");
  40594d:	b8 00 00 00 00       	mov    $0x0,%eax
  405952:	e8 e5 fc ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405957:	48 89 c3             	mov    %rax,%rbx
  40595a:	b8 00 00 00 00       	mov    $0x0,%eax
  40595f:	e8 53 fa ff ff       	callq  4053b7 <gsi_get_saved_file>
  405964:	41 b8 80 00 00 00    	mov    $0x80,%r8d
  40596a:	b9 70 83 40 00       	mov    $0x408370,%ecx
  40596f:	48 89 da             	mov    %rbx,%rdx
  405972:	be 88 84 40 00       	mov    $0x408488,%esi
  405977:	48 89 c7             	mov    %rax,%rdi
  40597a:	b8 00 00 00 00       	mov    $0x0,%eax
  40597f:	e8 9c fa ff ff       	callq  405420 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  405984:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  405989:	e9 9c 01 00 00       	jmpq   405b2a <gsi_parse_json_config_read_line+0x236>

	// Main loop - skip lines starts with '#' or empty lines
	do
	{
		// Reset buffer
		memset(s_line, 0, sizeof(s_line));
  40598e:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  405995:	ba 00 01 00 00       	mov    $0x100,%edx
  40599a:	be 00 00 00 00       	mov    $0x0,%esi
  40599f:	48 89 c7             	mov    %rax,%rdi
  4059a2:	e8 d9 bc ff ff       	callq  401680 <memset@plt>

		// Read line from file
		if (NULL == fgets(s_line, GSI_PARSE_JSON_CONFIG_MAX_LINE, f_config))
  4059a7:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  4059ae:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  4059b5:	be 00 01 00 00       	mov    $0x100,%esi
  4059ba:	48 89 c7             	mov    %rax,%rdi
  4059bd:	e8 0e bd ff ff       	callq  4016d0 <fgets@plt>
  4059c2:	48 85 c0             	test   %rax,%rax
  4059c5:	0f 85 95 00 00 00    	jne    405a60 <gsi_parse_json_config_read_line+0x16c>
		{
			// Check if get EOF
			if (feof(f_config))
  4059cb:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
  4059d2:	48 89 c7             	mov    %rax,%rdi
  4059d5:	e8 56 bd ff ff       	callq  401730 <feof@plt>
  4059da:	85 c0                	test   %eax,%eax
  4059dc:	74 41                	je     405a1f <gsi_parse_json_config_read_line+0x12b>
			{
				LOG_WARNING("get EOF from config file");
  4059de:	b8 00 00 00 00       	mov    $0x0,%eax
  4059e3:	e8 54 fc ff ff       	callq  40563c <gsi_is_gen_timestamp>
  4059e8:	48 89 c3             	mov    %rax,%rbx
  4059eb:	b8 00 00 00 00       	mov    $0x0,%eax
  4059f0:	e8 c2 f9 ff ff       	callq  4053b7 <gsi_get_saved_file>
  4059f5:	41 b8 90 00 00 00    	mov    $0x90,%r8d
  4059fb:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405a00:	48 89 da             	mov    %rbx,%rdx
  405a03:	be c8 84 40 00       	mov    $0x4084c8,%esi
  405a08:	48 89 c7             	mov    %rax,%rdi
  405a0b:	b8 00 00 00 00       	mov    $0x0,%eax
  405a10:	e8 0b fa ff ff       	callq  405420 <gsi_is_write_to_log>
				return GSI_PARSE_JSON_CONFIG_EOF;
  405a15:	b8 04 00 00 00       	mov    $0x4,%eax
  405a1a:	e9 0b 01 00 00       	jmpq   405b2a <gsi_parse_json_config_read_line+0x236>
			}
			else
			{
				LOG_ERROR("couldn't read from file");
  405a1f:	b8 00 00 00 00       	mov    $0x0,%eax
  405a24:	e8 13 fc ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405a29:	48 89 c3             	mov    %rax,%rbx
  405a2c:	b8 00 00 00 00       	mov    $0x0,%eax
  405a31:	e8 81 f9 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405a36:	41 b8 95 00 00 00    	mov    $0x95,%r8d
  405a3c:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405a41:	48 89 da             	mov    %rbx,%rdx
  405a44:	be 08 85 40 00       	mov    $0x408508,%esi
  405a49:	48 89 c7             	mov    %rax,%rdi
  405a4c:	b8 00 00 00 00       	mov    $0x0,%eax
  405a51:	e8 ca f9 ff ff       	callq  405420 <gsi_is_write_to_log>
				return GSI_PARSE_JSON_CONFIG_READ_ERR;
  405a56:	b8 03 00 00 00       	mov    $0x3,%eax
  405a5b:	e9 ca 00 00 00       	jmpq   405b2a <gsi_parse_json_config_read_line+0x236>
			}
		}
	}
	while (('#' == s_line[0]) || ('\n' == s_line[0]));
  405a60:	0f b6 85 e0 fe ff ff 	movzbl -0x120(%rbp),%eax
  405a67:	3c 23                	cmp    $0x23,%al
  405a69:	0f 84 1f ff ff ff    	je     40598e <gsi_parse_json_config_read_line+0x9a>
  405a6f:	0f b6 85 e0 fe ff ff 	movzbl -0x120(%rbp),%eax
  405a76:	3c 0a                	cmp    $0xa,%al
  405a78:	0f 84 10 ff ff ff    	je     40598e <gsi_parse_json_config_read_line+0x9a>

	// Get the position of ':' char in the current line
	s_separator = strchr(s_line, ':');
  405a7e:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  405a85:	be 3a 00 00 00       	mov    $0x3a,%esi
  405a8a:	48 89 c7             	mov    %rax,%rdi
  405a8d:	e8 ae bb ff ff       	callq  401640 <strchr@plt>
  405a92:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
	if (NULL == s_separator)
  405a99:	48 83 bd d8 fe ff ff 	cmpq   $0x0,-0x128(%rbp)
  405aa0:	00 
  405aa1:	75 3e                	jne    405ae1 <gsi_parse_json_config_read_line+0x1ed>
	{
		LOG_ERROR("there is no separator ':' in the line");
  405aa3:	b8 00 00 00 00       	mov    $0x0,%eax
  405aa8:	e8 8f fb ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405aad:	48 89 c3             	mov    %rax,%rbx
  405ab0:	b8 00 00 00 00       	mov    $0x0,%eax
  405ab5:	e8 fd f8 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405aba:	41 b8 a0 00 00 00    	mov    $0xa0,%r8d
  405ac0:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405ac5:	48 89 da             	mov    %rbx,%rdx
  405ac8:	be 48 85 40 00       	mov    $0x408548,%esi
  405acd:	48 89 c7             	mov    %rax,%rdi
  405ad0:	b8 00 00 00 00       	mov    $0x0,%eax
  405ad5:	e8 46 f9 ff ff       	callq  405420 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_READ_ERR;
  405ada:	b8 03 00 00 00       	mov    $0x3,%eax
  405adf:	eb 49                	jmp    405b2a <gsi_parse_json_config_read_line+0x236>
	}

	// Break the line into <KEY> <VALUE>
	*s_separator = 0;
  405ae1:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
  405ae8:	c6 00 00             	movb   $0x0,(%rax)

	// Set the buffers
	strcpy(s_key, s_line);
  405aeb:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  405af2:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  405af9:	48 89 d6             	mov    %rdx,%rsi
  405afc:	48 89 c7             	mov    %rax,%rdi
  405aff:	e8 5c ba ff ff       	callq  401560 <strcpy@plt>
	strcpy(s_value, ++s_separator);
  405b04:	48 83 85 d8 fe ff ff 	addq   $0x1,-0x128(%rbp)
  405b0b:	01 
  405b0c:	48 8b 95 d8 fe ff ff 	mov    -0x128(%rbp),%rdx
  405b13:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  405b1a:	48 89 d6             	mov    %rdx,%rsi
  405b1d:	48 89 c7             	mov    %rax,%rdi
  405b20:	e8 3b ba ff ff       	callq  401560 <strcpy@plt>

	return GSI_PARSE_JSON_CONFIG_SUCCESS;
  405b25:	b8 00 00 00 00       	mov    $0x0,%eax
}
  405b2a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  405b2e:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  405b35:	00 00 
  405b37:	74 05                	je     405b3e <gsi_parse_json_config_read_line+0x24a>
  405b39:	e8 c2 ba ff ff       	callq  401600 <__stack_chk_fail@plt>
  405b3e:	48 81 c4 48 01 00 00 	add    $0x148,%rsp
  405b45:	5b                   	pop    %rbx
  405b46:	5d                   	pop    %rbp
  405b47:	c3                   	retq   

0000000000405b48 <gsi_parse_json_config_get_next_entry>:
	 * Parameter:   [out] int* p_index - index of of given key OR -1 (if not found)
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_NOT_FOUND *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
enum gsi_prase_json_config_rc gsi_parse_json_config_get_next_entry(char* s_key, int* p_index)
{
  405b48:	55                   	push   %rbp
  405b49:	48 89 e5             	mov    %rsp,%rbp
  405b4c:	53                   	push   %rbx
  405b4d:	48 83 ec 28          	sub    $0x28,%rsp
  405b51:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  405b55:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Check input validation
	if ((NULL == s_key) || (NULL == p_index))
  405b59:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  405b5e:	74 07                	je     405b67 <gsi_parse_json_config_get_next_entry+0x1f>
  405b60:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  405b65:	75 41                	jne    405ba8 <gsi_parse_json_config_get_next_entry+0x60>
	{
		LOG_ERROR("invalid arguments");
  405b67:	b8 00 00 00 00       	mov    $0x0,%eax
  405b6c:	e8 cb fa ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405b71:	48 89 c3             	mov    %rax,%rbx
  405b74:	b8 00 00 00 00       	mov    $0x0,%eax
  405b79:	e8 39 f8 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405b7e:	41 b8 bb 00 00 00    	mov    $0xbb,%r8d
  405b84:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405b89:	48 89 da             	mov    %rbx,%rdx
  405b8c:	be 90 85 40 00       	mov    $0x408590,%esi
  405b91:	48 89 c7             	mov    %rax,%rdi
  405b94:	b8 00 00 00 00       	mov    $0x0,%eax
  405b99:	e8 82 f8 ff ff       	callq  405420 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  405b9e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  405ba3:	e9 9c 00 00 00       	jmpq   405c44 <gsi_parse_json_config_get_next_entry+0xfc>
	}

	// Search the key in the map
	for (int i_option = 0; g_config_params_keys[i_option] != NULL; ++i_option)
  405ba8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  405baf:	eb 34                	jmp    405be5 <gsi_parse_json_config_get_next_entry+0x9d>
	{
		if (0 == strcmp(s_key, g_config_params_keys[i_option]))
  405bb1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  405bb4:	48 98                	cltq   
  405bb6:	48 8b 14 c5 60 a2 60 	mov    0x60a260(,%rax,8),%rdx
  405bbd:	00 
  405bbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405bc2:	48 89 d6             	mov    %rdx,%rsi
  405bc5:	48 89 c7             	mov    %rax,%rdi
  405bc8:	e8 33 bb ff ff       	callq  401700 <strcmp@plt>
  405bcd:	85 c0                	test   %eax,%eax
  405bcf:	75 10                	jne    405be1 <gsi_parse_json_config_get_next_entry+0x99>
		{
			*p_index = i_option;
  405bd1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  405bd5:	8b 55 ec             	mov    -0x14(%rbp),%edx
  405bd8:	89 10                	mov    %edx,(%rax)
			return GSI_PARSE_JSON_CONFIG_SUCCESS;
  405bda:	b8 00 00 00 00       	mov    $0x0,%eax
  405bdf:	eb 63                	jmp    405c44 <gsi_parse_json_config_get_next_entry+0xfc>
		LOG_ERROR("invalid arguments");
		return GSI_PARSE_JSON_CONFIG_INVALID;
	}

	// Search the key in the map
	for (int i_option = 0; g_config_params_keys[i_option] != NULL; ++i_option)
  405be1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  405be5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  405be8:	48 98                	cltq   
  405bea:	48 8b 04 c5 60 a2 60 	mov    0x60a260(,%rax,8),%rax
  405bf1:	00 
  405bf2:	48 85 c0             	test   %rax,%rax
  405bf5:	75 ba                	jne    405bb1 <gsi_parse_json_config_get_next_entry+0x69>
			return GSI_PARSE_JSON_CONFIG_SUCCESS;
		}
	}

	// Not found so index is -1
	*p_index = -1;
  405bf7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  405bfb:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
	LOG_WARNING("key: %s not found", s_key);
  405c01:	b8 00 00 00 00       	mov    $0x0,%eax
  405c06:	e8 31 fa ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405c0b:	48 89 c3             	mov    %rax,%rbx
  405c0e:	b8 00 00 00 00       	mov    $0x0,%eax
  405c13:	e8 9f f7 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405c18:	48 89 c7             	mov    %rax,%rdi
  405c1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  405c1f:	49 89 c1             	mov    %rax,%r9
  405c22:	41 b8 cb 00 00 00    	mov    $0xcb,%r8d
  405c28:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405c2d:	48 89 da             	mov    %rbx,%rdx
  405c30:	be c8 85 40 00       	mov    $0x4085c8,%esi
  405c35:	b8 00 00 00 00       	mov    $0x0,%eax
  405c3a:	e8 e1 f7 ff ff       	callq  405420 <gsi_is_write_to_log>

	return GSI_PARSE_JSON_CONFIG_NOT_FOUND;
  405c3f:	b8 05 00 00 00       	mov    $0x5,%eax
}
  405c44:	48 83 c4 28          	add    $0x28,%rsp
  405c48:	5b                   	pop    %rbx
  405c49:	5d                   	pop    %rbp
  405c4a:	c3                   	retq   

0000000000405c4b <gsi_parse_json_config_get_config>:
	 * Parameter:   [in] char* p_argv[] - vector of arguments from command line (argv)
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_OPEN_ERR *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
enum gsi_prase_json_config_rc gsi_parse_json_config_get_config(int i_argc, char* p_argv[])
{
  405c4b:	55                   	push   %rbp
  405c4c:	48 89 e5             	mov    %rsp,%rbp
  405c4f:	41 54                	push   %r12
  405c51:	53                   	push   %rbx
  405c52:	48 83 ec 20          	sub    $0x20,%rsp
  405c56:	89 7d dc             	mov    %edi,-0x24(%rbp)
  405c59:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  405c5d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  405c64:	00 00 
  405c66:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  405c6a:	31 c0                	xor    %eax,%eax
	int i_option_index = 0;
  405c6c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	int i_rc = 0;
  405c73:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)

	// Check input validation
	if ((0 > i_argc) || (NULL == p_argv))
  405c7a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  405c7e:	78 07                	js     405c87 <gsi_parse_json_config_get_config+0x3c>
  405c80:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  405c85:	75 41                	jne    405cc8 <gsi_parse_json_config_get_config+0x7d>
	{
		LOG_ERROR("invalid arguments");
  405c87:	b8 00 00 00 00       	mov    $0x0,%eax
  405c8c:	e8 ab f9 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405c91:	48 89 c3             	mov    %rax,%rbx
  405c94:	b8 00 00 00 00       	mov    $0x0,%eax
  405c99:	e8 19 f7 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405c9e:	41 b8 e1 00 00 00    	mov    $0xe1,%r8d
  405ca4:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405ca9:	48 89 da             	mov    %rbx,%rdx
  405cac:	be 90 85 40 00       	mov    $0x408590,%esi
  405cb1:	48 89 c7             	mov    %rax,%rdi
  405cb4:	b8 00 00 00 00       	mov    $0x0,%eax
  405cb9:	e8 62 f7 ff ff       	callq  405420 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  405cbe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  405cc3:	e9 e0 00 00 00       	jmpq   405da8 <gsi_parse_json_config_get_config+0x15d>
	}

	// Parse command line arguments by getopt_long(), the argument is optional
	i_rc = getopt_long(i_argc, p_argv, "c::", &g_config_cmd_opts, &i_option_index);
  405cc8:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  405ccc:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  405cd0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  405cd3:	49 89 d0             	mov    %rdx,%r8
  405cd6:	b9 40 a2 60 00       	mov    $0x60a240,%ecx
  405cdb:	ba fe 85 40 00       	mov    $0x4085fe,%edx
  405ce0:	89 c7                	mov    %eax,%edi
  405ce2:	e8 39 b9 ff ff       	callq  401620 <getopt_long@plt>
  405ce7:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if (-1 == i_rc)
  405cea:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%rbp)
  405cee:	75 3e                	jne    405d2e <gsi_parse_json_config_get_config+0xe3>
	{
		LOG_ERROR("usage error: <a.out> --config=[file]");
  405cf0:	b8 00 00 00 00       	mov    $0x0,%eax
  405cf5:	e8 42 f9 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405cfa:	48 89 c3             	mov    %rax,%rbx
  405cfd:	b8 00 00 00 00       	mov    $0x0,%eax
  405d02:	e8 b0 f6 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405d07:	41 b8 e9 00 00 00    	mov    $0xe9,%r8d
  405d0d:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405d12:	48 89 da             	mov    %rbx,%rdx
  405d15:	be 08 86 40 00       	mov    $0x408608,%esi
  405d1a:	48 89 c7             	mov    %rax,%rdi
  405d1d:	b8 00 00 00 00       	mov    $0x0,%eax
  405d22:	e8 f9 f6 ff ff       	callq  405420 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_ERROR;
  405d27:	b8 06 00 00 00       	mov    $0x6,%eax
  405d2c:	eb 7a                	jmp    405da8 <gsi_parse_json_config_get_config+0x15d>
	}

	// No argument supplied so run default configuration.
	if (0 == strcmp("", optarg))
  405d2e:	48 8b 05 8b 45 20 00 	mov    0x20458b(%rip),%rax        # 60a2c0 <optarg@@GLIBC_2.2.5>
  405d35:	0f b6 00             	movzbl (%rax),%eax
  405d38:	84 c0                	test   %al,%al
  405d3a:	75 0c                	jne    405d48 <gsi_parse_json_config_get_config+0xfd>
	{
		gsi_parse_json_config_init_default_params();
  405d3c:	b8 00 00 00 00       	mov    $0x0,%eax
  405d41:	e8 81 04 00 00       	callq  4061c7 <gsi_parse_json_config_init_default_params>
  405d46:	eb 5b                	jmp    405da3 <gsi_parse_json_config_get_config+0x158>
	}
	// Read from config file given in command line
	else
	{
		if (GSI_PARSE_JSON_CONFIG_SUCCESS != gsi_parse_json_config_init_from_config_file(optarg))
  405d48:	48 8b 05 71 45 20 00 	mov    0x204571(%rip),%rax        # 60a2c0 <optarg@@GLIBC_2.2.5>
  405d4f:	48 89 c7             	mov    %rax,%rdi
  405d52:	e8 15 05 00 00       	callq  40626c <gsi_parse_json_config_init_from_config_file>
  405d57:	85 c0                	test   %eax,%eax
  405d59:	74 48                	je     405da3 <gsi_parse_json_config_get_config+0x158>
		{
			LOG_ERROR("failed to config parameters from file %s", optarg);
  405d5b:	48 8b 1d 5e 45 20 00 	mov    0x20455e(%rip),%rbx        # 60a2c0 <optarg@@GLIBC_2.2.5>
  405d62:	b8 00 00 00 00       	mov    $0x0,%eax
  405d67:	e8 d0 f8 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405d6c:	49 89 c4             	mov    %rax,%r12
  405d6f:	b8 00 00 00 00       	mov    $0x0,%eax
  405d74:	e8 3e f6 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405d79:	49 89 d9             	mov    %rbx,%r9
  405d7c:	41 b8 f7 00 00 00    	mov    $0xf7,%r8d
  405d82:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405d87:	4c 89 e2             	mov    %r12,%rdx
  405d8a:	be 50 86 40 00       	mov    $0x408650,%esi
  405d8f:	48 89 c7             	mov    %rax,%rdi
  405d92:	b8 00 00 00 00       	mov    $0x0,%eax
  405d97:	e8 84 f6 ff ff       	callq  405420 <gsi_is_write_to_log>
			return GSI_PARSE_JSON_CONFIG_ERROR;
  405d9c:	b8 06 00 00 00       	mov    $0x6,%eax
  405da1:	eb 05                	jmp    405da8 <gsi_parse_json_config_get_config+0x15d>
		}
	}

	return GSI_PARSE_JSON_CONFIG_SUCCESS;
  405da3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  405da8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  405dac:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
  405db3:	00 00 
  405db5:	74 05                	je     405dbc <gsi_parse_json_config_get_config+0x171>
  405db7:	e8 44 b8 ff ff       	callq  401600 <__stack_chk_fail@plt>
  405dbc:	48 83 c4 20          	add    $0x20,%rsp
  405dc0:	5b                   	pop    %rbx
  405dc1:	41 5c                	pop    %r12
  405dc3:	5d                   	pop    %rbp
  405dc4:	c3                   	retq   

0000000000405dc5 <gsi_parse_json_config_parse_main_args>:
	 * Parameter:   [in] int i_index - index of the parameter to set its value
	 * Parameter:   [in] char* s_value - value to set
	 * Return:		None
#############################################################################*/
static void gsi_parse_json_config_parse_main_args(int i_index, char* s_value)
{
  405dc5:	55                   	push   %rbp
  405dc6:	48 89 e5             	mov    %rsp,%rbp
  405dc9:	41 54                	push   %r12
  405dcb:	53                   	push   %rbx
  405dcc:	48 83 ec 10          	sub    $0x10,%rsp
  405dd0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  405dd3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Check input validation
	if ((0 > i_index) || (NULL == s_value))
  405dd7:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  405ddb:	78 07                	js     405de4 <gsi_parse_json_config_parse_main_args+0x1f>
  405ddd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  405de2:	75 3c                	jne    405e20 <gsi_parse_json_config_parse_main_args+0x5b>
	{
		LOG_ERROR("invalid arguments");
  405de4:	b8 00 00 00 00       	mov    $0x0,%eax
  405de9:	e8 4e f8 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405dee:	48 89 c3             	mov    %rax,%rbx
  405df1:	b8 00 00 00 00       	mov    $0x0,%eax
  405df6:	e8 bc f5 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405dfb:	41 b8 0e 01 00 00    	mov    $0x10e,%r8d
  405e01:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405e06:	48 89 da             	mov    %rbx,%rdx
  405e09:	be 90 85 40 00       	mov    $0x408590,%esi
  405e0e:	48 89 c7             	mov    %rax,%rdi
  405e11:	b8 00 00 00 00       	mov    $0x0,%eax
  405e16:	e8 05 f6 ff ff       	callq  405420 <gsi_is_write_to_log>
		return;
  405e1b:	e9 9e 03 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>
	}

	switch(i_index)
  405e20:	83 7d ec 08          	cmpl   $0x8,-0x14(%rbp)
  405e24:	0f 87 5d 03 00 00    	ja     406187 <gsi_parse_json_config_parse_main_args+0x3c2>
  405e2a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  405e2d:	48 8b 04 c5 d0 88 40 	mov    0x4088d0(,%rax,8),%rax
  405e34:	00 
  405e35:	ff e0                	jmpq   *%rax
	{
		// Server parameters
		case GSI_PARSE_JSON_PARAM_SERVER_PORT_1:
			g_config_server_params.ui_port1 = atoi(s_value);
  405e37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  405e3b:	48 89 c7             	mov    %rax,%rdi
  405e3e:	e8 1d ba ff ff       	callq  401860 <atoi@plt>
  405e43:	89 05 b7 44 20 00    	mov    %eax,0x2044b7(%rip)        # 60a300 <g_config_server_params>
			LOG_DEBUG("server_port_1: %d", g_config_server_params.ui_port1);
  405e49:	8b 1d b1 44 20 00    	mov    0x2044b1(%rip),%ebx        # 60a300 <g_config_server_params>
  405e4f:	b8 00 00 00 00       	mov    $0x0,%eax
  405e54:	e8 e3 f7 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405e59:	49 89 c4             	mov    %rax,%r12
  405e5c:	b8 00 00 00 00       	mov    $0x0,%eax
  405e61:	e8 51 f5 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405e66:	41 89 d9             	mov    %ebx,%r9d
  405e69:	41 b8 17 01 00 00    	mov    $0x117,%r8d
  405e6f:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405e74:	4c 89 e2             	mov    %r12,%rdx
  405e77:	be a0 86 40 00       	mov    $0x4086a0,%esi
  405e7c:	48 89 c7             	mov    %rax,%rdi
  405e7f:	b8 00 00 00 00       	mov    $0x0,%eax
  405e84:	e8 97 f5 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  405e89:	e9 30 03 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_PORT_2:
			g_config_server_params.ui_port2 = atoi(s_value);
  405e8e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  405e92:	48 89 c7             	mov    %rax,%rdi
  405e95:	e8 c6 b9 ff ff       	callq  401860 <atoi@plt>
  405e9a:	89 05 64 44 20 00    	mov    %eax,0x204464(%rip)        # 60a304 <g_config_server_params+0x4>
			LOG_DEBUG("server_port_2: %d", g_config_server_params.ui_port2);
  405ea0:	8b 1d 5e 44 20 00    	mov    0x20445e(%rip),%ebx        # 60a304 <g_config_server_params+0x4>
  405ea6:	b8 00 00 00 00       	mov    $0x0,%eax
  405eab:	e8 8c f7 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405eb0:	49 89 c4             	mov    %rax,%r12
  405eb3:	b8 00 00 00 00       	mov    $0x0,%eax
  405eb8:	e8 fa f4 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405ebd:	41 89 d9             	mov    %ebx,%r9d
  405ec0:	41 b8 1c 01 00 00    	mov    $0x11c,%r8d
  405ec6:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405ecb:	4c 89 e2             	mov    %r12,%rdx
  405ece:	be d8 86 40 00       	mov    $0x4086d8,%esi
  405ed3:	48 89 c7             	mov    %rax,%rdi
  405ed6:	b8 00 00 00 00       	mov    $0x0,%eax
  405edb:	e8 40 f5 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  405ee0:	e9 d9 02 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_PORT_3:
			g_config_server_params.ui_port3 = atoi(s_value);
  405ee5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  405ee9:	48 89 c7             	mov    %rax,%rdi
  405eec:	e8 6f b9 ff ff       	callq  401860 <atoi@plt>
  405ef1:	89 05 11 44 20 00    	mov    %eax,0x204411(%rip)        # 60a308 <g_config_server_params+0x8>
			LOG_DEBUG("server_port_3: %d", g_config_server_params.ui_port3);
  405ef7:	8b 1d 0b 44 20 00    	mov    0x20440b(%rip),%ebx        # 60a308 <g_config_server_params+0x8>
  405efd:	b8 00 00 00 00       	mov    $0x0,%eax
  405f02:	e8 35 f7 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405f07:	49 89 c4             	mov    %rax,%r12
  405f0a:	b8 00 00 00 00       	mov    $0x0,%eax
  405f0f:	e8 a3 f4 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405f14:	41 89 d9             	mov    %ebx,%r9d
  405f17:	41 b8 21 01 00 00    	mov    $0x121,%r8d
  405f1d:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405f22:	4c 89 e2             	mov    %r12,%rdx
  405f25:	be 10 87 40 00       	mov    $0x408710,%esi
  405f2a:	48 89 c7             	mov    %rax,%rdi
  405f2d:	b8 00 00 00 00       	mov    $0x0,%eax
  405f32:	e8 e9 f4 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  405f37:	e9 82 02 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_IP:
			strcpy(g_config_server_params.s_ip ,s_value);
  405f3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  405f40:	48 89 c6             	mov    %rax,%rsi
  405f43:	bf 10 a3 60 00       	mov    $0x60a310,%edi
  405f48:	e8 13 b6 ff ff       	callq  401560 <strcpy@plt>
			// Replace the '\n' by '\0'
			g_config_server_params.s_ip[strlen(g_config_server_params.s_ip) - 1] = '\0';
  405f4d:	bf 10 a3 60 00       	mov    $0x60a310,%edi
  405f52:	e8 99 b6 ff ff       	callq  4015f0 <strlen@plt>
  405f57:	48 83 e8 01          	sub    $0x1,%rax
  405f5b:	c6 80 10 a3 60 00 00 	movb   $0x0,0x60a310(%rax)
			LOG_DEBUG("server_ip: %s", g_config_server_params.s_ip);
  405f62:	b8 00 00 00 00       	mov    $0x0,%eax
  405f67:	e8 d0 f6 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405f6c:	48 89 c3             	mov    %rax,%rbx
  405f6f:	b8 00 00 00 00       	mov    $0x0,%eax
  405f74:	e8 3e f4 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405f79:	41 b9 10 a3 60 00    	mov    $0x60a310,%r9d
  405f7f:	41 b8 28 01 00 00    	mov    $0x128,%r8d
  405f85:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405f8a:	48 89 da             	mov    %rbx,%rdx
  405f8d:	be 48 87 40 00       	mov    $0x408748,%esi
  405f92:	48 89 c7             	mov    %rax,%rdi
  405f95:	b8 00 00 00 00       	mov    $0x0,%eax
  405f9a:	e8 81 f4 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  405f9f:	e9 1a 02 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_TIMER:
			g_config_server_params.i_server_timer = atoi(s_value);
  405fa4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  405fa8:	48 89 c7             	mov    %rax,%rdi
  405fab:	e8 b0 b8 ff ff       	callq  401860 <atoi@plt>
  405fb0:	89 05 56 43 20 00    	mov    %eax,0x204356(%rip)        # 60a30c <g_config_server_params+0xc>
			LOG_DEBUG("server_timer: %d", g_config_server_params.i_server_timer);
  405fb6:	8b 1d 50 43 20 00    	mov    0x204350(%rip),%ebx        # 60a30c <g_config_server_params+0xc>
  405fbc:	b8 00 00 00 00       	mov    $0x0,%eax
  405fc1:	e8 76 f6 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  405fc6:	49 89 c4             	mov    %rax,%r12
  405fc9:	b8 00 00 00 00       	mov    $0x0,%eax
  405fce:	e8 e4 f3 ff ff       	callq  4053b7 <gsi_get_saved_file>
  405fd3:	41 89 d9             	mov    %ebx,%r9d
  405fd6:	41 b8 2d 01 00 00    	mov    $0x12d,%r8d
  405fdc:	b9 70 83 40 00       	mov    $0x408370,%ecx
  405fe1:	4c 89 e2             	mov    %r12,%rdx
  405fe4:	be 78 87 40 00       	mov    $0x408778,%esi
  405fe9:	48 89 c7             	mov    %rax,%rdi
  405fec:	b8 00 00 00 00       	mov    $0x0,%eax
  405ff1:	e8 2a f4 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  405ff6:	e9 c3 01 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_SERVER_DATA:
			strcpy(g_config_server_params.s_server_data_file, s_value);
  405ffb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  405fff:	48 89 c6             	mov    %rax,%rsi
  406002:	bf 20 a3 60 00       	mov    $0x60a320,%edi
  406007:	e8 54 b5 ff ff       	callq  401560 <strcpy@plt>
			// Replace the '\n' by '\0'
			g_config_server_params.s_server_data_file[strlen(g_config_server_params.s_server_data_file) - 1] = '\0';
  40600c:	bf 20 a3 60 00       	mov    $0x60a320,%edi
  406011:	e8 da b5 ff ff       	callq  4015f0 <strlen@plt>
  406016:	48 83 e8 01          	sub    $0x1,%rax
  40601a:	c6 80 20 a3 60 00 00 	movb   $0x0,0x60a320(%rax)
			LOG_DEBUG("server_data: %s", g_config_server_params.s_server_data_file);
  406021:	b8 00 00 00 00       	mov    $0x0,%eax
  406026:	e8 11 f6 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  40602b:	48 89 c3             	mov    %rax,%rbx
  40602e:	b8 00 00 00 00       	mov    $0x0,%eax
  406033:	e8 7f f3 ff ff       	callq  4053b7 <gsi_get_saved_file>
  406038:	41 b9 20 a3 60 00    	mov    $0x60a320,%r9d
  40603e:	41 b8 34 01 00 00    	mov    $0x134,%r8d
  406044:	b9 70 83 40 00       	mov    $0x408370,%ecx
  406049:	48 89 da             	mov    %rbx,%rdx
  40604c:	be b0 87 40 00       	mov    $0x4087b0,%esi
  406051:	48 89 c7             	mov    %rax,%rdi
  406054:	b8 00 00 00 00       	mov    $0x0,%eax
  406059:	e8 c2 f3 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  40605e:	e9 5b 01 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		// Client parameters
		case GSI_PARSE_JSON_PARAM_CLIENT_PORT:
			g_config_client_params.ui_port = atoi(s_value);
  406063:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  406067:	48 89 c7             	mov    %rax,%rdi
  40606a:	e8 f1 b7 ff ff       	callq  401860 <atoi@plt>
  40606f:	89 05 2b 43 20 00    	mov    %eax,0x20432b(%rip)        # 60a3a0 <g_config_client_params>
			LOG_DEBUG("client_port: %d", g_config_client_params.ui_port);
  406075:	8b 1d 25 43 20 00    	mov    0x204325(%rip),%ebx        # 60a3a0 <g_config_client_params>
  40607b:	b8 00 00 00 00       	mov    $0x0,%eax
  406080:	e8 b7 f5 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  406085:	49 89 c4             	mov    %rax,%r12
  406088:	b8 00 00 00 00       	mov    $0x0,%eax
  40608d:	e8 25 f3 ff ff       	callq  4053b7 <gsi_get_saved_file>
  406092:	41 89 d9             	mov    %ebx,%r9d
  406095:	41 b8 3a 01 00 00    	mov    $0x13a,%r8d
  40609b:	b9 70 83 40 00       	mov    $0x408370,%ecx
  4060a0:	4c 89 e2             	mov    %r12,%rdx
  4060a3:	be e8 87 40 00       	mov    $0x4087e8,%esi
  4060a8:	48 89 c7             	mov    %rax,%rdi
  4060ab:	b8 00 00 00 00       	mov    $0x0,%eax
  4060b0:	e8 6b f3 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  4060b5:	e9 04 01 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_CLIENT_IP:
			strcpy(g_config_client_params.s_ip ,s_value);
  4060ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4060be:	48 89 c6             	mov    %rax,%rsi
  4060c1:	bf a4 a3 60 00       	mov    $0x60a3a4,%edi
  4060c6:	e8 95 b4 ff ff       	callq  401560 <strcpy@plt>
			// Replace the '\n' by '\0'
			g_config_client_params.s_ip[strlen(g_config_client_params.s_ip) - 1] = '\0';
  4060cb:	bf a4 a3 60 00       	mov    $0x60a3a4,%edi
  4060d0:	e8 1b b5 ff ff       	callq  4015f0 <strlen@plt>
  4060d5:	48 83 e8 01          	sub    $0x1,%rax
  4060d9:	c6 80 a4 a3 60 00 00 	movb   $0x0,0x60a3a4(%rax)
			LOG_DEBUG("client_ip: %s", g_config_client_params.s_ip);
  4060e0:	b8 00 00 00 00       	mov    $0x0,%eax
  4060e5:	e8 52 f5 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  4060ea:	48 89 c3             	mov    %rax,%rbx
  4060ed:	b8 00 00 00 00       	mov    $0x0,%eax
  4060f2:	e8 c0 f2 ff ff       	callq  4053b7 <gsi_get_saved_file>
  4060f7:	41 b9 a4 a3 60 00    	mov    $0x60a3a4,%r9d
  4060fd:	41 b8 41 01 00 00    	mov    $0x141,%r8d
  406103:	b9 70 83 40 00       	mov    $0x408370,%ecx
  406108:	48 89 da             	mov    %rbx,%rdx
  40610b:	be 20 88 40 00       	mov    $0x408820,%esi
  406110:	48 89 c7             	mov    %rax,%rdi
  406113:	b8 00 00 00 00       	mov    $0x0,%eax
  406118:	e8 03 f3 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  40611d:	e9 9c 00 00 00       	jmpq   4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		case GSI_PARSE_JSON_PARAM_CLIENT_MSG:
			strcpy(g_config_client_params.s_messages_file ,s_value);
  406122:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  406126:	48 89 c6             	mov    %rax,%rsi
  406129:	bf b4 a3 60 00       	mov    $0x60a3b4,%edi
  40612e:	e8 2d b4 ff ff       	callq  401560 <strcpy@plt>
			// Replace the '\n' by '\0'
			g_config_client_params.s_messages_file[strlen(g_config_client_params.s_messages_file) - 1] = '\0';
  406133:	bf b4 a3 60 00       	mov    $0x60a3b4,%edi
  406138:	e8 b3 b4 ff ff       	callq  4015f0 <strlen@plt>
  40613d:	48 83 e8 01          	sub    $0x1,%rax
  406141:	c6 80 b4 a3 60 00 00 	movb   $0x0,0x60a3b4(%rax)
			LOG_DEBUG("client_messages: %s", g_config_client_params.s_messages_file);
  406148:	b8 00 00 00 00       	mov    $0x0,%eax
  40614d:	e8 ea f4 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  406152:	48 89 c3             	mov    %rax,%rbx
  406155:	b8 00 00 00 00       	mov    $0x0,%eax
  40615a:	e8 58 f2 ff ff       	callq  4053b7 <gsi_get_saved_file>
  40615f:	41 b9 b4 a3 60 00    	mov    $0x60a3b4,%r9d
  406165:	41 b8 48 01 00 00    	mov    $0x148,%r8d
  40616b:	b9 70 83 40 00       	mov    $0x408370,%ecx
  406170:	48 89 da             	mov    %rbx,%rdx
  406173:	be 50 88 40 00       	mov    $0x408850,%esi
  406178:	48 89 c7             	mov    %rax,%rdi
  40617b:	b8 00 00 00 00       	mov    $0x0,%eax
  406180:	e8 9b f2 ff ff       	callq  405420 <gsi_is_write_to_log>
			break;
  406185:	eb 37                	jmp    4061be <gsi_parse_json_config_parse_main_args+0x3f9>

		default:
			LOG_ERROR("index is not match to any option");
  406187:	b8 00 00 00 00       	mov    $0x0,%eax
  40618c:	e8 ab f4 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  406191:	48 89 c3             	mov    %rax,%rbx
  406194:	b8 00 00 00 00       	mov    $0x0,%eax
  406199:	e8 19 f2 ff ff       	callq  4053b7 <gsi_get_saved_file>
  40619e:	41 b8 4c 01 00 00    	mov    $0x14c,%r8d
  4061a4:	b9 70 83 40 00       	mov    $0x408370,%ecx
  4061a9:	48 89 da             	mov    %rbx,%rdx
  4061ac:	be 88 88 40 00       	mov    $0x408888,%esi
  4061b1:	48 89 c7             	mov    %rax,%rdi
  4061b4:	b8 00 00 00 00       	mov    $0x0,%eax
  4061b9:	e8 62 f2 ff ff       	callq  405420 <gsi_is_write_to_log>
	}
}
  4061be:	48 83 c4 10          	add    $0x10,%rsp
  4061c2:	5b                   	pop    %rbx
  4061c3:	41 5c                	pop    %r12
  4061c5:	5d                   	pop    %rbp
  4061c6:	c3                   	retq   

00000000004061c7 <gsi_parse_json_config_init_default_params>:
	 * Description: Initialize default parameters to server structure
	 * Parameter:   [in] None
	 * Return:		None
#############################################################################*/
static void gsi_parse_json_config_init_default_params()
{
  4061c7:	55                   	push   %rbp
  4061c8:	48 89 e5             	mov    %rsp,%rbp
	// Server parameters
	g_config_server_params.ui_port1 = 65533;
  4061cb:	c7 05 2b 41 20 00 fd 	movl   $0xfffd,0x20412b(%rip)        # 60a300 <g_config_server_params>
  4061d2:	ff 00 00 
	g_config_server_params.ui_port2 = 65534;
  4061d5:	c7 05 25 41 20 00 fe 	movl   $0xfffe,0x204125(%rip)        # 60a304 <g_config_server_params+0x4>
  4061dc:	ff 00 00 
	g_config_server_params.ui_port3 = 65535;
  4061df:	c7 05 1f 41 20 00 ff 	movl   $0xffff,0x20411f(%rip)        # 60a308 <g_config_server_params+0x8>
  4061e6:	ff 00 00 
	g_config_server_params.i_server_timer = 0;
  4061e9:	c7 05 19 41 20 00 00 	movl   $0x0,0x204119(%rip)        # 60a30c <g_config_server_params+0xc>
  4061f0:	00 00 00 

	strcpy(g_config_server_params.s_ip, "127.0.0.1");
  4061f3:	48 b8 31 32 37 2e 30 	movabs $0x2e302e302e373231,%rax
  4061fa:	2e 30 2e 
  4061fd:	48 89 05 0c 41 20 00 	mov    %rax,0x20410c(%rip)        # 60a310 <g_config_server_params+0x10>
  406204:	66 c7 05 0b 41 20 00 	movw   $0x31,0x20410b(%rip)        # 60a318 <g_config_server_params+0x18>
  40620b:	31 00 
	strcpy(g_config_server_params.s_server_data_file, "../src/server/test_files/server_data.txt");
  40620d:	48 b8 2e 2e 2f 73 72 	movabs $0x732f6372732f2e2e,%rax
  406214:	63 2f 73 
  406217:	48 89 05 02 41 20 00 	mov    %rax,0x204102(%rip)        # 60a320 <g_config_server_params+0x20>
  40621e:	48 b8 65 72 76 65 72 	movabs $0x65742f7265767265,%rax
  406225:	2f 74 65 
  406228:	48 89 05 f9 40 20 00 	mov    %rax,0x2040f9(%rip)        # 60a328 <g_config_server_params+0x28>
  40622f:	48 b8 73 74 5f 66 69 	movabs $0x73656c69665f7473,%rax
  406236:	6c 65 73 
  406239:	48 89 05 f0 40 20 00 	mov    %rax,0x2040f0(%rip)        # 60a330 <g_config_server_params+0x30>
  406240:	48 b8 2f 73 65 72 76 	movabs $0x5f7265767265732f,%rax
  406247:	65 72 5f 
  40624a:	48 89 05 e7 40 20 00 	mov    %rax,0x2040e7(%rip)        # 60a338 <g_config_server_params+0x38>
  406251:	48 b8 64 61 74 61 2e 	movabs $0x7478742e61746164,%rax
  406258:	74 78 74 
  40625b:	48 89 05 de 40 20 00 	mov    %rax,0x2040de(%rip)        # 60a340 <g_config_server_params+0x40>
  406262:	c6 05 df 40 20 00 00 	movb   $0x0,0x2040df(%rip)        # 60a348 <g_config_server_params+0x48>
}
  406269:	90                   	nop
  40626a:	5d                   	pop    %rbp
  40626b:	c3                   	retq   

000000000040626c <gsi_parse_json_config_init_from_config_file>:
	 * Parameter:   [in] char* s_config_file - configuration file
	 * Return:		Success - GSI_PARSE_JSON_CONFIG_SUCCESS
	 * 				Failure - GSI_PARSE_JSON_CONFIG_OPEN_ERR *OR* GSI_PARSE_JSON_CONFIG_INVALID
#############################################################################*/
static enum gsi_prase_json_config_rc gsi_parse_json_config_init_from_config_file(char* s_config_file)
{
  40626c:	55                   	push   %rbp
  40626d:	48 89 e5             	mov    %rsp,%rbp
  406270:	53                   	push   %rbx
  406271:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp
  406278:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  40627f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  406286:	00 00 
  406288:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  40628c:	31 c0                	xor    %eax,%eax
	int i_param_index = 0;
  40628e:	c7 85 d0 fe ff ff 00 	movl   $0x0,-0x130(%rbp)
  406295:	00 00 00 
	int i_rc = GSI_PARSE_JSON_CONFIG_SUCCESS;
  406298:	c7 85 d4 fe ff ff 00 	movl   $0x0,-0x12c(%rbp)
  40629f:	00 00 00 
	char s_key[GSI_PARSE_JSON_CONFIG_MAX_KEY_LEN];
	char s_value[GSI_PARSE_JSON_CONFIG_MAX_VALUE_LEN];
	FILE* f_config = NULL;
  4062a2:	48 c7 85 d8 fe ff ff 	movq   $0x0,-0x128(%rbp)
  4062a9:	00 00 00 00 

	// Check input validation
	if (NULL == s_config_file)
  4062ad:	48 83 bd c8 fe ff ff 	cmpq   $0x0,-0x138(%rbp)
  4062b4:	00 
  4062b5:	75 41                	jne    4062f8 <gsi_parse_json_config_init_from_config_file+0x8c>
	{
		LOG_ERROR("invalid argument");
  4062b7:	b8 00 00 00 00       	mov    $0x0,%eax
  4062bc:	e8 7b f3 ff ff       	callq  40563c <gsi_is_gen_timestamp>
  4062c1:	48 89 c3             	mov    %rax,%rbx
  4062c4:	b8 00 00 00 00       	mov    $0x0,%eax
  4062c9:	e8 e9 f0 ff ff       	callq  4053b7 <gsi_get_saved_file>
  4062ce:	41 b8 74 01 00 00    	mov    $0x174,%r8d
  4062d4:	b9 70 83 40 00       	mov    $0x408370,%ecx
  4062d9:	48 89 da             	mov    %rbx,%rdx
  4062dc:	be 08 84 40 00       	mov    $0x408408,%esi
  4062e1:	48 89 c7             	mov    %rax,%rdi
  4062e4:	b8 00 00 00 00       	mov    $0x0,%eax
  4062e9:	e8 32 f1 ff ff       	callq  405420 <gsi_is_write_to_log>
		return GSI_PARSE_JSON_CONFIG_INVALID;
  4062ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4062f3:	e9 f9 00 00 00       	jmpq   4063f1 <gsi_parse_json_config_init_from_config_file+0x185>
	}

	// Open config file
	f_config = gsi_parse_json_config_open(s_config_file);
  4062f8:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
  4062ff:	48 89 c7             	mov    %rax,%rdi
  406302:	e8 7b f4 ff ff       	callq  405782 <gsi_parse_json_config_open>
  406307:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
	if (NULL == f_config)
  40630e:	48 83 bd d8 fe ff ff 	cmpq   $0x0,-0x128(%rbp)
  406315:	00 
  406316:	75 0a                	jne    406322 <gsi_parse_json_config_init_from_config_file+0xb6>
	{
		return GSI_PARSE_JSON_CONFIG_OPEN_ERR;
  406318:	b8 01 00 00 00       	mov    $0x1,%eax
  40631d:	e9 cf 00 00 00       	jmpq   4063f1 <gsi_parse_json_config_init_from_config_file+0x185>

	// Main loop to read all config parameters
	while (1)
	{
		// Reset buffers
		memset(s_key, 0, sizeof(s_key));
  406322:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  406329:	ba 80 00 00 00       	mov    $0x80,%edx
  40632e:	be 00 00 00 00       	mov    $0x0,%esi
  406333:	48 89 c7             	mov    %rax,%rdi
  406336:	e8 45 b3 ff ff       	callq  401680 <memset@plt>
		memset(s_value, 0, sizeof(s_value));
  40633b:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  406342:	ba 80 00 00 00       	mov    $0x80,%edx
  406347:	be 00 00 00 00       	mov    $0x0,%esi
  40634c:	48 89 c7             	mov    %rax,%rdi
  40634f:	e8 2c b3 ff ff       	callq  401680 <memset@plt>

		// Read the next line from config file
		i_rc = gsi_parse_json_config_read_line(f_config, s_key, s_value);
  406354:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
  40635b:	48 8d 8d e0 fe ff ff 	lea    -0x120(%rbp),%rcx
  406362:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
  406369:	48 89 ce             	mov    %rcx,%rsi
  40636c:	48 89 c7             	mov    %rax,%rdi
  40636f:	e8 80 f5 ff ff       	callq  4058f4 <gsi_parse_json_config_read_line>
  406374:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%rbp)
		if (GSI_PARSE_JSON_CONFIG_SUCCESS != i_rc)
  40637a:	83 bd d4 fe ff ff 00 	cmpl   $0x0,-0x12c(%rbp)
  406381:	75 45                	jne    4063c8 <gsi_parse_json_config_init_from_config_file+0x15c>
		{
			break;
		}

		// Get the key index in map
		if (GSI_PARSE_JSON_CONFIG_SUCCESS != gsi_parse_json_config_get_next_entry(s_key, &i_param_index))
  406383:	48 8d 95 d0 fe ff ff 	lea    -0x130(%rbp),%rdx
  40638a:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
  406391:	48 89 d6             	mov    %rdx,%rsi
  406394:	48 89 c7             	mov    %rax,%rdi
  406397:	e8 ac f7 ff ff       	callq  405b48 <gsi_parse_json_config_get_next_entry>
  40639c:	85 c0                	test   %eax,%eax
  40639e:	74 0c                	je     4063ac <gsi_parse_json_config_init_from_config_file+0x140>
		{
			i_rc = GSI_PARSE_JSON_CONFIG_NOT_FOUND;
  4063a0:	c7 85 d4 fe ff ff 05 	movl   $0x5,-0x12c(%rbp)
  4063a7:	00 00 00 
			break;
  4063aa:	eb 1d                	jmp    4063c9 <gsi_parse_json_config_init_from_config_file+0x15d>
		}

		// Set value at given index
		gsi_parse_json_config_parse_main_args(i_param_index, s_value);
  4063ac:	8b 85 d0 fe ff ff    	mov    -0x130(%rbp),%eax
  4063b2:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
  4063b9:	48 89 d6             	mov    %rdx,%rsi
  4063bc:	89 c7                	mov    %eax,%edi
  4063be:	e8 02 fa ff ff       	callq  405dc5 <gsi_parse_json_config_parse_main_args>
	}
  4063c3:	e9 5a ff ff ff       	jmpq   406322 <gsi_parse_json_config_init_from_config_file+0xb6>

		// Read the next line from config file
		i_rc = gsi_parse_json_config_read_line(f_config, s_key, s_value);
		if (GSI_PARSE_JSON_CONFIG_SUCCESS != i_rc)
		{
			break;
  4063c8:	90                   	nop
		// Set value at given index
		gsi_parse_json_config_parse_main_args(i_param_index, s_value);
	}

	// Close config file
	gsi_parse_json_config_close(f_config);
  4063c9:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
  4063d0:	48 89 c7             	mov    %rax,%rdi
  4063d3:	e8 70 f4 ff ff       	callq  405848 <gsi_parse_json_config_close>

	if (GSI_PARSE_JSON_CONFIG_EOF == i_rc)
  4063d8:	83 bd d4 fe ff ff 04 	cmpl   $0x4,-0x12c(%rbp)
  4063df:	75 0a                	jne    4063eb <gsi_parse_json_config_init_from_config_file+0x17f>
	{
		i_rc = GSI_PARSE_JSON_CONFIG_SUCCESS;
  4063e1:	c7 85 d4 fe ff ff 00 	movl   $0x0,-0x12c(%rbp)
  4063e8:	00 00 00 
	}

	return i_rc;
  4063eb:	8b 85 d4 fe ff ff    	mov    -0x12c(%rbp),%eax
}
  4063f1:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  4063f5:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
  4063fc:	00 00 
  4063fe:	74 05                	je     406405 <gsi_parse_json_config_init_from_config_file+0x199>
  406400:	e8 fb b1 ff ff       	callq  401600 <__stack_chk_fail@plt>
  406405:	48 81 c4 38 01 00 00 	add    $0x138,%rsp
  40640c:	5b                   	pop    %rbx
  40640d:	5d                   	pop    %rbp
  40640e:	c3                   	retq   

000000000040640f <gsi_is_thread_pool_create>:
	 * Parameter:   [in] int i_queue_size - size of the queue
	 * Return: 	    Success - pointer to new thread_pool object
	 * 				Failure - NULL
#############################################################################*/
gsi_thread_pool_t* gsi_is_thread_pool_create(int i_thread_count, int i_queue_size)
{
  40640f:	55                   	push   %rbp
  406410:	48 89 e5             	mov    %rsp,%rbp
  406413:	48 83 ec 20          	sub    $0x20,%rsp
  406417:	89 7d ec             	mov    %edi,-0x14(%rbp)
  40641a:	89 75 e8             	mov    %esi,-0x18(%rbp)
	gsi_thread_pool_t* p_pool = NULL;
  40641d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  406424:	00 

	// Check input validation
	if ((0 >= i_thread_count) || (GSI_IS_MAX_THREADS < i_thread_count) ||
  406425:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  406429:	7e 15                	jle    406440 <gsi_is_thread_pool_create+0x31>
  40642b:	83 7d ec 05          	cmpl   $0x5,-0x14(%rbp)
  40642f:	7f 0f                	jg     406440 <gsi_is_thread_pool_create+0x31>
  406431:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  406435:	7e 09                	jle    406440 <gsi_is_thread_pool_create+0x31>
		(0 >= i_queue_size)   || (GSI_IS_MAX_QUEUE_SIZE < i_queue_size))
  406437:	81 7d e8 c8 00 00 00 	cmpl   $0xc8,-0x18(%rbp)
  40643e:	7e 14                	jle    406454 <gsi_is_thread_pool_create+0x45>
	{
		printf("gsi_is_thread_pool_create: invalid arguments\n");
  406440:	bf 18 89 40 00       	mov    $0x408918,%edi
  406445:	e8 36 b1 ff ff       	callq  401580 <puts@plt>
		return NULL;
  40644a:	b8 00 00 00 00       	mov    $0x0,%eax
  40644f:	e9 35 02 00 00       	jmpq   406689 <gsi_is_thread_pool_create+0x27a>
	}

	// Allocate new thread pool
	p_pool = (gsi_thread_pool_t*) malloc(sizeof(gsi_thread_pool_t));
  406454:	bf 88 00 00 00       	mov    $0x88,%edi
  406459:	e8 52 b3 ff ff       	callq  4017b0 <malloc@plt>
  40645e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (NULL == p_pool)
  406462:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  406467:	75 14                	jne    40647d <gsi_is_thread_pool_create+0x6e>
	{
		printf("gsi_is_thread_pool_create: malloc failed\n");
  406469:	bf 48 89 40 00       	mov    $0x408948,%edi
  40646e:	e8 0d b1 ff ff       	callq  401580 <puts@plt>
		return NULL;
  406473:	b8 00 00 00 00       	mov    $0x0,%eax
  406478:	e9 0c 02 00 00       	jmpq   406689 <gsi_is_thread_pool_create+0x27a>
	}

	// Update fields
	p_pool->i_thread_count = 0;
  40647d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406481:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%rax)
	p_pool->i_queue_size = i_queue_size;
  406488:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40648c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  40648f:	89 50 6c             	mov    %edx,0x6c(%rax)
	p_pool->i_head = 0;
  406492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406496:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
	p_pool->i_tail = 0;
  40649d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4064a1:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%rax)
	p_pool->i_count = 0;
  4064a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4064ac:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%rax)
	p_pool->i_shutdown = 0;
  4064b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4064b7:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	p_pool->i_started = 0;
  4064be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4064c2:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  4064c9:	00 00 00 

	// Allocate array of threads
	p_pool->p_threads = (pthread_t*)malloc(sizeof(pthread_t) * i_thread_count);
  4064cc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4064cf:	48 98                	cltq   
  4064d1:	48 c1 e0 03          	shl    $0x3,%rax
  4064d5:	48 89 c7             	mov    %rax,%rdi
  4064d8:	e8 d3 b2 ff ff       	callq  4017b0 <malloc@plt>
  4064dd:	48 89 c2             	mov    %rax,%rdx
  4064e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4064e4:	48 89 50 58          	mov    %rdx,0x58(%rax)
	if (NULL == p_pool->p_threads)
  4064e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4064ec:	48 8b 40 58          	mov    0x58(%rax),%rax
  4064f0:	48 85 c0             	test   %rax,%rax
  4064f3:	75 16                	jne    40650b <gsi_is_thread_pool_create+0xfc>
	{
		free(p_pool);
  4064f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4064f9:	48 89 c7             	mov    %rax,%rdi
  4064fc:	e8 1f b0 ff ff       	callq  401520 <free@plt>
		return NULL;
  406501:	b8 00 00 00 00       	mov    $0x0,%eax
  406506:	e9 7e 01 00 00       	jmpq   406689 <gsi_is_thread_pool_create+0x27a>
	}

	// Allocate queue of tasks
	p_pool->queue = (gsi_thread_pool_task_t*)malloc(sizeof(gsi_thread_pool_task_t) * i_queue_size);
  40650b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  40650e:	48 98                	cltq   
  406510:	48 c1 e0 04          	shl    $0x4,%rax
  406514:	48 89 c7             	mov    %rax,%rdi
  406517:	e8 94 b2 ff ff       	callq  4017b0 <malloc@plt>
  40651c:	48 89 c2             	mov    %rax,%rdx
  40651f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406523:	48 89 50 60          	mov    %rdx,0x60(%rax)
	if (NULL == p_pool->queue)
  406527:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40652b:	48 8b 40 60          	mov    0x60(%rax),%rax
  40652f:	48 85 c0             	test   %rax,%rax
  406532:	75 26                	jne    40655a <gsi_is_thread_pool_create+0x14b>
	{
		free(p_pool->p_threads);
  406534:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406538:	48 8b 40 58          	mov    0x58(%rax),%rax
  40653c:	48 89 c7             	mov    %rax,%rdi
  40653f:	e8 dc af ff ff       	callq  401520 <free@plt>
		free(p_pool);
  406544:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406548:	48 89 c7             	mov    %rax,%rdi
  40654b:	e8 d0 af ff ff       	callq  401520 <free@plt>
		return NULL;
  406550:	b8 00 00 00 00       	mov    $0x0,%eax
  406555:	e9 2f 01 00 00       	jmpq   406689 <gsi_is_thread_pool_create+0x27a>
	}

	// Init the mutex
	if (0 != pthread_mutex_init(&(p_pool->lock), NULL))
  40655a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40655e:	be 00 00 00 00       	mov    $0x0,%esi
  406563:	48 89 c7             	mov    %rax,%rdi
  406566:	e8 55 b3 ff ff       	callq  4018c0 <pthread_mutex_init@plt>
  40656b:	85 c0                	test   %eax,%eax
  40656d:	74 36                	je     4065a5 <gsi_is_thread_pool_create+0x196>
	{
		free(p_pool->queue);
  40656f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406573:	48 8b 40 60          	mov    0x60(%rax),%rax
  406577:	48 89 c7             	mov    %rax,%rdi
  40657a:	e8 a1 af ff ff       	callq  401520 <free@plt>
		free(p_pool->p_threads);
  40657f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406583:	48 8b 40 58          	mov    0x58(%rax),%rax
  406587:	48 89 c7             	mov    %rax,%rdi
  40658a:	e8 91 af ff ff       	callq  401520 <free@plt>
		free(p_pool);
  40658f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406593:	48 89 c7             	mov    %rax,%rdi
  406596:	e8 85 af ff ff       	callq  401520 <free@plt>
		return NULL;
  40659b:	b8 00 00 00 00       	mov    $0x0,%eax
  4065a0:	e9 e4 00 00 00       	jmpq   406689 <gsi_is_thread_pool_create+0x27a>
	}

	// Init the condition variable
	if (0 != pthread_cond_init(&(p_pool->notify), NULL))
  4065a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4065a9:	48 83 c0 28          	add    $0x28,%rax
  4065ad:	be 00 00 00 00       	mov    $0x0,%esi
  4065b2:	48 89 c7             	mov    %rax,%rdi
  4065b5:	e8 d6 b1 ff ff       	callq  401790 <pthread_cond_init@plt>
  4065ba:	85 c0                	test   %eax,%eax
  4065bc:	74 42                	je     406600 <gsi_is_thread_pool_create+0x1f1>
	{
		pthread_mutex_destroy(&(p_pool->lock));
  4065be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4065c2:	48 89 c7             	mov    %rax,%rdi
  4065c5:	e8 96 b0 ff ff       	callq  401660 <pthread_mutex_destroy@plt>
		free(p_pool->queue);
  4065ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4065ce:	48 8b 40 60          	mov    0x60(%rax),%rax
  4065d2:	48 89 c7             	mov    %rax,%rdi
  4065d5:	e8 46 af ff ff       	callq  401520 <free@plt>
		free(p_pool->p_threads);
  4065da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4065de:	48 8b 40 58          	mov    0x58(%rax),%rax
  4065e2:	48 89 c7             	mov    %rax,%rdi
  4065e5:	e8 36 af ff ff       	callq  401520 <free@plt>
		free(p_pool);
  4065ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4065ee:	48 89 c7             	mov    %rax,%rdi
  4065f1:	e8 2a af ff ff       	callq  401520 <free@plt>
		return NULL;
  4065f6:	b8 00 00 00 00       	mov    $0x0,%eax
  4065fb:	e9 89 00 00 00       	jmpq   406689 <gsi_is_thread_pool_create+0x27a>
	}

	// Start worker threads
	for (int i = 0; i < i_thread_count; ++i)
  406600:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  406607:	eb 74                	jmp    40667d <gsi_is_thread_pool_create+0x26e>
	{
		if (0 != pthread_create(&(p_pool->p_threads[i]), NULL, gsi_is_thread_run, p_pool))
  406609:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40660d:	48 8b 40 58          	mov    0x58(%rax),%rax
  406611:	8b 55 f4             	mov    -0xc(%rbp),%edx
  406614:	48 63 d2             	movslq %edx,%rdx
  406617:	48 c1 e2 03          	shl    $0x3,%rdx
  40661b:	48 8d 3c 10          	lea    (%rax,%rdx,1),%rdi
  40661f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406623:	48 89 c1             	mov    %rax,%rcx
  406626:	ba a3 68 40 00       	mov    $0x4068a3,%edx
  40662b:	be 00 00 00 00       	mov    $0x0,%esi
  406630:	e8 fb ae ff ff       	callq  401530 <pthread_create@plt>
  406635:	85 c0                	test   %eax,%eax
  406637:	74 18                	je     406651 <gsi_is_thread_pool_create+0x242>
		{
			gsi_is_thread_pool_destroy(p_pool, GSI_TP_DESTROY_IMMIDIATE);
  406639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40663d:	be 02 00 00 00       	mov    $0x2,%esi
  406642:	48 89 c7             	mov    %rax,%rdi
  406645:	e8 5e 01 00 00       	callq  4067a8 <gsi_is_thread_pool_destroy>
			return NULL;
  40664a:	b8 00 00 00 00       	mov    $0x0,%eax
  40664f:	eb 38                	jmp    406689 <gsi_is_thread_pool_create+0x27a>
		}

		// Add 1 to the number of current working threads
		p_pool->i_thread_count++;
  406651:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406655:	8b 40 68             	mov    0x68(%rax),%eax
  406658:	8d 50 01             	lea    0x1(%rax),%edx
  40665b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40665f:	89 50 68             	mov    %edx,0x68(%rax)
		p_pool->i_started++;
  406662:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406666:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
  40666c:	8d 50 01             	lea    0x1(%rax),%edx
  40666f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406673:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
		free(p_pool);
		return NULL;
	}

	// Start worker threads
	for (int i = 0; i < i_thread_count; ++i)
  406679:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  40667d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  406680:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  406683:	7c 84                	jl     406609 <gsi_is_thread_pool_create+0x1fa>
		// Add 1 to the number of current working threads
		p_pool->i_thread_count++;
		p_pool->i_started++;
	}

	return p_pool;
  406685:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  406689:	c9                   	leaveq 
  40668a:	c3                   	retq   

000000000040668b <gsi_is_thread_pool_add>:
	 * Parameter:   [in] void* args - Argument to be passed to the function.
	 * Return: 	    Success - GSI_TP_RC_SUCCESS
	 * 				Failure - GSI_TP_RC_ERROR *OR* GSI_TP_RC_INVALID
#############################################################################*/
enum gsi_thread_pool_rc gsi_is_thread_pool_add(gsi_thread_pool_t* p_pool, thread_func_t thread_func, void* args)
{
  40668b:	55                   	push   %rbp
  40668c:	48 89 e5             	mov    %rsp,%rbp
  40668f:	48 83 ec 20          	sub    $0x20,%rsp
  406693:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  406697:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40669b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	// Check input validation
	if ((NULL == p_pool) || (NULL == thread_func))
  40669f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  4066a4:	74 07                	je     4066ad <gsi_is_thread_pool_add+0x22>
  4066a6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  4066ab:	75 0a                	jne    4066b7 <gsi_is_thread_pool_add+0x2c>
	{
		return GSI_TP_RC_INVALID;
  4066ad:	b8 02 00 00 00       	mov    $0x2,%eax
  4066b2:	e9 ef 00 00 00       	jmpq   4067a6 <gsi_is_thread_pool_add+0x11b>
	}

	// Try to lock the mutex to own the thread pool
	if (0 != pthread_mutex_lock(&(p_pool->lock)))
  4066b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4066bb:	48 89 c7             	mov    %rax,%rdi
  4066be:	e8 1d b2 ff ff       	callq  4018e0 <pthread_mutex_lock@plt>
  4066c3:	85 c0                	test   %eax,%eax
  4066c5:	74 0a                	je     4066d1 <gsi_is_thread_pool_add+0x46>
	{
		return GSI_TP_RC_ERROR;
  4066c7:	b8 01 00 00 00       	mov    $0x1,%eax
  4066cc:	e9 d5 00 00 00       	jmpq   4067a6 <gsi_is_thread_pool_add+0x11b>
	}

	// Check if the queue is full
	if (p_pool->i_count == p_pool->i_queue_size)
  4066d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4066d5:	8b 50 78             	mov    0x78(%rax),%edx
  4066d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4066dc:	8b 40 6c             	mov    0x6c(%rax),%eax
  4066df:	39 c2                	cmp    %eax,%edx
  4066e1:	75 0a                	jne    4066ed <gsi_is_thread_pool_add+0x62>
	{
		return GSI_TP_RC_ERROR;
  4066e3:	b8 01 00 00 00       	mov    $0x1,%eax
  4066e8:	e9 b9 00 00 00       	jmpq   4067a6 <gsi_is_thread_pool_add+0x11b>
	}

	// Check if we are in shutdown
	if (0 < p_pool->i_shutdown)
  4066ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4066f1:	8b 40 7c             	mov    0x7c(%rax),%eax
  4066f4:	85 c0                	test   %eax,%eax
  4066f6:	7e 0a                	jle    406702 <gsi_is_thread_pool_add+0x77>
	{
		return GSI_TP_RC_ERROR;
  4066f8:	b8 01 00 00 00       	mov    $0x1,%eax
  4066fd:	e9 a4 00 00 00       	jmpq   4067a6 <gsi_is_thread_pool_add+0x11b>
	}

	// Add task to queue
	p_pool->queue[p_pool->i_tail].thread_func = thread_func;
  406702:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406706:	48 8b 50 60          	mov    0x60(%rax),%rdx
  40670a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40670e:	8b 40 74             	mov    0x74(%rax),%eax
  406711:	48 98                	cltq   
  406713:	48 c1 e0 04          	shl    $0x4,%rax
  406717:	48 01 c2             	add    %rax,%rdx
  40671a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40671e:	48 89 02             	mov    %rax,(%rdx)
	p_pool->queue[p_pool->i_tail].args = args;
  406721:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406725:	48 8b 50 60          	mov    0x60(%rax),%rdx
  406729:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40672d:	8b 40 74             	mov    0x74(%rax),%eax
  406730:	48 98                	cltq   
  406732:	48 c1 e0 04          	shl    $0x4,%rax
  406736:	48 01 c2             	add    %rax,%rdx
  406739:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40673d:	48 89 42 08          	mov    %rax,0x8(%rdx)

	// Update the tail index
	p_pool->i_tail = (p_pool->i_tail + 1) % p_pool->i_queue_size;
  406741:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406745:	8b 40 74             	mov    0x74(%rax),%eax
  406748:	8d 50 01             	lea    0x1(%rax),%edx
  40674b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40674f:	8b 48 6c             	mov    0x6c(%rax),%ecx
  406752:	89 d0                	mov    %edx,%eax
  406754:	99                   	cltd   
  406755:	f7 f9                	idiv   %ecx
  406757:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40675b:	89 50 74             	mov    %edx,0x74(%rax)

	// Update the number of pending tasks
	p_pool->i_count++;
  40675e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406762:	8b 40 78             	mov    0x78(%rax),%eax
  406765:	8d 50 01             	lea    0x1(%rax),%edx
  406768:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40676c:	89 50 78             	mov    %edx,0x78(%rax)

	// Notify that there is new work in queue
	if (0 != pthread_cond_broadcast(&(p_pool->notify)))
  40676f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406773:	48 83 c0 28          	add    $0x28,%rax
  406777:	48 89 c7             	mov    %rax,%rdi
  40677a:	e8 f1 ad ff ff       	callq  401570 <pthread_cond_broadcast@plt>
  40677f:	85 c0                	test   %eax,%eax
  406781:	74 07                	je     40678a <gsi_is_thread_pool_add+0xff>
	{
		return GSI_TP_RC_ERROR;
  406783:	b8 01 00 00 00       	mov    $0x1,%eax
  406788:	eb 1c                	jmp    4067a6 <gsi_is_thread_pool_add+0x11b>
	}

	// Unlock the mutex
	if (0 != pthread_mutex_unlock(&p_pool->lock))
  40678a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40678e:	48 89 c7             	mov    %rax,%rdi
  406791:	e8 0a b0 ff ff       	callq  4017a0 <pthread_mutex_unlock@plt>
  406796:	85 c0                	test   %eax,%eax
  406798:	74 07                	je     4067a1 <gsi_is_thread_pool_add+0x116>
	{
		return GSI_TP_RC_ERROR;
  40679a:	b8 01 00 00 00       	mov    $0x1,%eax
  40679f:	eb 05                	jmp    4067a6 <gsi_is_thread_pool_add+0x11b>
	}

	return GSI_TP_RC_SUCCESS;
  4067a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4067a6:	c9                   	leaveq 
  4067a7:	c3                   	retq   

00000000004067a8 <gsi_is_thread_pool_destroy>:
	 * Parameter:   [in] int i_flags - Flags for shutdown - 1 default, 2 - graceful
	 * Return: 	    Success - GSI_TP_RC_SUCCESS
	 * 				Failure - GSI_TP_RC_ERROR *OR* GSI_TP_RC_INVALID
#############################################################################*/
enum gsi_thread_pool_rc gsi_is_thread_pool_destroy(gsi_thread_pool_t* p_pool, int i_flags)
{
  4067a8:	55                   	push   %rbp
  4067a9:	48 89 e5             	mov    %rsp,%rbp
  4067ac:	48 83 ec 20          	sub    $0x20,%rsp
  4067b0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4067b4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// Check input validation
	if (NULL == p_pool)
  4067b7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4067bc:	75 0a                	jne    4067c8 <gsi_is_thread_pool_destroy+0x20>
	{
		return GSI_TP_RC_INVALID;
  4067be:	b8 02 00 00 00       	mov    $0x2,%eax
  4067c3:	e9 d9 00 00 00       	jmpq   4068a1 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Try to lock the mutex to own the thread pool
	if (0 != pthread_mutex_lock(&(p_pool->lock)))
  4067c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4067cc:	48 89 c7             	mov    %rax,%rdi
  4067cf:	e8 0c b1 ff ff       	callq  4018e0 <pthread_mutex_lock@plt>
  4067d4:	85 c0                	test   %eax,%eax
  4067d6:	74 0a                	je     4067e2 <gsi_is_thread_pool_destroy+0x3a>
	{
		return GSI_TP_RC_ERROR;
  4067d8:	b8 01 00 00 00       	mov    $0x1,%eax
  4067dd:	e9 bf 00 00 00       	jmpq   4068a1 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Check if already in shutdown
	if (0 != p_pool->i_shutdown)
  4067e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4067e6:	8b 40 7c             	mov    0x7c(%rax),%eax
  4067e9:	85 c0                	test   %eax,%eax
  4067eb:	74 0a                	je     4067f7 <gsi_is_thread_pool_destroy+0x4f>
	{
		return GSI_TP_RC_ERROR;
  4067ed:	b8 01 00 00 00       	mov    $0x1,%eax
  4067f2:	e9 aa 00 00 00       	jmpq   4068a1 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Update shutdown according to i_flags
	if (GSI_TP_DESTROY_GRACEFUL == i_flags)
  4067f7:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  4067fb:	75 0d                	jne    40680a <gsi_is_thread_pool_destroy+0x62>
	{
		p_pool->i_shutdown = GSI_TP_DESTROY_GRACEFUL;
  4067fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406801:	c7 40 7c 01 00 00 00 	movl   $0x1,0x7c(%rax)
  406808:	eb 0b                	jmp    406815 <gsi_is_thread_pool_destroy+0x6d>
	}
	else
	{
		p_pool->i_shutdown = GSI_TP_DESTROY_IMMIDIATE;
  40680a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40680e:	c7 40 7c 02 00 00 00 	movl   $0x2,0x7c(%rax)
	}

	// Wake up all threads
	if (0 != pthread_cond_broadcast(&(p_pool->notify)))
  406815:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406819:	48 83 c0 28          	add    $0x28,%rax
  40681d:	48 89 c7             	mov    %rax,%rdi
  406820:	e8 4b ad ff ff       	callq  401570 <pthread_cond_broadcast@plt>
  406825:	85 c0                	test   %eax,%eax
  406827:	74 07                	je     406830 <gsi_is_thread_pool_destroy+0x88>
	{
		return GSI_TP_RC_ERROR;
  406829:	b8 01 00 00 00       	mov    $0x1,%eax
  40682e:	eb 71                	jmp    4068a1 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Unlock the mutex to get threads continue
	if (0 != pthread_mutex_unlock(&(p_pool->lock)))
  406830:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406834:	48 89 c7             	mov    %rax,%rdi
  406837:	e8 64 af ff ff       	callq  4017a0 <pthread_mutex_unlock@plt>
  40683c:	85 c0                	test   %eax,%eax
  40683e:	74 07                	je     406847 <gsi_is_thread_pool_destroy+0x9f>
	{
		return GSI_TP_RC_ERROR;
  406840:	b8 01 00 00 00       	mov    $0x1,%eax
  406845:	eb 5a                	jmp    4068a1 <gsi_is_thread_pool_destroy+0xf9>
	}

	// Join all worker thread
	for (int i = 0; i < p_pool->i_thread_count; ++i)
  406847:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40684e:	eb 34                	jmp    406884 <gsi_is_thread_pool_destroy+0xdc>
	{
		if (0 != pthread_join(p_pool->p_threads[i], NULL))
  406850:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406854:	48 8b 40 58          	mov    0x58(%rax),%rax
  406858:	8b 55 fc             	mov    -0x4(%rbp),%edx
  40685b:	48 63 d2             	movslq %edx,%rdx
  40685e:	48 c1 e2 03          	shl    $0x3,%rdx
  406862:	48 01 d0             	add    %rdx,%rax
  406865:	48 8b 00             	mov    (%rax),%rax
  406868:	be 00 00 00 00       	mov    $0x0,%esi
  40686d:	48 89 c7             	mov    %rax,%rdi
  406870:	e8 cb af ff ff       	callq  401840 <pthread_join@plt>
  406875:	85 c0                	test   %eax,%eax
  406877:	74 07                	je     406880 <gsi_is_thread_pool_destroy+0xd8>
		{
			return GSI_TP_RC_ERROR;
  406879:	b8 01 00 00 00       	mov    $0x1,%eax
  40687e:	eb 21                	jmp    4068a1 <gsi_is_thread_pool_destroy+0xf9>
	{
		return GSI_TP_RC_ERROR;
	}

	// Join all worker thread
	for (int i = 0; i < p_pool->i_thread_count; ++i)
  406880:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  406884:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406888:	8b 40 68             	mov    0x68(%rax),%eax
  40688b:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  40688e:	7f c0                	jg     406850 <gsi_is_thread_pool_destroy+0xa8>
			return GSI_TP_RC_ERROR;
		}
	}

	// Free the thread pool
	gsi_is_thread_pool_free(p_pool);
  406890:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406894:	48 89 c7             	mov    %rax,%rdi
  406897:	e8 57 01 00 00       	callq  4069f3 <gsi_is_thread_pool_free>

	return GSI_TP_RC_SUCCESS;
  40689c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4068a1:	c9                   	leaveq 
  4068a2:	c3                   	retq   

00000000004068a3 <gsi_is_thread_run>:
	 * Description: That is the main loop of each thread in thread pool
	 * Parameter:   [in] void* args - must be pointer to thread pool object
	 * Return:		NULL
#############################################################################*/
static void* gsi_is_thread_run(void* args)
{
  4068a3:	55                   	push   %rbp
  4068a4:	48 89 e5             	mov    %rsp,%rbp
  4068a7:	48 83 ec 30          	sub    $0x30,%rsp
  4068ab:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	gsi_thread_pool_t* p_pool = (gsi_thread_pool_t*)args;
  4068af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4068b3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	gsi_thread_pool_task_t task;

	// Check input validation
	if (NULL == args)
  4068b7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  4068bc:	75 0a                	jne    4068c8 <gsi_is_thread_run+0x25>
	{
		return NULL;
  4068be:	b8 00 00 00 00       	mov    $0x0,%eax
  4068c3:	e9 29 01 00 00       	jmpq   4069f1 <gsi_is_thread_run+0x14e>

	// Main loop
	while (1)
	{
		// Lock the mutex
		if (0 != pthread_mutex_lock(&(p_pool->lock)))
  4068c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4068cc:	48 89 c7             	mov    %rax,%rdi
  4068cf:	e8 0c b0 ff ff       	callq  4018e0 <pthread_mutex_lock@plt>
  4068d4:	85 c0                	test   %eax,%eax
  4068d6:	0f 85 e9 00 00 00    	jne    4069c5 <gsi_is_thread_run+0x122>
			break;
		}

		// Wait on condition variable until we have tasks, check for spurious wakeups.
        // When returning from pthread_cond_wait(), we own the lock.
		while ((p_pool->i_count == 0) && (!p_pool->i_shutdown))
  4068dc:	eb 17                	jmp    4068f5 <gsi_is_thread_run+0x52>
		{
			pthread_cond_wait(&(p_pool->notify), &(p_pool->lock));
  4068de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4068e2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4068e6:	48 83 c2 28          	add    $0x28,%rdx
  4068ea:	48 89 c6             	mov    %rax,%rsi
  4068ed:	48 89 d7             	mov    %rdx,%rdi
  4068f0:	e8 cb ac ff ff       	callq  4015c0 <pthread_cond_wait@plt>
			break;
		}

		// Wait on condition variable until we have tasks, check for spurious wakeups.
        // When returning from pthread_cond_wait(), we own the lock.
		while ((p_pool->i_count == 0) && (!p_pool->i_shutdown))
  4068f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4068f9:	8b 40 78             	mov    0x78(%rax),%eax
  4068fc:	85 c0                	test   %eax,%eax
  4068fe:	75 0b                	jne    40690b <gsi_is_thread_run+0x68>
  406900:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406904:	8b 40 7c             	mov    0x7c(%rax),%eax
  406907:	85 c0                	test   %eax,%eax
  406909:	74 d3                	je     4068de <gsi_is_thread_run+0x3b>
		{
			pthread_cond_wait(&(p_pool->notify), &(p_pool->lock));
		}

		// Check destroy status
		if ((p_pool->i_shutdown == GSI_TP_DESTROY_IMMIDIATE) ||
  40690b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40690f:	8b 40 7c             	mov    0x7c(%rax),%eax
  406912:	83 f8 02             	cmp    $0x2,%eax
  406915:	0f 84 ae 00 00 00    	je     4069c9 <gsi_is_thread_run+0x126>
		   ((p_pool->i_shutdown == GSI_TP_DESTROY_GRACEFUL) && (p_pool->i_count == 0)))
  40691b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40691f:	8b 40 7c             	mov    0x7c(%rax),%eax
		{
			pthread_cond_wait(&(p_pool->notify), &(p_pool->lock));
		}

		// Check destroy status
		if ((p_pool->i_shutdown == GSI_TP_DESTROY_IMMIDIATE) ||
  406922:	83 f8 01             	cmp    $0x1,%eax
  406925:	75 0f                	jne    406936 <gsi_is_thread_run+0x93>
		   ((p_pool->i_shutdown == GSI_TP_DESTROY_GRACEFUL) && (p_pool->i_count == 0)))
  406927:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40692b:	8b 40 78             	mov    0x78(%rax),%eax
  40692e:	85 c0                	test   %eax,%eax
  406930:	0f 84 93 00 00 00    	je     4069c9 <gsi_is_thread_run+0x126>
		{
			break;
		}

		// Get the first task
		task.thread_func = p_pool->queue[p_pool->i_head].thread_func;
  406936:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40693a:	48 8b 50 60          	mov    0x60(%rax),%rdx
  40693e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406942:	8b 40 70             	mov    0x70(%rax),%eax
  406945:	48 98                	cltq   
  406947:	48 c1 e0 04          	shl    $0x4,%rax
  40694b:	48 01 d0             	add    %rdx,%rax
  40694e:	48 8b 00             	mov    (%rax),%rax
  406951:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		task.args = p_pool->queue[p_pool->i_head].args;
  406955:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406959:	48 8b 50 60          	mov    0x60(%rax),%rdx
  40695d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406961:	8b 40 70             	mov    0x70(%rax),%eax
  406964:	48 98                	cltq   
  406966:	48 c1 e0 04          	shl    $0x4,%rax
  40696a:	48 01 d0             	add    %rdx,%rax
  40696d:	48 8b 40 08          	mov    0x8(%rax),%rax
  406971:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

		// Update the head index
		p_pool->i_head = (p_pool->i_head + 1) % p_pool->i_queue_size;
  406975:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406979:	8b 40 70             	mov    0x70(%rax),%eax
  40697c:	8d 50 01             	lea    0x1(%rax),%edx
  40697f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406983:	8b 48 6c             	mov    0x6c(%rax),%ecx
  406986:	89 d0                	mov    %edx,%eax
  406988:	99                   	cltd   
  406989:	f7 f9                	idiv   %ecx
  40698b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40698f:	89 50 70             	mov    %edx,0x70(%rax)

		// Decrease the number of pending tasks
		p_pool->i_count--;
  406992:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  406996:	8b 40 78             	mov    0x78(%rax),%eax
  406999:	8d 50 ff             	lea    -0x1(%rax),%edx
  40699c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4069a0:	89 50 78             	mov    %edx,0x78(%rax)

		// Unlock the mutex
		if (0 != pthread_mutex_unlock(&(p_pool->lock)))
  4069a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4069a7:	48 89 c7             	mov    %rax,%rdi
  4069aa:	e8 f1 ad ff ff       	callq  4017a0 <pthread_mutex_unlock@plt>
  4069af:	85 c0                	test   %eax,%eax
  4069b1:	75 15                	jne    4069c8 <gsi_is_thread_run+0x125>
		{
			break;
		}

		// Go to work
		(*(task.thread_func))(task.args);
  4069b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4069b7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4069bb:	48 89 d7             	mov    %rdx,%rdi
  4069be:	ff d0                	callq  *%rax
	}
  4069c0:	e9 03 ff ff ff       	jmpq   4068c8 <gsi_is_thread_run+0x25>
	while (1)
	{
		// Lock the mutex
		if (0 != pthread_mutex_lock(&(p_pool->lock)))
		{
			break;
  4069c5:	90                   	nop
  4069c6:	eb 01                	jmp    4069c9 <gsi_is_thread_run+0x126>
		p_pool->i_count--;

		// Unlock the mutex
		if (0 != pthread_mutex_unlock(&(p_pool->lock)))
		{
			break;
  4069c8:	90                   	nop
		// Go to work
		(*(task.thread_func))(task.args);
	}

	// Decrease the number of working threads
	p_pool->i_started--;
  4069c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4069cd:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
  4069d3:	8d 50 ff             	lea    -0x1(%rax),%edx
  4069d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4069da:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)

	// Unlock the mutex
	pthread_mutex_unlock(&(p_pool->lock));
  4069e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4069e4:	48 89 c7             	mov    %rax,%rdi
  4069e7:	e8 b4 ad ff ff       	callq  4017a0 <pthread_mutex_unlock@plt>

	return NULL;
  4069ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4069f1:	c9                   	leaveq 
  4069f2:	c3                   	retq   

00000000004069f3 <gsi_is_thread_pool_free>:
	 * Parameter:   [in] - gsi_thread_pool_t* p_pool - object to be free
	 * Return:		Success - GSI_TP_RC_SUCCESS
	 * 				Failure - GSI_TP_RC_ERROR *OR* GSI_TP_RC_INVALID
#############################################################################*/
static enum gsi_thread_pool_rc gsi_is_thread_pool_free(gsi_thread_pool_t* p_pool)
{
  4069f3:	55                   	push   %rbp
  4069f4:	48 89 e5             	mov    %rsp,%rbp
  4069f7:	48 83 ec 10          	sub    $0x10,%rsp
  4069fb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Check input validation
	if (NULL == p_pool)
  4069ff:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  406a04:	75 07                	jne    406a0d <gsi_is_thread_pool_free+0x1a>
	{
		return GSI_TP_RC_INVALID;
  406a06:	b8 02 00 00 00       	mov    $0x2,%eax
  406a0b:	eb 78                	jmp    406a85 <gsi_is_thread_pool_free+0x92>
	}

	// Check if there are still running threads
	if (0 < p_pool->i_started)
  406a0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406a11:	8b 80 80 00 00 00    	mov    0x80(%rax),%eax
  406a17:	85 c0                	test   %eax,%eax
  406a19:	7e 07                	jle    406a22 <gsi_is_thread_pool_free+0x2f>
	{
		return GSI_TP_RC_ERROR;
  406a1b:	b8 01 00 00 00       	mov    $0x1,%eax
  406a20:	eb 63                	jmp    406a85 <gsi_is_thread_pool_free+0x92>
	}

	free(p_pool->p_threads);
  406a22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406a26:	48 8b 40 58          	mov    0x58(%rax),%rax
  406a2a:	48 89 c7             	mov    %rax,%rdi
  406a2d:	e8 ee aa ff ff       	callq  401520 <free@plt>
	free(p_pool->queue);
  406a32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406a36:	48 8b 40 60          	mov    0x60(%rax),%rax
  406a3a:	48 89 c7             	mov    %rax,%rdi
  406a3d:	e8 de aa ff ff       	callq  401520 <free@plt>

	if (0 != pthread_mutex_destroy(&(p_pool->lock)))
  406a42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406a46:	48 89 c7             	mov    %rax,%rdi
  406a49:	e8 12 ac ff ff       	callq  401660 <pthread_mutex_destroy@plt>
  406a4e:	85 c0                	test   %eax,%eax
  406a50:	74 07                	je     406a59 <gsi_is_thread_pool_free+0x66>
	{
		return GSI_TP_RC_ERROR;
  406a52:	b8 01 00 00 00       	mov    $0x1,%eax
  406a57:	eb 2c                	jmp    406a85 <gsi_is_thread_pool_free+0x92>
	}

	if (0 != pthread_cond_destroy(&(p_pool->notify)))
  406a59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406a5d:	48 83 c0 28          	add    $0x28,%rax
  406a61:	48 89 c7             	mov    %rax,%rdi
  406a64:	e8 b7 ad ff ff       	callq  401820 <pthread_cond_destroy@plt>
  406a69:	85 c0                	test   %eax,%eax
  406a6b:	74 07                	je     406a74 <gsi_is_thread_pool_free+0x81>
	{
		return GSI_TP_RC_ERROR;
  406a6d:	b8 01 00 00 00       	mov    $0x1,%eax
  406a72:	eb 11                	jmp    406a85 <gsi_is_thread_pool_free+0x92>
	}

	free(p_pool);
  406a74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  406a78:	48 89 c7             	mov    %rax,%rdi
  406a7b:	e8 a0 aa ff ff       	callq  401520 <free@plt>

	return GSI_TP_RC_SUCCESS;
  406a80:	b8 00 00 00 00       	mov    $0x0,%eax
}
  406a85:	c9                   	leaveq 
  406a86:	c3                   	retq   
  406a87:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  406a8e:	00 00 

0000000000406a90 <__libc_csu_init>:
  406a90:	41 57                	push   %r15
  406a92:	41 56                	push   %r14
  406a94:	41 89 ff             	mov    %edi,%r15d
  406a97:	41 55                	push   %r13
  406a99:	41 54                	push   %r12
  406a9b:	4c 8d 25 4e 33 20 00 	lea    0x20334e(%rip),%r12        # 609df0 <__frame_dummy_init_array_entry>
  406aa2:	55                   	push   %rbp
  406aa3:	48 8d 2d 4e 33 20 00 	lea    0x20334e(%rip),%rbp        # 609df8 <__init_array_end>
  406aaa:	53                   	push   %rbx
  406aab:	49 89 f6             	mov    %rsi,%r14
  406aae:	49 89 d5             	mov    %rdx,%r13
  406ab1:	4c 29 e5             	sub    %r12,%rbp
  406ab4:	48 83 ec 08          	sub    $0x8,%rsp
  406ab8:	48 c1 fd 03          	sar    $0x3,%rbp
  406abc:	e8 17 aa ff ff       	callq  4014d8 <_init>
  406ac1:	48 85 ed             	test   %rbp,%rbp
  406ac4:	74 20                	je     406ae6 <__libc_csu_init+0x56>
  406ac6:	31 db                	xor    %ebx,%ebx
  406ac8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  406acf:	00 
  406ad0:	4c 89 ea             	mov    %r13,%rdx
  406ad3:	4c 89 f6             	mov    %r14,%rsi
  406ad6:	44 89 ff             	mov    %r15d,%edi
  406ad9:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  406add:	48 83 c3 01          	add    $0x1,%rbx
  406ae1:	48 39 eb             	cmp    %rbp,%rbx
  406ae4:	75 ea                	jne    406ad0 <__libc_csu_init+0x40>
  406ae6:	48 83 c4 08          	add    $0x8,%rsp
  406aea:	5b                   	pop    %rbx
  406aeb:	5d                   	pop    %rbp
  406aec:	41 5c                	pop    %r12
  406aee:	41 5d                	pop    %r13
  406af0:	41 5e                	pop    %r14
  406af2:	41 5f                	pop    %r15
  406af4:	c3                   	retq   
  406af5:	90                   	nop
  406af6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  406afd:	00 00 00 

0000000000406b00 <__libc_csu_fini>:
  406b00:	f3 c3                	repz retq 

Disassembly of section .fini:

0000000000406b04 <_fini>:
  406b04:	48 83 ec 08          	sub    $0x8,%rsp
  406b08:	48 83 c4 08          	add    $0x8,%rsp
  406b0c:	c3                   	retq   
